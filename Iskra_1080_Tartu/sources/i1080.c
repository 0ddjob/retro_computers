// Реверс-инженеринг ПЗУ компьютера Искра 1080 Тарту
// В процессе
// (c) 24-09-2020 Aleksey Morozov

asm (" device zxspectrum48");

// Используется в параметре UartSetMode
const int UART_SPEED_0 = 0;
const int UART_SPEED_1 = 1;
const int UART_SPEED_2 = 2;
const int UART_SPEED_3 = 3;

// Режим КР580ВВ51
const int UART_MODE__ASYNC_1 = 1; // Не используется в параметре UartSetMode
const int UART_MODE__ASYNC_16 = 2; // -//-
const int UART_MODE__ASYNC_64 = 3; // -//-
const int UART_MODE__ASYNC_MASK = 3; // -//-
const int UART_MODE__DATA_5 = 0 << 2;
const int UART_MODE__DATA_6 = 1 << 2;
const int UART_MODE__DATA_7 = 2 << 2;
const int UART_MODE__DATA_8 = 3 << 2;
const int UART_MODE__ODD = 1 << 4;
const int UART_MODE__CHECK = 1 << 5;
const int UART_MODE__STOP_1 = 1 << 6;
const int UART_MODE__STOP_15 = 2 << 6;
const int UART_MODE__STOP_2 = 3 << 6;

// Key codes
const int KEY_LEFT_DOWN = 0x81;
const int KEY_DOWN = 0x82;
const int KEY_RIGHT_DOWN = 0x83;
const int KEY_LEFT = 0x84;
const int KEY_RIGHT = 0x86;
const int KEY_LEFT_UP = 0x87;
const int KEY_UP = 0x88;
const int KEY_RIGHT_UP = 0x89;
const int KEY_EXT_0 = 0x80;
const int KEY_EXT_1 = 0x81;
const int KEY_EXT_2 = 0x82;
const int KEY_EXT_3 = 0x83;
const int KEY_EXT_4 = 0x84;
const int KEY_EXT_5 = 0x85;
const int KEY_EXT_6 = 0x86;
const int KEY_EXT_7 = 0x87;
const int KEY_EXT_8 = 0x88;
const int KEY_EXT_9 = 0x89;
const int KEY_EXT_POINT = 0x8A;
const int KEY_COP = 0x8B;
const int KEY_RUS = 0x8D;
const int KET_LAT = 0x8C;
const int KEY_CAPS_LOCK = 0x8E;
const int KEY_NUM_LOCK = 0x8F;
const int KEY_F1 = 0x90; // TODO: Проверить, что это F1 и т.д.
const int KEY_F2 = 0x91;
const int KEY_F3 = 0x92;
const int KEY_F4 = 0x93;
const int KEY_F5 = 0x94;
const int KEY_F6 = 0x95;

// Светодиоды. Биты порта PORT_KEYBOARD на запись.
const int LED_CAPS_LOCK = 0x10;
const int LED_NUM_LOCK = 0x20;

// Basic variables
extern uint8_t vPrintDisabled = 0x020E;
extern uint16_t word_26E = 0x26E;
extern uint16_t vBasicProgrammBegin = 0x0272;
extern uint16_t vBasicProgrammEnd = 0x0236;
extern uint16_t BasicEntry = 0xD000;

// Variables

extern uint8_t  vResetOpcode = 0x0000;
extern uint16_t vResetAddress = 0x0001;
extern uint16_t vCpmDisk = 0x0004;
extern uint8_t  Rst38  = 0x0038;

extern uint8_t  vTempVideoInverse        = 0x4C;
extern uint8_t  vTempVideoCursorX        = 0x4D;
extern uint8_t  vTempVideoFontHeight10   = 0x4E;
extern uint8_t  vTempVideoRom            = 0x4F;
extern uint8_t  vMonitorQuit             = 0xC7ED;
extern uint8_t  vMonitorQuitAddress      = 0xC7EE;
extern uint8_t  vPrint                   = 0xC7F0;
extern uint16_t vPrintAddress            = 0xC7F1;
extern uint8_t  vInput                   = 0xC7F3;
extern uint16_t vInputAddress            = 0xC7F4;
extern uint8_t  vTempMonitorProgramm0    = 0xC7F6;
extern uint8_t  vTempMonitorProgramm1    = 0xC7F7;
extern uint8_t  vTempMonitorProgramm2    = 0xC7F8;
extern uint8_t  vBiosReadWrite           = 0xC7FF;
extern uint16_t vKeyboardLayout          = 0xC800;
extern uint8_t  vVideoTextWidth          = 0xC802;
extern uint8_t  vVideoFontHeight10       = 0xC803;
extern uint8_t  vTempCall0000            = 0xC804;
extern uint8_t  vTempInputPrint          = 0xC806;
extern uint8_t  vVideoCursorX            = 0xC807;
extern uint8_t  vVideoCursorY            = 0xC808;
extern uint8_t  vVideoInverse            = 0xC809;
extern uint8_t  vVideoCursorAddress      = 0xC80A;
extern uint8_t  vUnused                  = 0xC80C;
extern uint8_t  vMonitorPrompt           = 0xC80D;
extern uint8_t  vTempMonitorArgument1    = 0xC80E;
extern uint16_t vTempMonitorArgument2    = 0xC810;
extern uint8_t  vMonitorArgument1        = 0xC812;
extern uint16_t vTempMonitorParse        = 0xC814;
extern uint8_t  vKeyboardLast            = 0xC816;
extern uint16_t vKeyboardDelay           = 0xC817;
extern uint16_t vVideoFont               = 0xC819;
extern uint8_t  vTempMonitorAble1        = 0xC81B;
extern uint8_t  vMonitorDirectiveIPort   = 0xC81C;
extern uint8_t  vMonitorDirectiveOPort   = 0xC81D;
extern uint16_t vTempSP                  = 0xC81E;
extern uint8_t  vVideoEscState           = 0xC820;
extern uint8_t  vVideoEscCursorState     = 0xC821;
extern uint8_t  vKeyboardCapsLock        = 0xC822;
extern uint8_t  vKeyboardNumLock         = 0xC823;
extern uint8_t  vKeyboardLeds            = 0xC824;
extern uint8_t  vInited12                = 0xC825;
extern uint8_t  vInited34                = 0xC826;
extern uint8_t  vTempRst38               = 0xC827;
extern uint8_t  vTempDisassembler        = 0xC828;
extern uint8_t  vTempTapeName            = 0xC829; // 6 символов
extern uint8_t  vTempTapeRequiredName    = 0xC82F;
extern uint8_t  vTempTapeRequiredType    = 0xC831;
extern uint8_t  vTempTapeFoundType       = 0xC832;
extern uint8_t  vTempTape1               = 0xC833;
extern uint8_t  vTempTapeAsciiRead       = 0xC835;
extern uint8_t  vTempTapeBegin           = 0xC837;
extern uint8_t  vTempTapeEnd             = 0xC839;
extern uint8_t  vTempTape2               = 0xC83B;
extern uint8_t  vTempTapeAscii           = 0xC83D;
extern uint8_t  vTempTapeFunction        = 0xC83F;
extern uint8_t  vTempTapeCounter         = 0xC841;
extern uint8_t  vTempTape3               = 0xC842;
extern uint8_t  vTempTape4               = 0xC843;
extern uint8_t  vKeyboardF1              = 0xC844; // TODO: Проверить, что это F1 и т.д.
extern uint8_t  vKeyboardF2              = 0xC845;
extern uint8_t  vKeyboardF3              = 0xC846;
extern uint8_t  vKeyboardF4              = 0xC847;
extern uint8_t  vKeyboardF5              = 0xC848;
extern uint8_t  vKeyboardF6              = 0xC849;
extern uint8_t  vUartWriteByte           = 0xC84A;
extern uint8_t  vMonitorStringLength     = 0xC900;
extern uint8_t  vMonitorString           = 0xC901;

// CP/B BIOS Routines
extern uint8_t BiosBoot2   = 0xC8A1;
extern uint8_t BiosInit2   = 0xC8B2;
extern uint8_t BiosLoadDph = 0xC8E4;
extern uint8_t BiosLoadCpm = 0xC905;
extern uint8_t BiosList2   = 0xC96A;
extern uint8_t BiosRead2   = 0xC984;
extern uint8_t BiosWrite2  = 0xC998;

// CP/M BIOS
extern uint8_t vBiosEntrySetTrk  = 0xB21E;
extern uint8_t vBiosEntrySetSec  = 0xB221;
extern uint8_t vBiosEntrySetDma  = 0xB224;
extern uint8_t vBiosEntryRead    = 0xB227;
extern uint8_t vBiosEntryWrite   = 0xB22A;
extern uint8_t vBiosEntryListSt  = 0xB22D;
extern uint8_t vBiosEntrySecTran = 0xB230;
extern uint8_t vBiosEntryDisks   = 0xB233;

// CP/M Variables
extern uint8_t vBiosDisk      = 0xB357;
extern uint8_t vBiosTrackLow  = 0xB358;
extern uint8_t vBiosTrackHigh = 0xB359;
extern uint8_t vBiosSector    = 0xB35A;
extern uint8_t vBiosDma       = 0xB35B;

// Strings
extern uint8_t romKeybaordEnglishLayout = 0xC000;
extern uint8_t romKeybaordRussianLayout = 0xC140;
extern uint8_t romDisassemlerOpcodes0   = 0xC280;
extern uint8_t romDisassemlerNames0     = 0xC2D7;
extern uint8_t asc_C2A1 = 0xC2A1;
extern uint8_t romDisassemlerNames1     = 0xC2D3;
extern uint8_t romPressPlayOnTape       = 0xC401; // 'Press PLAY on tape$'
extern uint8_t romAndAnyKeyOnKeyboard   = 0xC414; // ' & any key on keyboard$'
extern uint8_t romSearching             = 0xC42B; // 'Searching\r$'
extern uint8_t romFound                 = 0xC436; // 'Found $'
extern uint8_t romReading               = 0xC43D; // 'Reading\r$'
extern uint8_t romLoadError             = 0xC446; // 'Load error\r$'
extern uint8_t romVerifyError           = 0xC452; // 'Verify error\r$'
extern uint8_t romDone                  = 0xC460; // 'Done\r$'
extern uint8_t romPressRecord           = 0xC466; // 'Press RECORD &'
extern uint8_t romPlayOnTapeSaving      = 0xC474; // ' PLAY on tape$'
extern uint8_t romSaving                = 0xC482; // 'Saving\r$'
extern uint8_t romFileTooLong           = 0xC48A; // 'File too long\r$'
extern uint8_t romBasic                 = 0xC499; // '(BASIC)   $'
extern uint8_t romAscii                 = 0xC4A4; // '(ASCII)   $'
extern uint8_t romBinary                = 0xC4AF; // '(BINARY)  $'
extern uint8_t romUnknown               = 0xC4BA; // '(UNKNOWN) $'
extern uint8_t romNextWithoutFor        = 0xC4C5; // 'NEXT without FOR',0
extern uint8_t romSyntaxError           = 0xC4D6; // 'Syntax error',0
extern uint8_t romReturnWithoutGosub    = 0xC4E3; // 'RETURN without GOSUB',0
extern uint8_t romOutOfData             = 0xC4F8; // 'Out of DATA',0
extern uint8_t romIllegalValue          = 0xC504; // 'Illegal value',0
extern uint8_t romOverflow              = 0xC512; // 'Overflow',0
extern uint8_t romOutOfMemory           = 0xC51B; // 'Out of memory',0
extern uint8_t romUndefinedStatement    = 0xC529; // 'Undefined statement',0
extern uint8_t romBadSubscript          = 0xC53D; // 'Bad subscript',0
extern uint8_t romRedimDArray           = 0xC54B; // 'ReDIM\'d array',0
extern uint8_t romDivisionByZero        = 0xC559; // 'Division by zero',0
extern uint8_t romIllegalDirect         = 0xC56A; // 'Illegal direct',0
extern uint8_t romTypeMismatch          = 0xC579; // 'Type mismatch',0
extern uint8_t romOutOfStringSpace      = 0xC587; // 'Out of string space',0
extern uint8_t romStringTooLong         = 0xC59B; // 'String too long',0
extern uint8_t romFormulaTooComplex     = 0xC5AB; // 'Formula too complex',0
extern uint8_t romCanTContinue          = 0xC5BF; // 'Can\'t CONTinue',0
extern uint8_t romUndefinedFunction     = 0xC5CE; // 'Undefined function',0

// Basic hacks
extern uint8_t rst8a = 0xD006;
extern uint8_t basSyntaxError = 0xD13F;
extern uint8_t GetSymbolOrNumberEx = 0xD598;
extern uint8_t loc_D3FC = 0xD3FC;
extern uint8_t byte_241 = 0x241;
extern uint16_t vRst30ReturnAddress = 0x275;
extern uint8_t rst30a = 0xD00C;

const int TAPE_BINARY = 0xD0;
const int TAPE_BASIC = 0xD3;
const int TAPE_ASCII = 0xEA;

const int OPCODE_RET = 0xC9;
const int OPCODE_CALL = 0xC3;
const int OPCODE_IN = 0xDB;
const int OPCODE_OUT = 0xD3;
const int OPCODE_HALT = 0x76;

const int CPM_STACK_ADDRESS = 0x0080;
extern uint8_t cpmEntry = 0x9C00;
const int TEXT_SCREEN_ADDRESS = 0xC9C0;
const int FONT_ADDRESS = 0xC100;
const int STACK_ADDRESS = 0xC900;
const int TAPE_ASCII_BUFFER = 0x7F00;
const int TEXT_SCREEN_WIDTH = 64;
const int TEXT_SCREEN_HEIGHT = 25;
const int SCREEN_0_ADDRESS = 0xD000;
const int SCREEN_1_ADDRESS = 0x9000;
const int SCREEN_SIZE = 0x3000;
const int SCREEN_WIDTH = 384;
const int SCREEN_HEIGHT = 256;
const int BIT_PER_BYTE = 8;

const int PORT_80 = 0x80;
const int PORT_UART_DATA = 0x80;
const int PORT_UART_CONFIG = 0x81;
const int PORT_PALETTE_3 = 0x90;
const int PORT_PALETTE_2 = 0x91;
const int PORT_PALETTE_1 = 0x92;
const int PORT_PALETTE_0 = 0x93;
const int PORT_A0 = 0xA0;
const int PORT_ROM_0000 = 0xA8; // 0 - ПЗУ, 0x80/0xFF - ОЗУ
const int PORT_ROM_0000__ROM = 0;
const int PORT_ROM_0000__RAM = 0x80;
const int PORT_VIDEO_MODE_1_HIGH = 0xF9;
const int PORT_VIDEO_MODE_0_LOW = 0xB8;
const int PORT_UART_SPEED_0 = 0xBB;
const int PORT_KEYBOARD = 0xC0;
const int PORT_UART_SPEED_1 = 0xFB;
const int PORT_CODE_ROM = 0xBA;
const int PORT_CHARGEN_ROM = 0xFA;
const int PORT_TAPE_AND_IDX2 = 0x99;
const int PORT_TAPE_AND_IDX2_ID12 = 2;
const int PORT_RESET_CU1 = 0xBC;
const int PORT_RESET_CU2 = 0xBD;
const int PORT_RESET_CU3 = 0xBE;
const int PORT_RESET_CU4 = 0xBF;
const int PORT_SET_CU1 = 0xFC;
const int PORT_SET_CU2 = 0xFD;
const int PORT_SET_CU3 = 0xFE;
const int PORT_SET_CU4 = 0xFF;
const int PORT_TAPE_OUT = 0xB0;

asm(" org 0xC000");

void Rst0AtC000() {
    disable_interrupts();
    return Init();
    noreturn;
}

uint8_t data1[] = { 0xFF, 0xFF, 0x23, 0xE3 };

void Rst8AtC000() {
    a = *hl;
    swap(*sp, hl);
    return rst8a();
    noreturn;
}

void Rst8BAtC000() {
    if (flag_nz) return basSyntaxError();
    hl++;
    noreturn;
}

void Rst10AtC000() {
    a = *hl;
    if (a >= ':') return;
    return  GetSymbolOrNumberEx();
    noreturn;
}

void Rst18AtC000() {
    push(a);
    (a = vPrintDisabled) |= a;
    return loc_D3FC();
    noreturn;
}

void Rst20AtC000() {
    (a = h) -= d;
    if (flag_nz) return;
    (a = l) -= e;
}

uint8_t data2[] = { 0xFF, 0xFF };

extern uint8_t callE332 = 0xE332;

void Rst28AtC000() {
    a = byte_241;
    if (flag_nz a |= a) return callE332();
}

void Rst30AtC000() {
    swap(*sp, hl);
rst30b:
    vRst30ReturnAddress = hl;
    pop(hl);
    return rst30a();
    noreturn;
}

void Rst38AtC000() {
    return CallRamRst38Handler();
    noreturn;
}

uint8_t data3[] = {
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF,
    0xFF
};

void UnusedFunction1() {
    a = *bc;
}

void UnusedFunction2() {
    a = *de;
}

void UnusedFunction3() {
    a = *hl;
}

extern uint8_t VideoCopy0UpAt0000 = &VideoCopy0Up & 0x00FF;
extern uint8_t VideoCopy0UpLoop1At0000 = &VideoCopy0UpLoop1 & 0x00FF;
extern uint8_t VideoCopy0UpLoop2At0000 = &VideoCopy0UpLoop2 & 0x00FF;

const int SCROLL_SCREEN_UP_BLOCK = 8;
const int SCROLL_SCREEN_UP_COLUMN = 0x100;
const int SCROLL_SCREEN_UP_TO = 10;

void VideoCopy0Up() {
    // Сохранить SP
    vTempSP = ((hl = 0) += sp);
    // Поместить адрес записи в SP. +SCROLL_NEXT_COLUMN это компенсация уменьшения далее.
    sp = [SCREEN_0_ADDRESS + SCROLL_SCREEN_UP_COLUMN];
    // Перенос данных на SCROLL_BY строк выше. -1 это пропущенный hl-- далее.
    de = [-SCROLL_SCREEN_UP_TO - 1];
    // Цикл от 0x??00 до 0x??18
VideoCopy0UpLoop1:
        // Перемещение на первую строку. -SCROLL_BLOCK это компенсация увеличения далее.
        sp = ((hl = [SCREEN_SIZE - SCROLL_SCREEN_UP_BLOCK]) += sp);
        // Цикл от 0xFF?? до 0xD0??
        a = 0xD0;
VideoCopy0UpLoop2:
            // Перемещение на следущую колонку и возврат на туже строку
            hl = [-SCROLL_SCREEN_UP_COLUMN + SCROLL_SCREEN_UP_BLOCK];
            hl += sp;
            sp = hl;
            hl += de;

            // Копирование 8 строк из hl - 7 .. hl в sp - 8 .. sp - 1
            b = *hl;
            hl--;
            c = *hl;
            hl--;
            push(bc);

            b = *hl;
            hl--;
            c = *hl;
            hl--;
            push(bc);

            b = *hl;
            hl--;
            c = *hl;
            hl--;
            push(bc);

            b = *hl;
            hl--;
            c = *hl;
            push(bc);
            // Тут SP равно: FFF8, FEF8, FDF8 .. D0F8, FFF0...
        if (a != h) return VideoCopy0UpLoop2At0000();
        // Тут SP равно: D0F8, D0F0, D0E8 .. D010
    if ((a = l) >= 0x0C) return VideoCopy0UpLoop1At0000(); // 0x0C это не совсем точно, но работает
    // Восстановление SP
    sp = hl = vTempSP;
    noreturn;
}

// Тестирование компьютера при включении.
// Эта функция вызывается функцией Test.
// Подключается ПЗУ в адреса 0x0000 .. 0x00FF и вызывается адресу 0x00FF.

extern uint8_t TestRomAt0000 = &TestRom & 0x00FF;

void TestRom() {
}

uint8_t basic1[] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x08, 0x08,
  0x08, 0x00, 0x08, 0x00, 0x14, 0x14, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x14, 0x14, 0x3e, 0x14, 0x3e, 0x14, 0x14, 0x00, 0x22, 0x1c, 0x22, 0x22,
  0x22, 0x1c, 0x22, 0x00, 0x30, 0x32, 0x04, 0x08, 0x10, 0x26, 0x06, 0x00,
  0x10, 0x28, 0x28, 0x10, 0x2a, 0x24, 0x1a, 0x00, 0x08, 0x08, 0x08, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x08, 0x10, 0x20, 0x20, 0x20, 0x10, 0x08, 0x00,
  0x08, 0x04, 0x02, 0x02, 0x02, 0x04, 0x08, 0x00, 0x08, 0x2a, 0x1c, 0x08,
  0x1c, 0x2a, 0x08, 0x00, 0x00, 0x08, 0x08, 0x3e, 0x08, 0x08, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x18, 0x08, 0x10, 0x00, 0x00, 0x00, 0x00, 0x3e,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00,
  0x00, 0x02, 0x04, 0x08, 0x10, 0x20, 0x00, 0x00, 0x1c, 0x22, 0x26, 0x2a,
  0x32, 0x22, 0x1c, 0x00, 0x08, 0x18, 0x28, 0x08, 0x08, 0x08, 0x3c, 0x00,
  0x1c, 0x22, 0x02, 0x0c, 0x10, 0x20, 0x3e, 0x00, 0x3e, 0x02, 0x04, 0x0c,
  0x02, 0x22, 0x1c, 0x00, 0x04, 0x0c, 0x14, 0x24, 0x3e, 0x04, 0x04, 0x00,
  0x3e, 0x20, 0x3c, 0x02, 0x02, 0x22, 0x1c, 0x00, 0x0c, 0x10, 0x20, 0x3c,
  0x22, 0x22, 0x1c, 0x00, 0x3e, 0x02, 0x04, 0x08, 0x10, 0x10, 0x10, 0x00,
  0x1c, 0x22, 0x22, 0x1c, 0x22, 0x22, 0x1c, 0x00, 0x1c, 0x22, 0x22, 0x1e,
  0x02, 0x04, 0x38, 0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00,
  0x00, 0x18, 0x18, 0x00, 0x18, 0x08, 0x10, 0x00, 0x04, 0x08, 0x10, 0x20,
  0x10, 0x08, 0x04, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x3e, 0x00, 0x00, 0x00,
  0x10, 0x08, 0x04, 0x02, 0x04, 0x08, 0x10, 0x00, 0x1c, 0x22, 0x04, 0x08,
  0x08, 0x00, 0x08, 0x00, 0x1c, 0x22, 0x2a, 0x2e, 0x2c, 0x20, 0x1e, 0x00,
  0x08, 0x14, 0x22, 0x22, 0x3e, 0x22, 0x22, 0x00, 0x3c, 0x22, 0x22, 0x3c,
  0x22, 0x22, 0x3c, 0x00, 0x1c, 0x22, 0x20, 0x20, 0x20, 0x22, 0x1c, 0x00,
  0x3c, 0x22, 0x22, 0x22, 0x22, 0x22, 0x3c, 0x00, 0x3e, 0x20, 0x20, 0x3c,
  0x20, 0x20, 0x3e, 0x00, 0x3e, 0x20, 0x20, 0x3c, 0x20, 0x20, 0x20, 0x00,
  0x1e, 0x20, 0x20, 0x20, 0x26, 0x22, 0x1e, 0x00, 0x22, 0x22, 0x22, 0x3e,
  0x22, 0x22, 0x22, 0x00, 0x1c, 0x08, 0x08, 0x08, 0x08, 0x08, 0x1c, 0x00,
  0x02, 0x02, 0x02, 0x02, 0x02, 0x22, 0x1c, 0x00, 0x22, 0x24, 0x28, 0x30,
  0x28, 0x24, 0x22, 0x00, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3e, 0x00,
  0x22, 0x36, 0x2a, 0x2a, 0x22, 0x22, 0x22, 0x00, 0x22, 0x22, 0x32, 0x2a,
  0x26, 0x22, 0x22, 0x00, 0x1c, 0x22, 0x22, 0x22, 0x22, 0x22, 0x1c, 0x00,
  0x3c, 0x22, 0x22, 0x3c, 0x20, 0x20, 0x20, 0x00, 0x1c, 0x22, 0x22, 0x22,
  0x2a, 0x24, 0x1a, 0x00, 0x3c, 0x22, 0x22, 0x3c, 0x28, 0x24, 0x22, 0x00,
  0x1c, 0x22, 0x20, 0x1c, 0x02, 0x22, 0x1c, 0x00, 0x3e, 0x08, 0x08, 0x08,
  0x08, 0x08, 0x08, 0x00, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x1c, 0x00,
  0x22, 0x22, 0x22, 0x22, 0x22, 0x14, 0x08, 0x00, 0x22, 0x22, 0x22, 0x2a,
  0x2a, 0x36, 0x22, 0x00, 0x22, 0x22, 0x14, 0x08, 0x14, 0x22, 0x22, 0x00,
  0x22, 0x22, 0x14, 0x08, 0x08, 0x08, 0x08, 0x00, 0x3e, 0x02, 0x04, 0x08,
  0x10, 0x20, 0x3e, 0x00, 0x3e, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3e, 0x00,
  0x00, 0x20, 0x10, 0x08, 0x04, 0x02, 0x00, 0x00, 0x3e, 0x06, 0x06, 0x06,
  0x06, 0x06, 0x3e, 0x00, 0x00, 0x08, 0x14, 0x22, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x10, 0x08, 0x04, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x02, 0x1e, 0x22, 0x1e, 0x00,
  0x20, 0x20, 0x3c, 0x22, 0x22, 0x22, 0x3c, 0x00, 0x00, 0x00, 0x1e, 0x20,
  0x20, 0x20, 0x1e, 0x00, 0x02, 0x02, 0x1e, 0x22, 0x22, 0x22, 0x1e, 0x00,
  0x00, 0x00, 0x1c, 0x22, 0x3e, 0x20, 0x1e, 0x00, 0x0c, 0x12, 0x10, 0x3c,
  0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x1a, 0x26, 0x22, 0x1e, 0x02, 0x3c,
  0x20, 0x20, 0x3c, 0x22, 0x22, 0x22, 0x22, 0x00, 0x08, 0x00, 0x18, 0x08,
  0x08, 0x08, 0x1c, 0x00, 0x04, 0x00, 0x0c, 0x04, 0x04, 0x04, 0x24, 0x18,
  0x20, 0x20, 0x22, 0x24, 0x38, 0x24, 0x22, 0x00, 0x18, 0x08, 0x08, 0x08,
  0x08, 0x08, 0x1c, 0x00, 0x00, 0x00, 0x36, 0x2a, 0x2a, 0x2a, 0x2a, 0x00,
  0x00, 0x00, 0x2c, 0x32, 0x22, 0x22, 0x22, 0x00, 0x00, 0x00, 0x1c, 0x22,
  0x22, 0x22, 0x1c, 0x00, 0x00, 0x00, 0x3c, 0x22, 0x22, 0x3c, 0x20, 0x20,
  0x00, 0x00, 0x1e, 0x22, 0x22, 0x1e, 0x02, 0x02, 0x00, 0x00, 0x2e, 0x30,
  0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0x1e, 0x20, 0x1c, 0x02, 0x3c, 0x00,
  0x10, 0x10, 0x3c, 0x10, 0x10, 0x12, 0x0c, 0x00, 0x00, 0x00, 0x22, 0x22,
  0x22, 0x26, 0x1a, 0x00, 0x00, 0x00, 0x22, 0x22, 0x22, 0x14, 0x08, 0x00,
  0x00, 0x00, 0x22, 0x22, 0x2a, 0x2a, 0x36, 0x00, 0x00, 0x00, 0x22, 0x14,
  0x08, 0x14, 0x22, 0x00, 0x00, 0x00, 0x22, 0x22, 0x22, 0x1e, 0x02, 0x1c,
  0x00, 0x00, 0x3e, 0x04, 0x08, 0x10, 0x3e, 0x00, 0x0e, 0x18, 0x18, 0x30,
  0x18, 0x18, 0x0e, 0x00, 0x08, 0x08, 0x08, 0x00, 0x08, 0x08, 0x08, 0x00,
  0x38, 0x0c, 0x0c, 0x06, 0x0c, 0x0c, 0x38, 0x00, 0x7f, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x36, 0x36, 0x36, 0x00, 0x00, 0x22, 0x1c, 0x00,
  0x14, 0x14, 0x17, 0x10, 0x17, 0x14, 0x14, 0x14, 0x00, 0x00, 0xff, 0x00,
  0xff, 0x00, 0x00, 0x00, 0x14, 0x14, 0xff, 0x00, 0xff, 0x14, 0x14, 0x14,
  0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
  0xf8, 0x08, 0x08, 0x08, 0x00, 0x00, 0xff, 0x00, 0xff, 0x14, 0x14, 0x14,
  0x00, 0x00, 0x1f, 0x10, 0x17, 0x14, 0x14, 0x14, 0x14, 0x14, 0xf4, 0x04,
  0xfc, 0x00, 0x00, 0x00, 0x14, 0x14, 0x17, 0x10, 0x1f, 0x00, 0x00, 0x00,
  0x14, 0x14, 0xf4, 0x04, 0xf4, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14,
  0x14, 0x14, 0x14, 0x14, 0x00, 0x00, 0xfc, 0x04, 0xf4, 0x14, 0x14, 0x14,
  0x08, 0x08, 0xf8, 0x08, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0f, 0x08,
  0x0f, 0x08, 0x08, 0x08, 0x14, 0x14, 0x14, 0x14, 0xfc, 0x14, 0x14, 0x14,
  0x00, 0x00, 0x00, 0x00, 0xf8, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
  0x0f, 0x00, 0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0xff, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xff, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
  0x0f, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
  0x08, 0x08, 0x08, 0x08, 0xff, 0x08, 0x08, 0x08, 0x1c, 0x00, 0x1c, 0x22,
  0x22, 0x22, 0x1c, 0x00, 0x22, 0x08, 0x14, 0x22, 0x3e, 0x22, 0x22, 0x00,
  0x22, 0x00, 0x1c, 0x22, 0x22, 0x22, 0x1c, 0x00, 0x22, 0x00, 0x22, 0x22,
  0x22, 0x22, 0x1c, 0x00, 0x00, 0x1c, 0x00, 0x1c, 0x22, 0x22, 0x1c, 0x00,
  0x14, 0x00, 0x1c, 0x02, 0x1e, 0x22, 0x1e, 0x00, 0x00, 0x14, 0x00, 0x1c,
  0x22, 0x22, 0x1c, 0x00, 0x00, 0x14, 0x00, 0x22, 0x22, 0x26, 0x1a, 0x00,
  0x14, 0x14, 0xff, 0x00, 0xff, 0x14, 0x14, 0x14, 0x00, 0x00, 0x00, 0x00,
  0xfc, 0x14, 0x14, 0x14, 0x00, 0x00, 0xf8, 0x08, 0xf8, 0x08, 0x08, 0x08,
  0x14, 0x00, 0x3e, 0x20, 0x3c, 0x20, 0x3e, 0x00, 0x14, 0x14, 0x14, 0x14,
  0xfc, 0x00, 0x00, 0x00, 0x08, 0x08, 0xf8, 0x08, 0xf8, 0x00, 0x00, 0x00,
  0x08, 0x08, 0x0f, 0x08, 0x0f, 0x08, 0x08, 0x08, 0x14, 0x14, 0x14, 0x14,
  0xff, 0x00, 0x00, 0x00, 0x08, 0x08, 0x08, 0xff, 0x00, 0xff, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xff, 0x00, 0xff, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00,
  0xff, 0x14, 0x14, 0x14, 0x08, 0x08, 0x08, 0x08, 0xf8, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x0f, 0x08, 0x08, 0x08, 0x14, 0x14, 0x14, 0x14,
  0x1f, 0x00, 0x00, 0x00, 0x08, 0x08, 0x08, 0x0f, 0x08, 0x0f, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x0f, 0x08, 0x0f, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00,
  0x1f, 0x14, 0x14, 0x14, 0x08, 0x08, 0x08, 0xff, 0x08, 0xff, 0x08, 0x08,
  0x08, 0x14, 0x22, 0x22, 0x3e, 0x22, 0x22, 0x00, 0x3e, 0x20, 0x20, 0x3c,
  0x22, 0x22, 0x3c, 0x00, 0x3c, 0x22, 0x22, 0x3c, 0x22, 0x22, 0x3c, 0x00,
  0x3e, 0x22, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x0c, 0x14, 0x14, 0x14,
  0x14, 0x3e, 0x22, 0x00, 0x3e, 0x20, 0x20, 0x3c, 0x20, 0x20, 0x3e, 0x00,
  0x2a, 0x2a, 0x2a, 0x1c, 0x2a, 0x2a, 0x2a, 0x00, 0x1c, 0x22, 0x02, 0x0c,
  0x02, 0x22, 0x1c, 0x00, 0x22, 0x22, 0x26, 0x2a, 0x32, 0x22, 0x22, 0x00,
  0x14, 0x08, 0x22, 0x26, 0x2a, 0x32, 0x22, 0x00, 0x22, 0x24, 0x28, 0x30,
  0x28, 0x24, 0x22, 0x00, 0x06, 0x0a, 0x12, 0x12, 0x12, 0x12, 0x22, 0x00,
  0x22, 0x36, 0x2a, 0x22, 0x22, 0x22, 0x22, 0x00, 0x22, 0x22, 0x22, 0x3e,
  0x22, 0x22, 0x22, 0x00, 0x1c, 0x22, 0x22, 0x22, 0x22, 0x22, 0x1c, 0x00,
  0x3e, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x00, 0x3c, 0x22, 0x22, 0x3c,
  0x20, 0x20, 0x20, 0x00, 0x1c, 0x22, 0x20, 0x20, 0x20, 0x22, 0x1c, 0x00,
  0x3e, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x22, 0x22, 0x22, 0x1e,
  0x02, 0x22, 0x1c, 0x00, 0x08, 0x1c, 0x2a, 0x2a, 0x2a, 0x1c, 0x08, 0x00,
  0x22, 0x22, 0x14, 0x08, 0x14, 0x22, 0x22, 0x00, 0x24, 0x24, 0x24, 0x24,
  0x24, 0x3e, 0x02, 0x00, 0x22, 0x22, 0x22, 0x1e, 0x02, 0x02, 0x02, 0x00,
  0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x3e, 0x00, 0x2a, 0x2a, 0x2a, 0x2a,
  0x2a, 0x3e, 0x02, 0x00, 0x30, 0x10, 0x10, 0x1c, 0x12, 0x12, 0x1c, 0x00,
  0x22, 0x22, 0x32, 0x2a, 0x2a, 0x2a, 0x32, 0x00, 0x20, 0x20, 0x38, 0x24,
  0x22, 0x24, 0x38, 0x00, 0x1c, 0x22, 0x02, 0x1e, 0x02, 0x22, 0x1c, 0x00,
  0x2e, 0x2a, 0x2a, 0x3a, 0x2a, 0x2a, 0x2e, 0x00, 0x1e, 0x22, 0x22, 0x1e,
  0x0a, 0x12, 0x22, 0x00, 0x00, 0x00, 0x1c, 0x02, 0x1e, 0x22, 0x1e, 0x00,
  0x00, 0x00, 0x3e, 0x20, 0x3c, 0x22, 0x3c, 0x00, 0x00, 0x00, 0x3c, 0x22,
  0x3c, 0x22, 0x3c, 0x00, 0x00, 0x00, 0x3e, 0x22, 0x20, 0x20, 0x20, 0x00,
  0x00, 0x00, 0x0c, 0x14, 0x14, 0x14, 0x3e, 0x22, 0x00, 0x00, 0x1c, 0x22,
  0x3e, 0x20, 0x1e, 0x00, 0x00, 0x00, 0x2a, 0x2a, 0x1c, 0x2a, 0x2a, 0x00,
  0x00, 0x00, 0x1c, 0x22, 0x04, 0x02, 0x22, 0x1c, 0x00, 0x00, 0x22, 0x26,
  0x2a, 0x32, 0x22, 0x00, 0x00, 0x14, 0x08, 0x22, 0x26, 0x2a, 0x32, 0x00,
  0x00, 0x00, 0x22, 0x24, 0x38, 0x24, 0x22, 0x00, 0x00, 0x00, 0x0e, 0x0a,
  0x0a, 0x12, 0x22, 0x00, 0x00, 0x00, 0x22, 0x36, 0x2a, 0x22, 0x22, 0x00,
  0x00, 0x00, 0x22, 0x22, 0x3e, 0x22, 0x22, 0x00, 0x00, 0x00, 0x1c, 0x22,
  0x22, 0x22, 0x1c, 0x00, 0x00, 0x00, 0x3e, 0x22, 0x22, 0x22, 0x22, 0x00,
  0x00, 0x00, 0x3c, 0x22, 0x22, 0x3c, 0x20, 0x20, 0x00, 0x00, 0x1e, 0x20,
  0x20, 0x20, 0x1e, 0x00, 0x00, 0x00, 0x3e, 0x08, 0x08, 0x08, 0x08, 0x00,
  0x00, 0x00, 0x22, 0x22, 0x1e, 0x02, 0x02, 0x1c, 0x00, 0x00, 0x08, 0x3e,
  0x2a, 0x3e, 0x08, 0x08, 0x00, 0x00, 0x22, 0x14, 0x08, 0x14, 0x22, 0x00,
  0x00, 0x00, 0x24, 0x24, 0x24, 0x24, 0x3e, 0x02, 0x00, 0x00, 0x22, 0x22,
  0x1e, 0x02, 0x02, 0x00, 0x00, 0x00, 0x2a, 0x2a, 0x2a, 0x2a, 0x3e, 0x00,
  0x00, 0x00, 0x2a, 0x2a, 0x2a, 0x2a, 0x3e, 0x02, 0x00, 0x00, 0x30, 0x10,
  0x1c, 0x12, 0x1c, 0x00, 0x00, 0x00, 0x22, 0x22, 0x3a, 0x2a, 0x3a, 0x00,
  0x00, 0x00, 0x20, 0x20, 0x38, 0x24, 0x38, 0x00, 0x00, 0x00, 0x3c, 0x02,
  0x1e, 0x02, 0x3c, 0x00, 0x00, 0x00, 0x2e, 0x2a, 0x3a, 0x2a, 0x2e, 0x00,
  0x00, 0x00, 0x1e, 0x22, 0x1e, 0x12, 0x22, 0x00, 0x14, 0x14, 0x14, 0x14,
  0xff, 0x14, 0x14, 0x14, 0x14, 0x00, 0x1c, 0x22, 0x3e, 0x20, 0x1e, 0x00,
  0x08, 0x08, 0x3e, 0x08, 0x08, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x08, 0x00,
  0x3e, 0x00, 0x08, 0x00, 0x0c, 0x12, 0x12, 0x0c, 0x00, 0x00, 0x00, 0x00,
  0x0c, 0x12, 0x04, 0x08, 0x1e, 0x00, 0x00, 0x00, 0x1e, 0x04, 0x0c, 0x02,
  0x1c, 0x00, 0x00, 0x00, 0x08, 0x0c, 0x0a, 0x0a, 0x08, 0x18, 0x38, 0x10,
  0x08, 0x1c, 0x2a, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,
  0x08, 0x2a, 0x1c, 0x08, 0x00, 0x00, 0x04, 0x02, 0x3f, 0x02, 0x04, 0x00,
  0x00, 0x00, 0x08, 0x10, 0x3f, 0x10, 0x08, 0x00, 0x3c, 0x7e, 0xff, 0xff,
  0xff, 0xff, 0x7e, 0x3c, 0x00, 0x0c, 0x1e, 0x3f, 0x3f, 0x1e, 0x0c, 0x00,
  0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0x33, 0x33, 0xcc, 0xcc,
  0x33, 0x33, 0xcc, 0xcc, 0xc3, 0x24, 0xc8, 0xc3, 0xdd, 0xcb, 0xc3, 0x30,
  0xca, 0xc3, 0xa5, 0xca, 0xc3, 0x05, 0xcd, 0xc3, 0x11, 0xcd, 0xc3, 0x1d,
  0xcd, 0xc3, 0x29, 0xcd, 0xc3, 0x35, 0xcd, 0xc3, 0x3c, 0xcd, 0xc3, 0x43,
  0xcd, 0xc3, 0x4a, 0xcd, 0xe5, 0xd5, 0xc5, 0x21, 0x00, 0x80, 0xaf, 0x77,
  0x23, 0x77, 0x23, 0x77, 0x23, 0x22, 0xe6, 0x8f, 0x3a, 0xe2, 0x8f, 0x2f,
  0x5f, 0x2a, 0xe0, 0x8f, 0xcd, 0x3f, 0xca, 0xcd, 0x14, 0xca, 0x32, 0xea,
  0x8f, 0x4f, 0x3a, 0xe4, 0x8f, 0xe6, 0x03, 0x32, 0xe4, 0x8f, 0xb9, 0xca,
  0x6f, 0xc8, 0xcd, 0x73, 0xc8, 0xcd, 0x9d, 0xc8, 0xcd, 0x17, 0xc9, 0xcd,
  0x3b, 0xc9, 0xcd, 0x71, 0xc9, 0x7d, 0xb4, 0xca, 0x6f, 0xc8, 0xcd, 0x05,
  0xca, 0xd2, 0x55, 0xc8, 0xc3, 0x5e, 0xc8, 0xc1, 0xd1, 0xe1, 0xc9, 0xb7,
  0x78, 0x1f, 0x47, 0xd2, 0x84, 0xc8, 0x25, 0x15, 0x06, 0x80, 0x7c, 0xfe,
  0xcf, 0xca, 0x93, 0xc8, 0xcd, 0x05, 0xca, 0xda, 0x93, 0xc8, 0xcd, 0x24,
  0xca, 0xca, 0x7a, 0xc8, 0xc3, 0x73, 0xc8, 0xb7, 0x78, 0x17, 0x47, 0xd0,
  0x14, 0x24, 0x06, 0x01, 0xc9, 0xe5, 0xd5, 0xc5, 0x3a, 0xe4, 0x8f, 0x4f,
  0x1f, 0x78, 0xd2, 0xad, 0xc8, 0xb6, 0xc3, 0xaf, 0xc8, 0x2f, 0xa6, 0x77,
  0x79, 0x1f, 0x1f, 0x1a, 0x4f, 0x78, 0xd2, 0xbd, 0xc8, 0xb1, 0xc3, 0xbf,
  0xc8, 0x2f, 0xa1, 0x12, 0x7c, 0x32, 0xe8, 0x8f, 0xb7, 0x78, 0x32, 0xe9,
  0x8f, 0x17, 0x47, 0xd2, 0xde, 0xc8, 0x06, 0x80, 0x78, 0x32, 0xe9, 0x8f,
  0x7c, 0xfe, 0xff, 0xca, 0x13, 0xc9, 0x14, 0x24, 0x06, 0x01, 0xcd, 0x05,
  0xca, 0xda, 0x13, 0xc9, 0x7e, 0xb7, 0xca, 0xed, 0xc8, 0x3c, 0xc2, 0xa0,
  0xc8, 0x1a, 0xb7, 0xca, 0xf6, 0xc8, 0x3c, 0xc2, 0xa0, 0xc8, 0x3a, 0xe4,
  0x8f, 0x4f, 0x1f, 0x3e, 0xff, 0xda, 0x01, 0xc9, 0x3c, 0x77, 0x79, 0x1f,
  0x1f, 0x3e, 0xff, 0xda, 0x0b, 0xc9, 0x3c, 0x12, 0x7c, 0x32, 0xe8, 0x8f,
  0xc3, 0xce, 0xc8, 0xc1, 0xd1, 0xe1, 0xc9, 0xe5, 0xd5, 0xc5, 0x7d, 0xfe,
  0xff, 0xca, 0x37, 0xc9, 0x1c, 0x2c, 0xcd, 0x05, 0xca, 0xd2, 0x31, 0xc9,
  0xcd, 0x80, 0xc9, 0xdc, 0xb8, 0xc9, 0xc3, 0x37, 0xc9, 0xcd, 0x73, 0xc8,
  0xcd, 0xb8, 0xc9, 0xc1, 0xd1, 0xe1, 0xc9, 0xe5, 0xd5, 0xc5, 0x7d, 0xfe,
  0x00, 0xca, 0x5b, 0xc9, 0x1d, 0x2d, 0xcd, 0x05, 0xca, 0xd2, 0x55, 0xc9,
  0xcd, 0x80, 0xc9, 0xdc, 0xb8, 0xc9, 0xc3, 0x5b, 0xc9, 0xcd, 0x73, 0xc8,
  0xcd, 0xb8, 0xc9, 0xc1, 0xd1, 0xe1, 0xc9, 0xe5, 0xd5, 0xeb, 0x2a, 0xe6,
  0x8f, 0x72, 0x23, 0x73, 0x23, 0x70, 0x23, 0x22, 0xe6, 0x8f, 0xd1, 0xe1,
  0xc9, 0x2a, 0xe6, 0x8f, 0x2b, 0x46, 0x2b, 0x5e, 0x2b, 0x56, 0x22, 0xe6,
  0x8f, 0xc3, 0x82, 0xca, 0x3a, 0xe8, 0x8f, 0xbc, 0xc2, 0x8c, 0xc9, 0x3a,
  0xe9, 0x8f, 0xb8, 0xc8, 0xb7, 0x78, 0x17, 0x47, 0xd2, 0x9b, 0xc9, 0x7c,
  0xfe, 0xff, 0xc8, 0x14, 0x24, 0x06, 0x01, 0xcd, 0x05, 0xca, 0xd2, 0xb6,
  0xc9, 0xcd, 0x24, 0xca, 0xc2, 0x80, 0xc9, 0x3a, 0xe8, 0x8f, 0xbc, 0xc2,
  0x97, 0xc9, 0x3a, 0xe9, 0x8f, 0xb8, 0xc8, 0xc3, 0x8c, 0xc9, 0x37, 0xc9,
  0xe5, 0xd5, 0xc5, 0x0e, 0x00, 0xcd, 0x5f, 0xc9, 0x3a, 0xe8, 0x8f, 0xbc,
  0xc2, 0xce, 0xc9, 0x3a, 0xe9, 0x8f, 0xb8, 0xca, 0x01, 0xca, 0xb7, 0x78,
  0x17, 0x47, 0xd2, 0xdf, 0xc9, 0x06, 0x01, 0x7c, 0xfe, 0xff, 0xca, 0x01,
  0xca, 0x14, 0x24, 0xc5, 0xcd, 0x05, 0xca, 0xc1, 0xda, 0xef, 0xc9, 0x79,
  0xb7, 0xca, 0xf4, 0xc9, 0xc3, 0xbb, 0xc9, 0x0e, 0x01, 0xc3, 0xc0, 0xc9,
  0xcd, 0x24, 0xca, 0xc2, 0xc0, 0xc9, 0x3a, 0xe8, 0x8f, 0xbc, 0xc2, 0xd5,
  0xc9, 0xc1, 0xd1, 0xe1, 0xc9, 0xcd, 0x14, 0xca, 0x4f, 0x3a, 0xea, 0x8f,
  0xb9, 0xc2, 0x12, 0xca, 0xb7, 0xc9, 0x37, 0xc9, 0x1a, 0xa0, 0xca, 0x1b,
  0xca, 0x3e, 0x01, 0x17, 0x4f, 0x7e, 0xa0, 0x79, 0xc8, 0xf6, 0x01, 0xc9,
  0x7e, 0xb7, 0xca, 0x2b, 0xca, 0x3c, 0xc0, 0x1a, 0xb7, 0xc8, 0x3c, 0xc9,
  0x3a, 0xe2, 0x8f, 0x2f, 0x5f, 0x2a, 0xe0, 0x8f, 0xcd, 0x3f, 0xca, 0xcd,
  0x89, 0xca, 0xc9, 0x01, 0x80, 0x01, 0x7c, 0xb7, 0xf2, 0x4b, 0xca, 0x09,
  0xc3, 0x42, 0xca, 0x7d, 0xe6, 0x07, 0x57, 0xb7, 0x7c, 0x1f, 0x67, 0x7d,
  0x1f, 0x6f, 0xb7, 0x7c, 0x1f, 0x67, 0x7d, 0x1f, 0x6f, 0xb7, 0x7c, 0x1f,
  0x67, 0x7d, 0x1f, 0x6f, 0x01, 0xd0, 0xff, 0x09, 0x7c, 0xb7, 0xf2, 0x67,
  0xca, 0x7d, 0xc6, 0x30, 0x2f, 0x4a, 0x57, 0x3e, 0x07, 0x91, 0x4f, 0x3e,
  0x01, 0xca, 0x81, 0xca, 0x17, 0x0d, 0xc2, 0x7c, 0xca, 0x47, 0xeb, 0x7c,
  0xd6, 0x40, 0x57, 0x5d, 0xc9, 0x78, 0x2f, 0x4f, 0xa6, 0x77, 0x1a, 0xa1,
  0x12, 0x3a, 0xe4, 0x8f, 0x1f, 0xd2, 0x9d, 0xca, 0xf5, 0x78, 0xb6, 0x77,
  0xf1, 0x1f, 0xd2, 0xa4, 0xca, 0x1a, 0xb0, 0x12, 0xc9, 0x2a, 0xec, 0x8f,
  0xeb, 0x2a, 0xe8, 0x8f, 0xcd, 0x94, 0xcb, 0x19, 0xcd, 0x9c, 0xcb, 0x22,
  0xf0, 0x8f, 0xeb, 0x22, 0xf4, 0x8f, 0x2a, 0xee, 0x8f, 0xeb, 0x2a, 0xea,
  0x8f, 0xcd, 0x94, 0xcb, 0x19, 0xcd, 0x9c, 0xcb, 0x22, 0xf2, 0x8f, 0xeb,
  0x22, 0xf6, 0x8f, 0x2a, 0xf0, 0x8f, 0x7b, 0x95, 0x7a, 0x9c, 0xd2, 0x36,
  0xcb, 0x3a, 0xf5, 0x8f, 0xb7, 0xc4, 0xae, 0xcb, 0x2a, 0xea, 0x8f, 0x22,
  0xfe, 0x8f, 0x21, 0x00, 0x00, 0x22, 0xfa, 0x8f, 0x2a, 0xe8, 0x8f, 0x22,
  0xfc, 0x8f, 0x22, 0xe0, 0x8f, 0x3a, 0xfe, 0x8f, 0x32, 0xe2, 0x8f, 0xcd,
  0x30, 0xca, 0x2a, 0xfa, 0x8f, 0xeb, 0x2a, 0xf2, 0x8f, 0x19, 0x22, 0xfa,
  0x8f, 0xeb, 0x2a, 0xf0, 0x8f, 0x7b, 0x95, 0x7a, 0x9c, 0xda, 0x26, 0xcb,
  0xcd, 0x94, 0xcb, 0x19, 0x22, 0xfa, 0x8f, 0x2a, 0xfe, 0x8f, 0xeb, 0x2a,
  0xf6, 0x8f, 0x19, 0x22, 0xfe, 0x8f, 0x2a, 0xfc, 0x8f, 0xeb, 0x2a, 0xec,
  0x8f, 0xcd, 0xa8, 0xcb, 0xc8, 0xeb, 0x23, 0xc3, 0xef, 0xca, 0x3a, 0xf7,
  0x8f, 0xb7, 0xc4, 0xae, 0xcb, 0x2a, 0xe8, 0x8f, 0x22, 0xfc, 0x8f, 0x26,
  0x00, 0x6c, 0x22, 0xf8, 0x8f, 0x2a, 0xea, 0x8f, 0x22, 0xfe, 0x8f, 0x7d,
  0x32, 0xe2, 0x8f, 0x2a, 0xfc, 0x8f, 0x22, 0xe0, 0x8f, 0xcd, 0x30, 0xca,
  0x2a, 0xf8, 0x8f, 0xeb, 0x2a, 0xf0, 0x8f, 0x19, 0x22, 0xf8, 0x8f, 0xeb,
  0x2a, 0xf2, 0x8f, 0x7b, 0x95, 0x7a, 0x9c, 0xda, 0x84, 0xcb, 0xcd, 0x94,
  0xcb, 0x19, 0x22, 0xf8, 0x8f, 0x2a, 0xfc, 0x8f, 0xeb, 0x2a, 0xf4, 0x8f,
  0x19, 0x22, 0xfc, 0x8f, 0x2a, 0xfe, 0x8f, 0xeb, 0x2a, 0xee, 0x8f, 0xcd,
  0xa8, 0xcb, 0xc8, 0xeb, 0x23, 0xc3, 0x4c, 0xcb, 0x7c, 0x2f, 0x67, 0x7d,
  0x2f, 0x6f, 0x23, 0xc9, 0x7c, 0xb7, 0x11, 0x01, 0x00, 0xf0, 0xcd, 0x94,
  0xcb, 0x1b, 0x1b, 0xc9, 0x7b, 0xbd, 0xc0, 0x7a, 0xbc, 0xc9, 0x2a, 0xe8,
  0x8f, 0xeb, 0x2a, 0xec, 0x8f, 0x22, 0xe8, 0x8f, 0xeb, 0x22, 0xec, 0x8f,
  0x2a, 0xea, 0x8f, 0xeb, 0x2a, 0xee, 0x8f, 0x22, 0xea, 0x8f, 0xeb, 0x22,
  0xee, 0x8f, 0x2a, 0xf4, 0x8f, 0xcd, 0x94, 0xcb, 0x22, 0xf4, 0x8f, 0x2a,
  0xf6, 0x8f, 0xcd, 0x94, 0xcb, 0x22, 0xf6, 0x8f, 0xc9, 0xe5, 0xd5, 0xc5,
  0x2a, 0xe0, 0x8f, 0x22, 0xee, 0x8f, 0x2a, 0xe2, 0x8f, 0x22, 0xf0, 0x8f,
  0x21, 0x00, 0x00, 0x22, 0xea, 0x8f, 0x2a, 0xe6, 0x8f, 0x22, 0xec, 0x8f,
  0xcd, 0x94, 0xcb, 0x29, 0x01, 0x03, 0x00, 0x09, 0x22, 0xe8, 0x8f, 0x2a,
  0xec, 0x8f, 0xeb, 0x2a, 0xea, 0x8f, 0xcd, 0xe2, 0xcc, 0xd2, 0x56, 0xcc,
  0xcd, 0x5d, 0xcc, 0x2a, 0xe8, 0x8f, 0x7c, 0xb7, 0xfa, 0x3e, 0xcc, 0x2a,
  0xec, 0x8f, 0xcd, 0x94, 0xcb, 0xeb, 0x2a, 0xea, 0x8f, 0x19, 0x29, 0x29,
  0x01, 0x0a, 0x00, 0x09, 0xeb, 0x2a, 0xe8, 0x8f, 0x19, 0x22, 0xe8, 0x8f,
  0x2a, 0xec, 0x8f, 0x2b, 0x22, 0xec, 0x8f, 0xc3, 0x4c, 0xcc, 0xeb, 0x2a,
  0xea, 0x8f, 0x29, 0x29, 0x19, 0x11, 0x06, 0x00, 0x19, 0x22, 0xe8, 0x8f,
  0x2a, 0xea, 0x8f, 0x23, 0x22, 0xea, 0x8f, 0xc3, 0x03, 0xcc, 0xcc, 0x5d,
  0xcc, 0xc1, 0xd1, 0xe1, 0xc9, 0x2a, 0xee, 0x8f, 0xeb, 0x2a, 0xf0, 0x8f,
  0x4d, 0x44, 0x2a, 0xea, 0x8f, 0xe5, 0x19, 0x22, 0xe0, 0x8f, 0x2a, 0xec,
  0x8f, 0xe5, 0x09, 0x22, 0xe2, 0x8f, 0xcd, 0xfb, 0xcc, 0xe1, 0x19, 0x22,
  0xe0, 0x8f, 0xe1, 0x09, 0x22, 0xe2, 0x8f, 0xcd, 0xfb, 0xcc, 0x2a, 0xea,
  0x8f, 0xcd, 0x94, 0xcb, 0xe5, 0x09, 0x22, 0xe2, 0x8f, 0xcd, 0xfb, 0xcc,
  0x2a, 0xea, 0x8f, 0x19, 0x22, 0xe0, 0x8f, 0x2a, 0xec, 0x8f, 0xcd, 0x94,
  0xcb, 0x09, 0x22, 0xe2, 0x8f, 0xcd, 0xfb, 0xcc, 0xe1, 0xe5, 0x19, 0x22,
  0xe0, 0x8f, 0xcd, 0xfb, 0xcc, 0x2a, 0xec, 0x8f, 0xcd, 0x94, 0xcb, 0x19,
  0x22, 0xe0, 0x8f, 0xe1, 0x09, 0x22, 0xe2, 0x8f, 0xcd, 0xfb, 0xcc, 0x2a,
  0xea, 0x8f, 0x09, 0x22, 0xe2, 0x8f, 0xcd, 0xfb, 0xcc, 0x2a, 0xea, 0x8f,
  0xcd, 0x94, 0xcb, 0x19, 0x22, 0xe0, 0x8f, 0x2a, 0xec, 0x8f, 0x09, 0x22,
  0xe2, 0x8f, 0xcd, 0xfb, 0xcc, 0xc9, 0x7c, 0xb7, 0xf2, 0xee, 0xcc, 0x7a,
  0xb7, 0xfa, 0xf5, 0xcc, 0x37, 0xc9, 0x7a, 0xb7, 0xf2, 0xf5, 0xcc, 0xaf,
  0xc9, 0x7c, 0x92, 0xc0, 0x7d, 0x93, 0xc9, 0xc5, 0xd5, 0xe5, 0xcd, 0x30,
  0xca, 0xe1, 0xd1, 0xc1, 0xc9, 0x3a, 0x04, 0x02, 0xe6, 0x0f, 0x32, 0xc0,
  0x8f, 0x2f, 0xd3, 0x90, 0xc9, 0x3a, 0x06, 0x02, 0xe6, 0x0f, 0x32, 0xc1,
  0x8f, 0x2f, 0xd3, 0x91, 0xc9, 0x3a, 0x08, 0x02, 0xe6, 0x0f, 0x32, 0xc2,
  0x8f, 0x2f, 0xd3, 0x92, 0xc9, 0x3a, 0x0a, 0x02, 0xe6, 0x0f, 0x32, 0xc3,
  0x8f, 0x2f, 0xd3, 0x93, 0xc9, 0x3a, 0xc0, 0x8f, 0x32, 0xe0, 0x8f, 0xc9,
  0x3a, 0xc1, 0x8f, 0x32, 0xe0, 0x8f, 0xc9, 0x3a, 0xc2, 0x8f, 0x32, 0xe0,
  0x8f, 0xc9, 0x3a, 0xc3, 0x8f, 0x32, 0xe0, 0x8f, 0xc9
};

// Вывод символа на экран в режиме 64 символа в строке
// Вызывается функцией VideoPrintChar

void VideoDrawChar64() {
    // Запоминаем, было ли подключено ПЗУ
    vTempVideoRom = (a ^= a);
    vTempVideoRom = a = vTempVideoRom;

    // Подключаем ОЗУ
    out(PORT_ROM_0000, a = PORT_ROM_0000__RAM);

    a = e; // Непонятно
    swap(de, hl);
    l = a; // Непонятно
    
    // Вычисление адреса текстового столбца в видеопамяти
    a = vTempVideoCursorX;
    a >>r= 2;
    a &= 0x1F;
    h = a;
    (a += h) += h;
    invert(a);
    h = a;

    // Вызов одной из функций наложения символа на изображение в видеопамяти
    a = vTempVideoCursorX;
    a >>r= 1;
    if (flag_nc) {
        a >>r= 1;
        if (flag_c) return VideoDrawChar64X2(); // С битовым сдвигом >> 2
        return VideoDrawChar64X0(); // С битовым сдвигом << 2
    }
    a >>r= 1;
    if (flag_c) return VideoDrawChar64X3(); // Без сдвига
    return VideoDrawChar64X1(); // С битовым сдвигом >> 4
    noreturn;
}

// Вывод символа на экран в режиме 64 символа в строке
// Функция для символов в координатах (X % 4) == 0
// Вызывается функцией VideoDrawChar64

void VideoDrawChar64X0() {
    VideoDrawChar64X0L(c = 8);
    if (flag_z (a = vTempVideoFontHeight10) |= a) {
        de = &cZeroZero;
    }
    VideoDrawChar64X0L(c = 2);
    return VideoDrawChar64End();
    noreturn;
}

// Вызывается функцией VideoDrawChar64X0

void VideoDrawChar64X0L() {
    do {
        b = ((a = *de) <<@= 2);
        b = (((a = vTempVideoInverse) ^= b) &= 0xFC);
        *hl = (((a = *hl) &= 3) |= b);        
        de++;
        hl--;
    } while(flag_nz c--);
}

// Вывод символа на экран в режиме 64 символа в строке
// Функция для символов в координатах (X % 4) == 1
// Вызывается функцией VideoDrawChar64

void VideoDrawChar64X1() {
    VideoDrawChar64X1L(a = 8);
    if (flag_z (a = vTempVideoFontHeight10) |= a) {
        de = &cZeroZero;
    }
    VideoDrawChar64X1L(a = 2);
    return VideoDrawChar64End();
    noreturn;
}

// Вызывается функцией VideoDrawChar64X1

void VideoDrawChar64X1L() {
    do {
        push(a) {
            c = a = vTempVideoInverse;
            c = (((a = *de) >>r= 4) ^= c);
            b = (a &= 3);
            c = ((a = c) &= 0xF0);
            *hl = (((a = *hl) &= 0xFC) |= b);
            h--;
            *hl = (((a = *hl) &= 0x0F) |= c);
            h++;
            de++;
            hl--;
        }
    } while (flag_nz a--);
}

// Вывод символа на экран в режиме 64 символа в строке
// Функция для символов в координатах (X % 4) == 2
// Вызывается функцией VideoDrawChar64

void VideoDrawChar64X2() {
    h--;
    VideoDrawChar64X2L(a = 8);
    if (flag_z (a = vTempVideoFontHeight10) |= a) {
        de = &cZeroZero;
    }
    VideoDrawChar64X2L(a = 2);
    return VideoDrawChar64End();
    noreturn;
}

// Вызывается функцией VideoDrawChar64X2

void VideoDrawChar64X2L() {
    do {
        push(a) {
            c = a = vTempVideoInverse;
            c = (((a = *de) >>r= 2) ^= c);
            b = (a &= 0xF);     
            c = ((a = c) &= 0xC0);
            *hl = (((a = *hl) &= 0xF0) |= b);
            h--;
            *hl = (((a = *hl) &= 0x3F) |= c);
            h++;
            de++;
            hl--;
        }
    } while(flag_nz a--);
}

// Вывод символа на экран в режиме 64 символа в строке
// Функция для символов в координатах (X % 4) == 3
// Вызывается функцией VideoDrawChar64

void VideoDrawChar64X3() {
    h--;
    h--;
    VideoDrawChar64X3L(c = 8);
    if (flag_z (a = vTempVideoFontHeight10) |= a) {
        de = &cZeroZero;
    }
    VideoDrawChar64X3L(c = 2);
    return VideoDrawChar64End();
    noreturn;
}

// Вызывается функцией VideoDrawChar64X3

void VideoDrawChar64X3L() {
    do {
        b = a = *de;
        b = (((a = vTempVideoInverse) ^= b) &= 0x3F);
        *hl = (((a = *hl) &= 0xC0) |= b);
        de++;
        hl--;
    } while(flag_nz c--);
}

// Завершение вывода символа на экран в режиме 64 символа в строке
// Вызывается функциями VideoDrawChar64X0, 1, 2, 3

void VideoDrawChar64End() {
    if (flag_z (a = vTempVideoRom) |= a) return VideoDrawCharEnd();
    out (PORT_ROM_0000, a ^= a); // Подключаем ПЗУ, тут a == PORT_ROM_0000__ROM
    return VideoDrawCharEnd();
    noreturn;
}

// Используется для рисования межстрочного интервала.
uint8_t cZeroZero[2];

asm(" org 0xCFF0");

void CopyFromHiddenRom1() {
    while () {
        if ((a = c) == e) {
            if ((a = b) == d) return;
        }
        *hl = a = *bc;
        bc++;
        hl++;
    }
    noreturn;
}

void TestRomC000() {
    rst(0x38);
    noreturn;
}

asm(" org 0xD000");

uint8_t basic2[] = {
  0xc3, 0xc4, 0xea, 0xc3, 0x03, 0xeb, 0xbe, 0x23, 0xe3, 0xc3, 0x0d, 0x00,
  0x4e, 0x23, 0x46, 0x23, 0xc5, 0xc3, 0x74, 0x02, 0x3c, 0xe3, 0xfa, 0xe3,
  0x50, 0xe3, 0x9a, 0xe7, 0x8b, 0xdd, 0x86, 0xe0, 0xb9, 0xdd, 0xbc, 0xe5,
  0x92, 0xe6, 0xee, 0xe1, 0x01, 0xe6, 0xc4, 0xe6, 0xca, 0xe6, 0x27, 0xe7,
  0x3c, 0xe7, 0x88, 0xe7, 0xf8, 0xdf, 0x30, 0xde, 0xbe, 0xe0, 0x07, 0xe0,
  0x15, 0xe0, 0x25, 0xe0, 0x55, 0xe0, 0x5f, 0xe0, 0x8a, 0xe9, 0x79, 0xb4,
  0xe4, 0x79, 0xed, 0xe0, 0x7b, 0x2a, 0xe2, 0x7b, 0x8a, 0xe2, 0x7f, 0xc5,
  0xe5, 0x50, 0x89, 0xdb, 0x46, 0x88, 0xdb, 0xf3, 0xe7, 0xfd, 0xd7, 0x44,
  0xd4, 0xa1, 0xd7, 0x55, 0xd9, 0x27, 0xdc, 0x7f, 0xd9, 0xcc, 0xe7, 0xc9,
  0xd7, 0xfc, 0xd4, 0x88, 0xd8, 0xcc, 0xd6, 0xb9, 0xd7, 0xe5, 0xd7, 0x23,
  0xda, 0xe0, 0xd6, 0x92, 0xe0, 0x69, 0xd8, 0x2f, 0xe8, 0x6e, 0xe8, 0x90,
  0xe7, 0xa9, 0xd8, 0xc1, 0xdd, 0x08, 0xd7, 0xfb, 0xd7, 0x78, 0xd7, 0xd0,
  0xe9, 0xba, 0xe9, 0x35, 0xea, 0x8f, 0xea, 0x4a, 0xd2, 0x98, 0xf7, 0x93,
  0xf7, 0x2a, 0xd6, 0x69, 0xd6, 0x6c, 0xd6, 0xd5, 0xe8, 0xad, 0xe8, 0x73,
  0xea, 0x56, 0xea, 0xff, 0xe8, 0x34, 0xe8, 0x36, 0xe9, 0xf3, 0xe7, 0xc5,
  0xc4, 0xd6, 0xc4, 0xe3, 0xc4, 0xf8, 0xc4, 0x04, 0xc5, 0x12, 0xc5, 0x1b,
  0xc5, 0x29, 0xc5, 0x3d, 0xc5, 0x4b, 0xc5, 0x59, 0xc5, 0x6a, 0xc5, 0x79,
  0xc5, 0x87, 0xc5, 0x9b, 0xc5, 0xab, 0xc5, 0xbf, 0xc5, 0xce, 0xc5, 0x20,
  0x69, 0x6e, 0x20, 0x00, 0x0d, 0x4f, 0x4b, 0x0d, 0x00, 0x0d, 0x42, 0x72,
  0x65, 0x61, 0x6b, 0x07, 0x00, 0x21, 0x04, 0x00, 0x39, 0x7e, 0x23, 0xfe,
  0x81, 0xc0, 0x4e, 0x23, 0x46, 0x23, 0xe5, 0x69, 0x60, 0x7a, 0xb3, 0xeb,
  0xca, 0x01, 0xd1, 0xeb, 0xe7, 0x01, 0x0d, 0x00, 0xe1, 0xc8, 0x09, 0xc3,
  0xed, 0xd0, 0xcd, 0x2a, 0xd1, 0xc5, 0xe3, 0xc1, 0xe7, 0x7e, 0x02, 0xc8,
  0x0b, 0x2b, 0xc3, 0x10, 0xd1, 0xe3, 0x4e, 0x23, 0xe3, 0xe5, 0x2a, 0x3a,
  0x02, 0x06, 0x00, 0x09, 0x09, 0xcd, 0x2a, 0xd1, 0xe1, 0xc9, 0xd5, 0xeb,
  0x21, 0xda, 0xff, 0x39, 0xe7, 0xeb, 0xd1, 0xd0, 0x1e, 0x0c, 0xc3, 0x47,
  0xd1, 0x2a, 0x28, 0x02, 0x22, 0x30, 0x02, 0x1e, 0x02, 0x01, 0x1e, 0x14,
  0x01, 0x1e, 0x00, 0xcd, 0x6f, 0xd2, 0xaf, 0x32, 0x0e, 0x02, 0xcd, 0xf3,
  0xd8, 0x21, 0xb3, 0xd0, 0x57, 0x3e, 0x07, 0xdf, 0x19, 0x7e, 0x23, 0x66,
  0x6f, 0xf5, 0xd5, 0x11, 0xc8, 0x01, 0xd3, 0xfa, 0x7e, 0x12, 0x23, 0x13,
  0xb7, 0xc2, 0x64, 0xd1, 0xd3, 0xba, 0xd1, 0xf1, 0x21, 0xc8, 0x01, 0xcd,
  0xa4, 0xde, 0x2a, 0x30, 0x02, 0x7c, 0xa5, 0x3c, 0xc4, 0xc5, 0xe4, 0xaf,
  0x32, 0x0e, 0x02, 0x21, 0xff, 0xff, 0x22, 0x30, 0x02, 0x21, 0xdc, 0xd0,
  0xcd, 0xa4, 0xde, 0xcd, 0xd4, 0xd3, 0xd7, 0x3c, 0x3d, 0xca, 0x8f, 0xd1,
  0xf5, 0xcd, 0x44, 0xd7, 0xd5, 0x2b, 0x2b, 0x7e, 0x23, 0xfe, 0x20, 0xca,
  0x9d, 0xd1, 0x23, 0xcd, 0xa0, 0xd2, 0x47, 0xd1, 0xf1, 0xd2, 0x75, 0xd5,
  0xd5, 0xc5, 0xd7, 0xf5, 0xcd, 0x32, 0xd2, 0xc5, 0xd2, 0xcd, 0xd1, 0xeb,
  0x2a, 0x36, 0x02, 0x1a, 0x02, 0x03, 0x13, 0xe7, 0xd2, 0xbf, 0xd1, 0x60,
  0x69, 0x23, 0x22, 0x36, 0x02, 0xd1, 0xf1, 0xca, 0xf9, 0xd1, 0x2a, 0x36,
  0x02, 0xe3, 0xc1, 0x09, 0xe5, 0xcd, 0x0a, 0xd1, 0xe1, 0x22, 0x36, 0x02,
  0xeb, 0x74, 0x23, 0x23, 0xd1, 0x73, 0x23, 0x72, 0x23, 0x11, 0x01, 0x01,
  0x1a, 0x77, 0x23, 0x13, 0xfe, 0xf0, 0xca, 0x27, 0xd2, 0xb7, 0xc2, 0xec,
  0xd1, 0xcd, 0x56, 0xd2, 0x23, 0x54, 0x5d, 0x7e, 0x23, 0xb6, 0xca, 0x8f,
  0xd1, 0x23, 0x23, 0x23, 0xaf, 0xbe, 0xf5, 0x7e, 0xfe, 0xf0, 0xca, 0x1f,
  0xd2, 0xaf, 0xf1, 0x23, 0xc2, 0x09, 0xd2, 0xeb, 0x73, 0x23, 0x72, 0xeb,
  0xc3, 0xfd, 0xd1, 0xf1, 0xaf, 0x23, 0x23, 0x23, 0xc3, 0x09, 0xd2, 0x1a,
  0x77, 0x13, 0x23, 0x1a, 0x77, 0x23, 0x13, 0xc3, 0xec, 0xd1, 0x2a, 0x72,
  0x02, 0x44, 0x4d, 0x7e, 0x23, 0xb6, 0x2b, 0xc8, 0xc5, 0xf7, 0xf7, 0xe1,
  0xe7, 0xe1, 0xc1, 0x3f, 0xc8, 0x3f, 0xd0, 0xc3, 0x35, 0xd2, 0xc0, 0x2a,
  0x72, 0x02, 0xaf, 0x77, 0x23, 0x77, 0x23, 0x22, 0x36, 0x02, 0x2a, 0x72,
  0x02, 0x2b, 0x22, 0x2c, 0x02, 0x2a, 0x6e, 0x02, 0x22, 0x24, 0x02, 0xcd,
  0xcc, 0xd6, 0x2a, 0x36, 0x02, 0x22, 0x38, 0x02, 0x22, 0x3a, 0x02, 0xc1,
  0x2a, 0x70, 0x02, 0xf9, 0x21, 0x14, 0x02, 0x22, 0x12, 0x02, 0x21, 0x00,
  0x00, 0xe5, 0x22, 0x34, 0x02, 0x2a, 0x2c, 0x02, 0xaf, 0x32, 0x2a, 0x02,
  0xc5, 0xc9, 0x3a, 0x58, 0x02, 0xfe, 0x22, 0x3e, 0x00, 0x32, 0x58, 0x02,
  0xca, 0xd4, 0xd3, 0x3e, 0x3f, 0xdf, 0x3e, 0x20, 0xdf, 0xc3, 0xd4, 0xd3,
  0xaf, 0x32, 0x11, 0x02, 0x0e, 0x05, 0x11, 0x01, 0x01, 0x7e, 0xfe, 0x20,
  0xca, 0x08, 0xd3, 0x47, 0xfe, 0x22, 0xca, 0x5b, 0xd3, 0xb7, 0xca, 0xc1,
  0xd3, 0x3a, 0x11, 0x02, 0xb7, 0x47, 0x7e, 0xc2, 0x08, 0xd3, 0xfe, 0x3f,
  0x3e, 0x95, 0xca, 0x08, 0xd3, 0x7e, 0xfe, 0x30, 0xda, 0xd4, 0xd2, 0xfe,
  0x3c, 0xda, 0x08, 0xd3, 0xd5, 0x11, 0xe0, 0xc5, 0xe5, 0x3e, 0xd7, 0x13,
  0xd3, 0xfa, 0x1a, 0xd3, 0xba, 0xe6, 0x7f, 0xca, 0x05, 0xd3, 0xbe, 0xca,
  0xf7, 0xd2, 0xee, 0x20, 0xbe, 0xca, 0xf5, 0xd2, 0xee, 0x20, 0xc3, 0x72,
  0xd3, 0xee, 0x20, 0xd3, 0xfa, 0x1a, 0xd3, 0xba, 0xb7, 0xf2, 0xda, 0xd2,
  0xf1, 0x78, 0xf6, 0x80, 0xf2, 0xe1, 0x7e, 0xd1, 0xf5, 0x3a, 0x11, 0x02,
  0xfe, 0x5e, 0xc2, 0x15, 0xd3, 0xf1, 0xc3, 0x22, 0xd3, 0xf1, 0xfe, 0x61,
  0xda, 0x22, 0xd3, 0xfe, 0x7b, 0xd2, 0x22, 0xd3, 0xe6, 0xdf, 0x23, 0x12,
  0x13, 0x0c, 0xfe, 0x88, 0xca, 0x9b, 0xd3, 0xfe, 0xb0, 0xca, 0x83, 0xd3,
  0xfe, 0x8c, 0xca, 0x9b, 0xd3, 0xfe, 0x82, 0xca, 0x62, 0xd3, 0xfe, 0x83,
  0xca, 0x62, 0xd3, 0xd6, 0x3a, 0xca, 0x49, 0xd3, 0xfe, 0x5e, 0xc2, 0x4c,
  0xd3, 0x32, 0x11, 0x02, 0xd6, 0x47, 0xc2, 0xa9, 0xd2, 0x47, 0x7e, 0xb7,
  0xca, 0xc1, 0xd3, 0xb8, 0xca, 0x08, 0xd3, 0x23, 0x12, 0x0c, 0x13, 0xc3,
  0x52, 0xd3, 0xf5, 0xe5, 0xd7, 0xe1, 0xda, 0x9a, 0xd3, 0x3e, 0x20, 0x12,
  0x13, 0x0c, 0xf1, 0xc3, 0x3f, 0xd3, 0xe1, 0xe5, 0x04, 0xeb, 0xd3, 0xfa,
  0xb6, 0xd3, 0xba, 0x23, 0xf2, 0x76, 0xd3, 0xeb, 0xc3, 0xdc, 0xd2, 0xf5,
  0xe5, 0xd7, 0xe1, 0xda, 0x8e, 0xd3, 0xf1, 0xc3, 0x3f, 0xd3, 0xeb, 0x3e,
  0x20, 0x77, 0x23, 0x3e, 0x88, 0x77, 0x23, 0xeb, 0x0c, 0x0c, 0xf1, 0xc5,
  0xd5, 0xcd, 0x44, 0xd7, 0xe3, 0x3e, 0xf0, 0x77, 0x23, 0x73, 0x23, 0x72,
  0x23, 0xeb, 0xe1, 0xc1, 0x2b, 0x0c, 0x0c, 0xd7, 0x0c, 0x7e, 0xfe, 0x2c,
  0xca, 0xba, 0xd3, 0xc3, 0xa9, 0xd2, 0x12, 0x13, 0x23, 0x0c, 0xc3, 0x9b,
  0xd3, 0x21, 0x00, 0x01, 0x12, 0x13, 0x12, 0x13, 0x12, 0xc9, 0x05, 0x2b,
  0xdf, 0xc2, 0xd9, 0xd3, 0xdf, 0xcd, 0xf3, 0xd8, 0x21, 0x01, 0x01, 0x06,
  0x01, 0xcd, 0x1b, 0xd4, 0xfe, 0x08, 0xca, 0xca, 0xd3, 0xfe, 0x0d, 0xca,
  0xee, 0xd8, 0xfe, 0x18, 0xca, 0xd0, 0xd3, 0x4f, 0x78, 0xfe, 0xfa, 0x3e,
  0x07, 0xd2, 0xf8, 0xd3, 0x79, 0x71, 0x23, 0x04, 0xdf, 0xc3, 0xd9, 0xd3,
  0xc2, 0xd5, 0xde, 0xf1, 0xf5, 0xfe, 0x20, 0xda, 0x14, 0xd4, 0x3a, 0x0d,
  0x02, 0xfe, 0x40, 0xc2, 0x10, 0xd4, 0x3e, 0x00, 0x3c, 0x32, 0x0d, 0x02,
  0xf1, 0xf5, 0xcd, 0xf0, 0xc7, 0xf1, 0xc9, 0xcd, 0xf3, 0xc7, 0xfe, 0x1f,
  0xc0, 0x3e, 0x7f, 0x32, 0x0d, 0xc8, 0x32, 0x16, 0xc8, 0x3e, 0xc3, 0x32,
  0xed, 0xc7, 0x21, 0x03, 0xd0, 0x22, 0xee, 0xc7, 0x3e, 0x80, 0xd3, 0xa8,
  0x3e, 0x07, 0xcd, 0xf0, 0xc7, 0x21, 0x3c, 0xf4, 0x22, 0x01, 0x00, 0xe9,
  0xaf, 0x32, 0x6b, 0x02, 0x32, 0x09, 0xc8, 0xcd, 0x65, 0xd7, 0xc0, 0xc1,
  0xcd, 0x32, 0xd2, 0xc5, 0xe1, 0xf7, 0xc1, 0x78, 0xb1, 0xc2, 0x62, 0xd4,
  0x3e, 0x1a, 0xdf, 0xc3, 0x7f, 0xd1, 0xcd, 0xd6, 0xd6, 0xc5, 0xcd, 0xf3,
  0xd8, 0xf7, 0xe3, 0xcd, 0xcd, 0xe4, 0x3e, 0x20, 0xe1, 0xfe, 0x04, 0xca,
  0x98, 0xd4, 0xdf, 0x7e, 0xb7, 0x23, 0xc2, 0xa1, 0xd4, 0x32, 0x6b, 0x02,
  0xc3, 0x54, 0xd4, 0x3e, 0x20, 0xdf, 0xe5, 0xd5, 0xc5, 0x5e, 0x23, 0x56,
  0xeb, 0xcd, 0xcd, 0xe4, 0xc1, 0xd1, 0xe1, 0x23, 0x23, 0xc3, 0x77, 0xd4,
  0x3e, 0x5e, 0xdf, 0x3e, 0x44, 0xdf, 0xc3, 0x77, 0xd4, 0xfa, 0xb5, 0xd4,
  0xfe, 0x22, 0xc2, 0x71, 0xd4, 0x3a, 0x6b, 0x02, 0x2f, 0x32, 0x6b, 0x02,
  0x3e, 0x22, 0xc3, 0x71, 0xd4, 0x3a, 0x6b, 0x02, 0xb7, 0x2b, 0x7e, 0x23,
  0xc2, 0x71, 0xd4, 0xfe, 0xf0, 0xca, 0x83, 0xd4, 0xd6, 0x7f, 0x4f, 0xe5,
  0x11, 0xe1, 0xc5, 0xd5, 0xd3, 0xfa, 0x1a, 0xd3, 0xba, 0x13, 0xb7, 0xf2,
  0xcc, 0xd4, 0x0d, 0xe1, 0xc2, 0xcb, 0xd4, 0xd3, 0xfa, 0x7e, 0xd3, 0xba,
  0xb7, 0xf2, 0xf7, 0xd4, 0xfe, 0xf0, 0xca, 0x83, 0xd4, 0xe6, 0x7f, 0xc3,
  0x70, 0xd4, 0xcd, 0xc5, 0xe4, 0x23, 0x23, 0x7e, 0xc3, 0x71, 0xd4, 0xdf,
  0x23, 0xc3, 0xdb, 0xd4, 0x3e, 0x64, 0x32, 0x2a, 0x02, 0xcd, 0x1d, 0xd8,
  0xe3, 0xcd, 0xe9, 0xd0, 0xd1, 0xc2, 0x0e, 0xd5, 0x09, 0xf9, 0xeb, 0xcd,
  0x19, 0xd1, 0x08, 0xe5, 0xcd, 0xfb, 0xd7, 0xe3, 0xe5, 0x2a, 0x30, 0x02,
  0xe3, 0xcd, 0x6f, 0xda, 0xcf, 0xad, 0xcd, 0x6c, 0xda, 0xe5, 0xcd, 0x75,
  0xe3, 0xe1, 0xc5, 0xd5, 0x01, 0x00, 0x81, 0x51, 0x5a, 0x7e, 0xfe, 0xb2,
  0x3e, 0x01, 0xc2, 0x43, 0xd5, 0xd7, 0xcd, 0x6c, 0xda, 0xe5, 0xcd, 0x75,
  0xe3, 0xe1, 0xef, 0xc5, 0xd5, 0xf5, 0x33, 0xe5, 0x2a, 0x2c, 0x02, 0xe3,
  0x06, 0x81, 0xc5, 0x33, 0xcd, 0x94, 0xfb, 0xfe, 0xff, 0xc4, 0xdb, 0xd6,
  0x22, 0x2c, 0x02, 0x7e, 0xfe, 0x3a, 0xca, 0x75, 0xd5, 0xb7, 0xc2, 0x3f,
  0xd1, 0x23, 0x7e, 0x23, 0xb6, 0x23, 0xca, 0xe7, 0xd6, 0x5e, 0x23, 0x56,
  0xeb, 0x22, 0x30, 0x02, 0xeb, 0xd7, 0x11, 0x50, 0xd5, 0xd5, 0xc8, 0xd6,
  0x80, 0xda, 0x1d, 0xd8, 0xfe, 0x2c, 0xd2, 0x3f, 0xd1, 0x07, 0x4f, 0x06,
  0x00, 0xeb, 0x21, 0x5b, 0xd0, 0x09, 0x4e, 0x23, 0x46, 0xc5, 0xeb, 0x23,
  0x7e, 0xfe, 0x3a, 0xd0, 0xfe, 0x20, 0xca, 0x93, 0xd5, 0xfe, 0x30, 0x3f,
  0x3c, 0x3d, 0xc9, 0x78, 0xb1, 0xc2, 0xab, 0xd5, 0x01, 0x0a, 0x00, 0x2a,
  0x72, 0x02, 0xe5, 0x23, 0x23, 0x5e, 0x23, 0x56, 0xeb, 0x22, 0x6c, 0x02,
  0xeb, 0xc3, 0xbc, 0xd5, 0xe1, 0xe5, 0x23, 0x23, 0x5e, 0x3a, 0x6c, 0x02,
  0x77, 0x23, 0x56, 0x3a, 0x6d, 0x02, 0x77, 0x23, 0x2a, 0x72, 0x02, 0x23,
  0x23, 0x23, 0x23, 0x7e, 0xfe, 0xf0, 0xca, 0xef, 0xd5, 0xfe, 0xf1, 0xca,
  0xe9, 0xd5, 0xb7, 0xca, 0x5e, 0xd6, 0xca, 0x17, 0xd6, 0x23, 0xc3, 0xd3,
  0xd5, 0x23, 0x23, 0x23, 0xc3, 0xd3, 0xd5, 0x23, 0x7e, 0xbb, 0xca, 0xfa,
  0xd5, 0x23, 0x23, 0xc3, 0xd3, 0xd5, 0x23, 0x7e, 0xba, 0xca, 0x04, 0xd6,
  0x23, 0xc3, 0xd3, 0xd5, 0x2b, 0x2b, 0x3e, 0xf1, 0x77, 0x23, 0x3a, 0x6c,
  0x02, 0x77, 0x23, 0x3a, 0x6d, 0x02, 0x77, 0x23, 0xc3, 0xd3, 0xd5, 0x2a,
  0x6c, 0x02, 0x09, 0x22, 0x6c, 0x02, 0xe1, 0x5e, 0x23, 0x7e, 0xb7, 0xc8,
  0x57, 0xeb, 0xe5, 0xc3, 0xbc, 0xd5, 0xcd, 0x44, 0xd7, 0x42, 0x4b, 0xe5,
  0xcd, 0xa3, 0xd5, 0x2a, 0x72, 0x02, 0x23, 0x23, 0x23, 0x23, 0x7e, 0xfe,
  0xf1, 0xca, 0x4c, 0xd6, 0xfe, 0xf0, 0xca, 0x37, 0xd6, 0xb7, 0xca, 0x52,
  0xd6, 0xc3, 0x39, 0xd6, 0x3e, 0xf0, 0x77, 0xc3, 0x37, 0xd6, 0x23, 0x23,
  0x7e, 0xb7, 0xeb, 0xe1, 0xc8, 0xe5, 0xeb, 0xc3, 0x37, 0xd6, 0x23, 0x23,
  0x7e, 0xb7, 0xca, 0x17, 0xd6, 0x2b, 0xc3, 0xcf, 0xd5, 0xc3, 0x7f, 0xd1,
  0xe5, 0x2a, 0x72, 0x02, 0x2b, 0x23, 0x5e, 0x23, 0x56, 0x7a, 0xb3, 0xca,
  0xb1, 0xd6, 0x23, 0x23, 0x23, 0x7e, 0xfe, 0xa2, 0xca, 0x8f, 0xd6, 0xfe,
  0xf0, 0xca, 0xac, 0xd6, 0xb7, 0xca, 0x71, 0xd6, 0xc3, 0x7c, 0xd6, 0xeb,
  0x5e, 0x23, 0x56, 0x7a, 0xb3, 0xca, 0xb1, 0xd6, 0x23, 0x4e, 0x23, 0x46,
  0x23, 0xc5, 0xd5, 0xcd, 0xff, 0xff, 0xd1, 0xe1, 0xc1, 0xda, 0xbc, 0xd6,
  0xc5, 0xc3, 0x8f, 0xd6, 0x23, 0x23, 0xc3, 0x7c, 0xd6, 0xe1, 0xc9, 0x23,
  0x7e, 0x2b, 0xb7, 0xc8, 0x23, 0xc3, 0xb3, 0xd6, 0x11, 0xd7, 0xd0, 0x1a,
  0x13, 0xdf, 0xb7, 0xc2, 0xbf, 0xd6, 0xcd, 0xcd, 0xe4, 0xc3, 0x69, 0xd6,
  0xeb, 0x2a, 0x72, 0x02, 0x2b, 0x22, 0x3c, 0x02, 0xeb, 0xc9, 0xcd, 0x94,
  0xfb, 0x3c, 0xc8, 0xcd, 0x94, 0xfb, 0xfe, 0x03, 0xc0, 0xf6, 0xc0, 0x22,
  0x2c, 0x02, 0xc1, 0xf5, 0x2a, 0x30, 0x02, 0x7d, 0xa4, 0x3c, 0xca, 0xfa,
  0xd6, 0x22, 0x32, 0x02, 0x2a, 0x2c, 0x02, 0x22, 0x34, 0x02, 0xaf, 0x32,
  0x0e, 0x02, 0xf1, 0x21, 0xe1, 0xd0, 0xc2, 0x73, 0xd1, 0xc3, 0x7f, 0xd1,
  0xc0, 0x1e, 0x20, 0x2a, 0x34, 0x02, 0x7c, 0xb5, 0xca, 0x47, 0xd1, 0xeb,
  0x2a, 0x32, 0x02, 0x22, 0x30, 0x02, 0xeb, 0xc9, 0x7e, 0xfe, 0x41, 0xd8,
  0xfe, 0x5b, 0x3f, 0xc9, 0xd7, 0xcd, 0x6c, 0xda, 0xef, 0xfa, 0x3f, 0xd7,
  0x3a, 0x41, 0x02, 0xfe, 0x91, 0xda, 0xcf, 0xe3, 0x01, 0x80, 0x90, 0x11,
  0x00, 0x00, 0xcd, 0xa4, 0xe3, 0x51, 0xc8, 0x1e, 0x08, 0xc3, 0x47, 0xd1,
  0x2b, 0x11, 0x00, 0x00, 0xd7, 0xd0, 0xe5, 0xf5, 0x21, 0x98, 0x19, 0xe7,
  0xda, 0x3f, 0xd1, 0x62, 0x6b, 0x19, 0x29, 0x19, 0x29, 0xf1, 0xd6, 0x30,
  0x5f, 0x16, 0x00, 0x19, 0xeb, 0xe1, 0xc3, 0x48, 0xd7, 0x23, 0x5e, 0x23,
  0x56, 0xc9, 0x7e, 0xfe, 0xf0, 0xc2, 0x75, 0xd7, 0xcd, 0x65, 0xd7, 0x37,
  0xc9, 0xfe, 0x00, 0xc9, 0xca, 0x5a, 0xd2, 0xcd, 0x25, 0xd7, 0x2b, 0xd7,
  0xc0, 0xe5, 0x2a, 0x6e, 0x02, 0x7d, 0x93, 0x5f, 0x7c, 0x9a, 0x57, 0xda,
  0x3f, 0xd1, 0x2a, 0x36, 0x02, 0x01, 0x28, 0x00, 0x09, 0xe7, 0xd2, 0x34,
  0xd1, 0xeb, 0x22, 0x70, 0x02, 0xe1, 0xc3, 0x5a, 0xd2, 0xca, 0x56, 0xd2,
  0xe5, 0x21, 0x03, 0x01, 0x7e, 0x23, 0x6e, 0xb5, 0xe1, 0xca, 0x56, 0xd2,
  0xcd, 0x5a, 0xd2, 0x01, 0x50, 0xd5, 0xc3, 0xc8, 0xd7, 0xcd, 0x19, 0xd1,
  0x03, 0xc1, 0xe5, 0xe5, 0x2a, 0x30, 0x02, 0xe3, 0x16, 0x8c, 0xd5, 0x33,
  0xc5, 0xcd, 0x65, 0xd7, 0xcd, 0xfd, 0xd7, 0xe5, 0x2a, 0x30, 0x02, 0xe7,
  0xe1, 0x23, 0xdc, 0x35, 0xd2, 0xd4, 0x32, 0xd2, 0x60, 0x69, 0x2b, 0xd8,
  0x1e, 0x0e, 0xc3, 0x47, 0xd1, 0xc0, 0x16, 0xff, 0xcd, 0xe9, 0xd0, 0xf9,
  0xfe, 0x8c, 0x1e, 0x04, 0xc2, 0x47, 0xd1, 0xe1, 0x22, 0x30, 0x02, 0x21,
  0x50, 0xd5, 0xe3, 0x01, 0x3a, 0x0e, 0x00, 0x06, 0x00, 0x79, 0x48, 0x47,
  0x7e, 0xfe, 0xf0, 0xca, 0x17, 0xd8, 0xb7, 0xc8, 0xb8, 0xc8, 0x23, 0xfe,
  0x22, 0xca, 0x01, 0xd8, 0xc3, 0x04, 0xd8, 0x23, 0x23, 0x23, 0xc3, 0x04,
  0xd8, 0xcd, 0x2c, 0xdc, 0xcf, 0xbb, 0x3a, 0x10, 0x02, 0xf5, 0xd5, 0xcd,
  0x7b, 0xda, 0xe3, 0x22, 0x2c, 0x02, 0xd1, 0xf1, 0xd5, 0x1f, 0xcd, 0x71,
  0xda, 0xca, 0x62, 0xd8, 0xe5, 0x2a, 0x3e, 0x02, 0xe5, 0x23, 0x23, 0xf7,
  0xd1, 0x2a, 0x70, 0x02, 0xe7, 0xd1, 0xd2, 0x52, 0xd8, 0x2a, 0x36, 0x02,
  0xe7, 0x6b, 0x62, 0xdc, 0x40, 0xde, 0x1a, 0xf5, 0xaf, 0x12, 0xcd, 0xd6,
  0xdf, 0xf1, 0x77, 0xeb, 0xe1, 0xcd, 0x84, 0xe3, 0xe1, 0xc9, 0xe5, 0xcd,
  0x81, 0xe3, 0xd1, 0xe1, 0xc9, 0xcd, 0xaf, 0xe0, 0x7e, 0x47, 0xfe, 0x8c,
  0xca, 0x76, 0xd8, 0xcf, 0x88, 0x2b, 0x4b, 0x0d, 0x78, 0xca, 0x7b, 0xd5,
  0x23, 0xcd, 0x65, 0xd7, 0x23, 0x7e, 0xfe, 0x2c, 0xc0, 0xc3, 0x77, 0xd8,
  0xcd, 0x7b, 0xda, 0x7e, 0xfe, 0x88, 0xca, 0x94, 0xd8, 0xcf, 0xb0, 0x2b,
  0xef, 0xca, 0xfd, 0xd7, 0x23, 0x7e, 0xfe, 0x20, 0xca, 0x98, 0xd8, 0xfe,
  0x88, 0xca, 0xea, 0xd8, 0xc3, 0x7a, 0xd5, 0x2b, 0xd7, 0xca, 0xf3, 0xd8,
  0xc8, 0xfe, 0xac, 0xca, 0x12, 0xd9, 0xfe, 0xae, 0xca, 0x12, 0xd9, 0xe5,
  0xfe, 0x2c, 0xca, 0xfe, 0xd8, 0xfe, 0x3b, 0xca, 0x32, 0xd9, 0xc1, 0xcd,
  0x7b, 0xda, 0x2b, 0xe5, 0x3a, 0x10, 0x02, 0xb7, 0xc2, 0xe3, 0xd8, 0xcd,
  0xd8, 0xe4, 0xcd, 0x60, 0xde, 0x2a, 0x3e, 0x02, 0x3a, 0x0d, 0x02, 0x86,
  0xcd, 0xa7, 0xde, 0x3e, 0x20, 0xdf, 0xaf, 0xc4, 0xa7, 0xde, 0xe1, 0xc3,
  0xa8, 0xd8, 0x23, 0xc3, 0xc9, 0xd7, 0x36, 0x00, 0x21, 0x00, 0x01, 0x3e,
  0x0d, 0xdf, 0x3a, 0x0c, 0x02, 0xaf, 0x32, 0x0d, 0x02, 0xc9, 0x3a, 0x0d,
  0x02, 0xfe, 0x40, 0xd4, 0xf3, 0xd8, 0xd2, 0x32, 0xd9, 0xd6, 0x10, 0xd2,
  0x09, 0xd9, 0x2f, 0xc3, 0x29, 0xd9, 0xf5, 0xcd, 0xae, 0xe0, 0xcf, 0x29,
  0x2b, 0xf1, 0xfe, 0xae, 0xe5, 0x7b, 0xca, 0x2a, 0xd9, 0x3a, 0x0d, 0x02,
  0x2f, 0x83, 0xd2, 0x32, 0xd9, 0x3c, 0x47, 0x3e, 0x20, 0xdf, 0x05, 0xc2,
  0x2d, 0xd9, 0xe1, 0xd7, 0xc3, 0xac, 0xd8, 0x07, 0x3f, 0x20, 0x52, 0x65,
  0x65, 0x6e, 0x74, 0x65, 0x72, 0x0d, 0x00, 0x3a, 0x2b, 0x02, 0xb7, 0xc2,
  0x39, 0xd1, 0xc1, 0x21, 0x37, 0xd9, 0xcd, 0xa4, 0xde, 0x2a, 0x2c, 0x02,
  0xc9, 0xfe, 0x22, 0x32, 0x58, 0x02, 0x3e, 0x00, 0x32, 0x0e, 0x02, 0xc2,
  0x6c, 0xd9, 0xcd, 0x61, 0xde, 0xcf, 0x3b, 0xe5, 0xcd, 0xa7, 0xde, 0xe1,
  0xe5, 0xcd, 0x13, 0xde, 0xcd, 0x8a, 0xd2, 0x23, 0x7e, 0xb7, 0x2b, 0xc1,
  0xca, 0xe6, 0xd6, 0xc5, 0xc3, 0x84, 0xd9, 0xe5, 0x2a, 0x3c, 0x02, 0xf6,
  0xaf, 0x32, 0x2b, 0x02, 0xe3, 0x01, 0xcf, 0x2c, 0xcd, 0x2c, 0xdc, 0xe3,
  0xd5, 0x7e, 0xfe, 0x2c, 0xca, 0xa4, 0xd9, 0x3a, 0x2b, 0x02, 0xb7, 0xc2,
  0x01, 0xda, 0x3e, 0x3f, 0xdf, 0xcd, 0x8a, 0xd2, 0x3a, 0x10, 0x02, 0xb7,
  0xca, 0xc4, 0xd9, 0xd7, 0x57, 0x47, 0xfe, 0x22, 0xca, 0xb8, 0xd9, 0x16,
  0x3a, 0x06, 0x2c, 0x2b, 0xcd, 0x64, 0xde, 0xeb, 0x21, 0xcd, 0xd9, 0xe3,
  0xd5, 0xc3, 0x38, 0xd8, 0xd7, 0xcd, 0x2e, 0xe4, 0xe3, 0xcd, 0x81, 0xe3,
  0xe1, 0x2b, 0xd7, 0xca, 0xd7, 0xd9, 0xfe, 0x2c, 0xc2, 0x43, 0xd9, 0xe3,
  0x2b, 0xd7, 0xc2, 0x8a, 0xd9, 0xd1, 0x3a, 0x2b, 0x02, 0xb7, 0xeb, 0xc2,
  0xd1, 0xd6, 0xb6, 0x21, 0xf0, 0xd9, 0xd5, 0xc4, 0xa4, 0xde, 0xe1, 0xc9,
  0x07, 0x20, 0x45, 0x78, 0x74, 0x72, 0x61, 0x20, 0x69, 0x67, 0x6e, 0x6f,
  0x72, 0x65, 0x64, 0x0d, 0x00, 0xcd, 0xfb, 0xd7, 0xb7, 0xc2, 0x1a, 0xda,
  0x23, 0xf7, 0x79, 0xb0, 0x1e, 0x06, 0xca, 0x47, 0xd1, 0xc1, 0x5e, 0x23,
  0x56, 0xeb, 0x22, 0x28, 0x02, 0xeb, 0xd7, 0xfe, 0x98, 0xc2, 0x01, 0xda,
  0xc3, 0xa4, 0xd9, 0x11, 0x00, 0x00, 0xc4, 0x2c, 0xdc, 0x22, 0x2c, 0x02,
  0xcd, 0xe9, 0xd0, 0xc2, 0x45, 0xd1, 0xf9, 0xd5, 0x7e, 0x23, 0xf5, 0xd5,
  0xcd, 0x67, 0xe3, 0xe3, 0xe5, 0xcd, 0xe3, 0xe0, 0xe1, 0xcd, 0x81, 0xe3,
  0xe1, 0xcd, 0x78, 0xe3, 0xe5, 0xcd, 0xa4, 0xe3, 0xe1, 0xc1, 0x90, 0xcd,
  0x78, 0xe3, 0xca, 0x5e, 0xda, 0xeb, 0x22, 0x30, 0x02, 0x69, 0x60, 0xc3,
  0x4c, 0xd5, 0xf9, 0x2a, 0x2c, 0x02, 0x7e, 0xfe, 0x2c, 0xc2, 0x50, 0xd5,
  0xd7, 0xcd, 0x26, 0xda, 0xcd, 0x7b, 0xda, 0xf6, 0x37, 0x3a, 0x10, 0x02,
  0x8f, 0xe8, 0x1e, 0x18, 0xc3, 0x47, 0xd1, 0x2b, 0x16, 0x00, 0xd5, 0xcd,
  0x19, 0xd1, 0x01, 0xcd, 0xeb, 0xda, 0x22, 0x2e, 0x02, 0x2a, 0x2e, 0x02,
  0xc1, 0x78, 0xfe, 0x78, 0xd4, 0x6f, 0xda, 0x7e, 0x16, 0x00, 0xd6, 0xba,
  0xda, 0xb0, 0xda, 0xfe, 0x03, 0xd2, 0xb0, 0xda, 0xfe, 0x01, 0x17, 0xaa,
  0xba, 0x57, 0xda, 0x3f, 0xd1, 0x22, 0x26, 0x02, 0xd7, 0xc3, 0x96, 0xda,
  0x7a, 0xb7, 0xc2, 0xb0, 0xdb, 0x7e, 0x22, 0x26, 0x02, 0xd6, 0xb3, 0xd8,
  0xfe, 0x07, 0xd0, 0x5f, 0x3a, 0x10, 0x02, 0x3d, 0xb3, 0x7b, 0xca, 0x88,
  0xdf, 0x07, 0x83, 0x5f, 0x21, 0x46, 0xd0, 0x19, 0x78, 0x56, 0xba, 0xd0,
  0x23, 0xcd, 0x6f, 0xda, 0xc5, 0x01, 0x89, 0xda, 0xc5, 0x43, 0x4a, 0xcd,
  0x5a, 0xe3, 0x58, 0x51, 0xf7, 0x2a, 0x26, 0x02, 0xc3, 0x7e, 0xda, 0xaf,
  0x32, 0x10, 0x02, 0xd7, 0xda, 0x2e, 0xe4, 0xcd, 0x1c, 0xd7, 0xd2, 0x35,
  0xdb, 0xfe, 0xb3, 0xca, 0xeb, 0xda, 0xfe, 0x2e, 0xca, 0x2e, 0xe4, 0xfe,
  0xb4, 0xca, 0x24, 0xdb, 0xfe, 0x22, 0xca, 0x61, 0xde, 0xfe, 0xb1, 0xca,
  0x0b, 0xdc, 0xfe, 0xaf, 0xca, 0xde, 0xdd, 0xd6, 0xbd, 0xd2, 0x46, 0xdb,
  0xcf, 0x28, 0xcd, 0x7b, 0xda, 0xcf, 0x29, 0xc9, 0x16, 0x7d, 0xcd, 0x7e,
  0xda, 0x2a, 0x2e, 0x02, 0xe5, 0xcd, 0x52, 0xe3, 0xcd, 0x6f, 0xda, 0xe1,
  0xc9, 0xcd, 0x2c, 0xdc, 0xe5, 0xeb, 0x22, 0x3e, 0x02, 0x3a, 0x10, 0x02,
  0xb7, 0xcc, 0x67, 0xe3, 0xe1, 0xc9, 0x06, 0x00, 0x07, 0x4f, 0xc5, 0xd7,
  0x79, 0xfe, 0x30, 0xca, 0x70, 0xdb, 0xfe, 0x29, 0xda, 0x77, 0xdb, 0xcf,
  0x28, 0xcd, 0x7b, 0xda, 0xcf, 0x2c, 0xcd, 0x70, 0xda, 0xeb, 0x2a, 0x3e,
  0x02, 0xe3, 0xe5, 0xeb, 0xcd, 0xaf, 0xe0, 0xeb, 0xe3, 0xc3, 0x7f, 0xdb,
  0xc1, 0x01, 0x30, 0xdb, 0xc3, 0x8a, 0xe9, 0xcd, 0x1c, 0xdb, 0xe3, 0x11,
  0x30, 0xdb, 0xd5, 0x01, 0x14, 0xd0, 0x09, 0x4e, 0x23, 0x66, 0x69, 0xe9,
  0xf6, 0xaf, 0xf5, 0xcd, 0x6f, 0xda, 0xcd, 0x2c, 0xd7, 0xf1, 0xeb, 0xc1,
  0xe3, 0xeb, 0xcd, 0x6a, 0xe3, 0xf5, 0xcd, 0x2c, 0xd7, 0xf1, 0xc1, 0x79,
  0x21, 0xac, 0xdd, 0xc2, 0xab, 0xdb, 0xa3, 0x4f, 0x78, 0xa2, 0xe9, 0xb3,
  0x4f, 0x78, 0xb2, 0xe9, 0x21, 0xc2, 0xdb, 0x3a, 0x10, 0x02, 0x1f, 0x7a,
  0x17, 0x5f, 0x16, 0x64, 0x78, 0xba, 0xd0, 0xc3, 0xd8, 0xda, 0xc4, 0xdb,
  0x79, 0xb7, 0x1f, 0xc1, 0xd1, 0xf5, 0xcd, 0x71, 0xda, 0x21, 0x01, 0xdc,
  0xe5, 0xca, 0xa4, 0xe3, 0xaf, 0x32, 0x10, 0x02, 0xd5, 0xcd, 0xd2, 0xdf,
  0xd1, 0xf7, 0xf7, 0xcd, 0xd6, 0xdf, 0xcd, 0x78, 0xe3, 0xe1, 0xe3, 0x55,
  0xe1, 0x7b, 0xb2, 0xc8, 0x7a, 0xb7, 0x2f, 0xc8, 0xaf, 0xbb, 0x3c, 0xd0,
  0x15, 0x1d, 0x0a, 0xbe, 0x23, 0x03, 0xca, 0xe9, 0xdb, 0x3f, 0xc3, 0x38,
  0xe3, 0x3c, 0x8f, 0xc1, 0xa0, 0xc6, 0xff, 0x9f, 0xc3, 0x3d, 0xe3, 0x16,
  0x5a, 0xcd, 0x7e, 0xda, 0xcd, 0x6f, 0xda, 0xcd, 0x2c, 0xd7, 0x7b, 0x2f,
  0x4f, 0x7a, 0x2f, 0xcd, 0xac, 0xdd, 0xc1, 0xc3, 0x89, 0xda, 0x2b, 0xd7,
  0xc8, 0xcf, 0x2c, 0x01, 0x22, 0xdc, 0xc5, 0xf6, 0xaf, 0x32, 0x0f, 0x02,
  0x46, 0xcd, 0x1c, 0xd7, 0xda, 0x3f, 0xd1, 0xaf, 0x4f, 0x32, 0x10, 0x02,
  0xd7, 0xda, 0x46, 0xdc, 0xcd, 0x1c, 0xd7, 0xda, 0x51, 0xdc, 0x4f, 0xd7,
  0xda, 0x47, 0xdc, 0xcd, 0x1c, 0xd7, 0xd2, 0x47, 0xdc, 0xd6, 0x24, 0xc2,
  0x5e, 0xdc, 0x3c, 0x32, 0x10, 0x02, 0x0f, 0x81, 0x4f, 0xd7, 0x3a, 0x2a,
  0x02, 0x86, 0xfe, 0x28, 0xca, 0xb0, 0xdc, 0xaf, 0x32, 0x2a, 0x02, 0xe5,
  0x2a, 0x38, 0x02, 0xeb, 0x2a, 0x36, 0x02, 0xe7, 0xca, 0x8a, 0xdc, 0x79,
  0x96, 0x23, 0xc2, 0x7f, 0xdc, 0x78, 0x96, 0x23, 0xca, 0xad, 0xdc, 0x23,
  0x23, 0x23, 0x23, 0xc3, 0x73, 0xdc, 0xc5, 0x01, 0x06, 0x00, 0x2a, 0x3a,
  0x02, 0xe5, 0x09, 0xc1, 0xe5, 0xcd, 0x0a, 0xd1, 0xe1, 0x22, 0x3a, 0x02,
  0x60, 0x69, 0x22, 0x38, 0x02, 0x2b, 0x36, 0x00, 0xe7, 0xc2, 0xa1, 0xdc,
  0xd1, 0x73, 0x23, 0x72, 0x23, 0xeb, 0xe1, 0xc9, 0xe5, 0x2a, 0x0f, 0x02,
  0xe3, 0x16, 0x00, 0xd5, 0xc5, 0xcd, 0x24, 0xd7, 0xc1, 0xf1, 0xeb, 0xe3,
  0xe5, 0xeb, 0x3c, 0x57, 0x7e, 0xfe, 0x2c, 0xca, 0xb7, 0xdc, 0xcf, 0x29,
  0x22, 0x2e, 0x02, 0xe1, 0x22, 0x0f, 0x02, 0xd5, 0x2a, 0x38, 0x02, 0x3e,
  0x19, 0xeb, 0x2a, 0x3a, 0x02, 0xeb, 0xe7, 0xca, 0x05, 0xdd, 0x7e, 0xb9,
  0x23, 0xc2, 0xea, 0xdc, 0x7e, 0xb8, 0x23, 0x5e, 0x23, 0x56, 0x23, 0xc2,
  0xd8, 0xdc, 0x3a, 0x0f, 0x02, 0xb7, 0x1e, 0x12, 0xc2, 0x47, 0xd1, 0xf1,
  0xbe, 0xca, 0x63, 0xdd, 0x1e, 0x10, 0xc3, 0x47, 0xd1, 0x11, 0x04, 0x00,
  0x71, 0x23, 0x70, 0x23, 0xf1, 0x32, 0x7a, 0x02, 0xc3, 0x77, 0x02, 0x22,
  0x26, 0x02, 0x23, 0x23, 0x41, 0x70, 0x23, 0x3a, 0x0f, 0x02, 0xb7, 0x78,
  0x01, 0x0b, 0x00, 0xca, 0x28, 0xdd, 0xc1, 0x03, 0x71, 0x23, 0x70, 0x23,
  0xf5, 0xe5, 0xcd, 0x13, 0xe4, 0xeb, 0xe1, 0xc1, 0x05, 0xc2, 0x1b, 0xdd,
  0x42, 0x4b, 0xeb, 0x19, 0xda, 0x00, 0xdd, 0xcd, 0x2a, 0xd1, 0x22, 0x3a,
  0x02, 0x2b, 0x36, 0x00, 0xe7, 0xc2, 0x45, 0xdd, 0x03, 0x67, 0x3a, 0x0f,
  0x02, 0xb7, 0x3a, 0x7a, 0x02, 0x6f, 0x29, 0x09, 0xeb, 0x2a, 0x26, 0x02,
  0x73, 0x23, 0x72, 0x23, 0xc2, 0x85, 0xdd, 0x23, 0x01, 0x00, 0x00, 0x16,
  0xe1, 0x5e, 0x23, 0x56, 0x23, 0xe3, 0xf5, 0xe7, 0xd2, 0x00, 0xdd, 0xe5,
  0xcd, 0x13, 0xe4, 0xd1, 0x19, 0xf1, 0x3d, 0x44, 0x4d, 0xc2, 0x68, 0xdd,
  0x29, 0x29, 0xc1, 0x09, 0xeb, 0x2a, 0x2e, 0x02, 0x2b, 0xd7, 0xc9, 0x2a,
  0x3a, 0x02, 0xeb, 0x21, 0x00, 0x00, 0x39, 0x3a, 0x10, 0x02, 0xb7, 0xca,
  0xa7, 0xdd, 0xcd, 0xd2, 0xdf, 0xcd, 0xe3, 0xde, 0x2a, 0x70, 0x02, 0xeb,
  0x2a, 0x24, 0x02, 0x7d, 0x93, 0x4f, 0x7c, 0x9a, 0x41, 0x50, 0x1e, 0x00,
  0x21, 0x10, 0x02, 0x73, 0x06, 0x90, 0xc3, 0x42, 0xe3, 0x3a, 0x0d, 0x02,
  0x47, 0xaf, 0xc3, 0xad, 0xdd, 0xcd, 0x21, 0xde, 0x01, 0xfb, 0xd7, 0xc5,
  0xd5, 0xcd, 0x13, 0xde, 0xcf, 0x28, 0xcd, 0x2c, 0xdc, 0xcd, 0x6f, 0xda,
  0xcf, 0x29, 0xcf, 0xbb, 0x44, 0x4d, 0xe3, 0xc3, 0x0a, 0xde, 0xcd, 0x21,
  0xde, 0xd5, 0xcd, 0x1c, 0xdb, 0xcd, 0x6f, 0xda, 0xe3, 0xf7, 0xd1, 0xf7,
  0xe1, 0xf7, 0xf7, 0x2b, 0x2b, 0x2b, 0x2b, 0xe5, 0xe7, 0xd5, 0x1e, 0x22,
  0xca, 0x47, 0xd1, 0xcd, 0x81, 0xe3, 0xe1, 0xcd, 0x6c, 0xda, 0x2b, 0xd7,
  0xc2, 0x3f, 0xd1, 0xe1, 0xd1, 0xc1, 0x71, 0x23, 0x70, 0x23, 0x73, 0x23,
  0x72, 0xe1, 0xc9, 0xe5, 0x2a, 0x30, 0x02, 0x23, 0x7c, 0xb5, 0xe1, 0xc0,
  0x1e, 0x16, 0xc3, 0x47, 0xd1, 0xcf, 0xaf, 0x3e, 0x80, 0x32, 0x2a, 0x02,
  0xb6, 0x47, 0xcd, 0x31, 0xdc, 0xc3, 0x6f, 0xda, 0xcd, 0x6f, 0xda, 0xcd,
  0xd8, 0xe4, 0xcd, 0x60, 0xde, 0xcd, 0xd2, 0xdf, 0x01, 0x21, 0xe0, 0xc5,
  0x7e, 0x23, 0x23, 0xe5, 0xcd, 0xbb, 0xde, 0xe1, 0xf7, 0xc1, 0xcd, 0x57,
  0xde, 0xe5, 0x6f, 0xcd, 0xc5, 0xdf, 0xd1, 0xc9, 0xcd, 0xbb, 0xde, 0x21,
  0x20, 0x02, 0xe5, 0x77, 0x23, 0xc3, 0x0d, 0xde, 0x2b, 0x06, 0x22, 0x50,
  0xe5, 0x0e, 0xff, 0x23, 0x7e, 0x0c, 0xb7, 0xca, 0x76, 0xde, 0xba, 0xca,
  0x76, 0xde, 0xb8, 0xc2, 0x67, 0xde, 0xfe, 0x22, 0xcc, 0x93, 0xd5, 0xe3,
  0x23, 0xeb, 0x79, 0xcd, 0x57, 0xde, 0xe7, 0xd4, 0x40, 0xde, 0x11, 0x20,
  0x02, 0x2a, 0x12, 0x02, 0x22, 0x3e, 0x02, 0x3e, 0x01, 0x32, 0x10, 0x02,
  0xcd, 0x84, 0xe3, 0xe7, 0x1e, 0x1e, 0xca, 0x47, 0xd1, 0x22, 0x12, 0x02,
  0xe1, 0x7e, 0xc9, 0x23, 0xcd, 0x60, 0xde, 0xcd, 0xd2, 0xdf, 0xcd, 0x78,
  0xe3, 0x1c, 0x1d, 0xc8, 0x0a, 0xdf, 0xfe, 0x0d, 0xcc, 0xf6, 0xd8, 0x03,
  0xc3, 0xae, 0xde, 0xb7, 0x0e, 0xf1, 0xf5, 0x2a, 0x70, 0x02, 0xeb, 0x2a,
  0x24, 0x02, 0x2f, 0x4f, 0x06, 0xff, 0x09, 0x23, 0xe7, 0xda, 0xd7, 0xde,
  0x22, 0x24, 0x02, 0x23, 0xeb, 0xf1, 0xc9, 0xf1, 0x1e, 0x1a, 0xca, 0x47,
  0xd1, 0xbf, 0xf5, 0x01, 0xbd, 0xde, 0xc5, 0x2a, 0x6e, 0x02, 0x22, 0x24,
  0x02, 0x21, 0x00, 0x00, 0xe5, 0x2a, 0x70, 0x02, 0xe5, 0x21, 0x14, 0x02,
  0xeb, 0x2a, 0x12, 0x02, 0xeb, 0xe7, 0x01, 0xf4, 0xde, 0xc2, 0x40, 0xdf,
  0x2a, 0x36, 0x02, 0xeb, 0x2a, 0x38, 0x02, 0xeb, 0xe7, 0xca, 0x17, 0xdf,
  0x7e, 0x23, 0x23, 0xb7, 0xcd, 0x43, 0xdf, 0xc3, 0x03, 0xdf, 0xc1, 0xeb,
  0x2a, 0x3a, 0x02, 0xeb, 0xe7, 0xca, 0x63, 0xdf, 0xcd, 0x78, 0xe3, 0x7b,
  0xe5, 0x09, 0xb7, 0xf2, 0x16, 0xdf, 0x22, 0x26, 0x02, 0xe1, 0x4e, 0x06,
  0x00, 0x09, 0x09, 0x23, 0xeb, 0x2a, 0x26, 0x02, 0xeb, 0xe7, 0xca, 0x17,
  0xdf, 0x01, 0x34, 0xdf, 0xc5, 0xf6, 0x80, 0xf7, 0xf7, 0xd1, 0xc1, 0xf0,
  0x79, 0xb7, 0xc8, 0x44, 0x4d, 0x2a, 0x24, 0x02, 0xe7, 0x60, 0x69, 0xd8,
  0xe1, 0xe3, 0xe7, 0xe3, 0xe5, 0x60, 0x69, 0xd0, 0xc1, 0xf1, 0xf1, 0xe5,
  0xd5, 0xc5, 0xc9, 0xd1, 0xe1, 0x7d, 0xb4, 0xc8, 0x2b, 0x46, 0x2b, 0x4e,
  0xe5, 0x2b, 0x2b, 0x6e, 0x26, 0x00, 0x09, 0x50, 0x59, 0x2b, 0x44, 0x4d,
  0x2a, 0x24, 0x02, 0xcd, 0x0d, 0xd1, 0xe1, 0x71, 0x23, 0x70, 0x69, 0x60,
  0x2b, 0xc3, 0xe6, 0xde, 0xc5, 0xe5, 0x2a, 0x3e, 0x02, 0xe3, 0xcd, 0xeb,
  0xda, 0xe3, 0xcd, 0x70, 0xda, 0x7e, 0xe5, 0x2a, 0x3e, 0x02, 0xe5, 0x86,
  0x1e, 0x1c, 0xda, 0x47, 0xd1, 0xcd, 0x54, 0xde, 0xd1, 0xcd, 0xd6, 0xdf,
  0xe3, 0xcd, 0xd5, 0xdf, 0xe5, 0x2a, 0x22, 0x02, 0xeb, 0xcd, 0xbf, 0xdf,
  0xcd, 0xbf, 0xdf, 0x21, 0x8c, 0xda, 0xe3, 0xe5, 0xc3, 0x86, 0xde, 0xe1,
  0xe3, 0xf7, 0xf7, 0xc1, 0xe1, 0x2c, 0x2d, 0xc8, 0x0a, 0x12, 0x03, 0x13,
  0xc3, 0xc6, 0xdf, 0xcd, 0x70, 0xda, 0x2a, 0x3e, 0x02, 0xeb, 0x2a, 0x12,
  0x02, 0x2b, 0x46, 0x2b, 0x4e, 0x2b, 0x2b, 0xe7, 0xeb, 0xc0, 0x22, 0x12,
  0x02, 0xd5, 0x50, 0x59, 0x1b, 0x4e, 0x2a, 0x24, 0x02, 0xe7, 0xc2, 0xf6,
  0xdf, 0x47, 0x09, 0x22, 0x24, 0x02, 0xe1, 0xc9, 0x01, 0xbc, 0xdd, 0xc5,
  0xcd, 0xcf, 0xdf, 0xaf, 0x57, 0x32, 0x10, 0x02, 0x7e, 0xb7, 0xc9, 0xcd,
  0xfc, 0xdf, 0xca, 0x3f, 0xd7, 0x23, 0x23, 0xf7, 0xe1, 0x7e, 0xc3, 0xbc,
  0xdd, 0x3e, 0x01, 0xcd, 0x54, 0xde, 0xcd, 0xb2, 0xe0, 0x2a, 0x22, 0x02,
  0x73, 0xc1, 0xc3, 0x86, 0xde, 0xcd, 0x98, 0xe0, 0xaf, 0xe3, 0x4f, 0xe5,
  0x7e, 0xb8, 0xda, 0x33, 0xe0, 0x78, 0x11, 0x0e, 0x00, 0xc5, 0xcd, 0xbb,
  0xde, 0xc1, 0xe1, 0xe5, 0x23, 0x23, 0x46, 0x23, 0x66, 0x68, 0x06, 0x00,
  0x09, 0x44, 0x4d, 0xcd, 0x57, 0xde, 0x6f, 0xcd, 0xc5, 0xdf, 0xd1, 0xcd,
  0xd6, 0xdf, 0xc3, 0x86, 0xde, 0xcd, 0x98, 0xe0, 0xd1, 0xd5, 0x1a, 0x90,
  0xc3, 0x29, 0xe0, 0xeb, 0x7e, 0xcd, 0x9b, 0xe0, 0xc5, 0x1e, 0xff, 0xfe,
  0x29, 0xca, 0x71, 0xe0, 0xcf, 0x2c, 0xcd, 0xaf, 0xe0, 0xcf, 0x29, 0xf1,
  0xe3, 0x01, 0x2b, 0xe0, 0xc5, 0x3d, 0xbe, 0x06, 0x00, 0xd0, 0x4f, 0x7e,
  0x91, 0xbb, 0x47, 0xd8, 0x43, 0xc9, 0xcd, 0xb2, 0xe0, 0x32, 0x7f, 0x02,
  0xcd, 0x7e, 0x02, 0xc3, 0xbc, 0xdd, 0xcd, 0xa5, 0xe0, 0xc3, 0x81, 0x02,
  0xeb, 0xcf, 0x29, 0xc1, 0xd1, 0xc5, 0x43, 0x04, 0x05, 0xca, 0x3f, 0xd7,
  0xc9, 0xcd, 0xaf, 0xe0, 0x32, 0x82, 0x02, 0xcf, 0x2c, 0x06, 0xd7, 0xcd,
  0x6c, 0xda, 0xcd, 0x28, 0xd7, 0x7a, 0xb7, 0xc2, 0x3f, 0xd7, 0x2b, 0xd7,
  0x7b, 0xc9, 0xcd, 0xfc, 0xdf, 0xca, 0x58, 0xe1, 0x5f, 0x23, 0x23, 0xf7,
  0x60, 0x69, 0x19, 0x46, 0x72, 0xe3, 0xc5, 0x7e, 0xcd, 0x2e, 0xe4, 0xc1,
  0xe1, 0x70, 0xc9, 0xd5, 0xcf, 0x2c, 0xcd, 0xaf, 0xe0, 0xd1, 0x12, 0xc9,
  0x21, 0xa1, 0xe5, 0xcd, 0x78, 0xe3, 0xc3, 0xf2, 0xe0, 0xcd, 0x78, 0xe3,
  0x21, 0xc1, 0xd1, 0xcd, 0x52, 0xe3, 0x78, 0xb7, 0xc8, 0x3a, 0x41, 0x02,
  0xb7, 0xca, 0x6a, 0xe3, 0x90, 0xd2, 0x0c, 0xe1, 0x2f, 0x3c, 0xeb, 0xcd,
  0x5a, 0xe3, 0xeb, 0xcd, 0x6a, 0xe3, 0xc1, 0xd1, 0xfe, 0x19, 0xd0, 0xf5,
  0xcd, 0x8f, 0xe3, 0x67, 0xf1, 0xcd, 0xb9, 0xe1, 0xb4, 0x21, 0x3e, 0x02,
  0xf2, 0x32, 0xe1, 0xcd, 0x99, 0xe1, 0xd2, 0x78, 0xe1, 0x23, 0x34, 0xca,
  0x94, 0xe1, 0x2e, 0x01, 0xcd, 0xcf, 0xe1, 0xc3, 0x78, 0xe1, 0xaf, 0x90,
  0x47, 0x7e, 0x9b, 0x5f, 0x23, 0x7e, 0x9a, 0x57, 0x23, 0x7e, 0x99, 0x4f,
  0xdc, 0xa5, 0xe1, 0x68, 0x63, 0xaf, 0x47, 0x79, 0xb7, 0xc2, 0x65, 0xe1,
  0x4a, 0x54, 0x65, 0x6f, 0x78, 0xd6, 0x08, 0xfe, 0xe0, 0xc2, 0x46, 0xe1,
  0xaf, 0x32, 0x41, 0x02, 0xc9, 0x05, 0x29, 0x7a, 0x17, 0x57, 0x79, 0x8f,
  0x4f, 0xf2, 0x5d, 0xe1, 0x78, 0x5c, 0x45, 0xb7, 0xca, 0x78, 0xe1, 0x21,
  0x41, 0x02, 0x86, 0x77, 0xd2, 0x58, 0xe1, 0xc8, 0x78, 0x21, 0x41, 0x02,
  0xb7, 0xfc, 0x8a, 0xe1, 0x46, 0x23, 0x7e, 0xe6, 0x80, 0xa9, 0x4f, 0xc3,
  0x6a, 0xe3, 0x1c, 0xc0, 0x14, 0xc0, 0x0c, 0xc0, 0x0e, 0x80, 0x34, 0xc0,
  0x1e, 0x0a, 0xc3, 0x47, 0xd1, 0x7e, 0x83, 0x5f, 0x23, 0x7e, 0x8a, 0x57,
  0x23, 0x7e, 0x89, 0x4f, 0xc9, 0x21, 0x42, 0x02, 0x7e, 0x2f, 0x77, 0xaf,
  0x6f, 0x90, 0x47, 0x7d, 0x9b, 0x5f, 0x7d, 0x9a, 0x57, 0x7d, 0x99, 0x4f,
  0xc9, 0x06, 0x00, 0xd6, 0x08, 0xda, 0xc8, 0xe1, 0x43, 0x5a, 0x51, 0x0e,
  0x00, 0xc3, 0xbb, 0xe1, 0xc6, 0x09, 0x6f, 0xaf, 0x2d, 0xc8, 0x79, 0x1f,
  0x4f, 0x7a, 0x1f, 0x57, 0x7b, 0x1f, 0x5f, 0x78, 0x1f, 0x47, 0xc3, 0xcb,
  0xe1, 0x00, 0x00, 0x00, 0x81, 0x03, 0xaa, 0x56, 0x19, 0x80, 0xf1, 0x22,
  0x76, 0x80, 0x45, 0xaa, 0x38, 0x82, 0xef, 0xea, 0x3f, 0xd7, 0x21, 0x41,
  0x02, 0x7e, 0x01, 0x35, 0x80, 0x11, 0xf3, 0x04, 0x90, 0xf5, 0x70, 0xd5,
  0xc5, 0xcd, 0xf2, 0xe0, 0xc1, 0xd1, 0x04, 0xcd, 0x8c, 0xe2, 0x21, 0xdd,
  0xe1, 0xcd, 0xe9, 0xe0, 0x21, 0xe1, 0xe1, 0xcd, 0x62, 0xe6, 0x01, 0x80,
  0x80, 0x11, 0x00, 0x00, 0xcd, 0xf2, 0xe0, 0xf1, 0xcd, 0xae, 0xe4, 0x01,
  0x31, 0x80, 0x11, 0x18, 0x72, 0x21, 0xc1, 0xd1, 0xef, 0xc8, 0x2e, 0x00,
  0xcd, 0xf2, 0xe2, 0x79, 0x32, 0x85, 0x02, 0xeb, 0x22, 0x50, 0x02, 0x01,
  0x00, 0x00, 0x50, 0x58, 0x21, 0x43, 0xe1, 0xe5, 0x21, 0x4c, 0xe2, 0xe5,
  0xe5, 0x21, 0x3e, 0x02, 0x7e, 0x23, 0xb7, 0xca, 0x79, 0xe2, 0xe5, 0xeb,
  0x1e, 0x08, 0x1f, 0x57, 0x79, 0xd2, 0x66, 0xe2, 0xd5, 0xeb, 0x2a, 0x50,
  0x02, 0x19, 0xd1, 0xc3, 0x84, 0x02, 0x1f, 0x4f, 0x7c, 0x1f, 0x67, 0x7d,
  0x1f, 0x6f, 0x78, 0x1f, 0x47, 0x1d, 0x7a, 0xc2, 0x56, 0xe2, 0xeb, 0xe1,
  0xc9, 0x43, 0x5a, 0x51, 0x4f, 0xc9, 0xcd, 0x5a, 0xe3, 0x01, 0x20, 0x84,
  0x11, 0x00, 0x00, 0xcd, 0x6a, 0xe3, 0xc1, 0xd1, 0xef, 0xca, 0x42, 0xd1,
  0x2e, 0xff, 0xcd, 0xf2, 0xe2, 0x34, 0x34, 0x2b, 0x7e, 0x32, 0x92, 0x02,
  0x2b, 0x7e, 0x32, 0x8e, 0x02, 0x2b, 0x7e, 0x32, 0x8a, 0x02, 0x41, 0xeb,
  0xaf, 0x4f, 0x57, 0x5f, 0x32, 0x95, 0x02, 0xe5, 0xc5, 0x7d, 0xc3, 0x89,
  0x02, 0xde, 0x00, 0x3f, 0xd2, 0xc2, 0xe2, 0x32, 0x95, 0x02, 0xf1, 0xf1,
  0x37, 0xd2, 0xc1, 0xe1, 0x79, 0x3c, 0x3d, 0x1f, 0xfa, 0x79, 0xe1, 0x17,
  0x7b, 0x17, 0x5f, 0x7a, 0x17, 0x57, 0x79, 0x17, 0x4f, 0x29, 0x78, 0x17,
  0x47, 0x3a, 0x95, 0x02, 0x17, 0x32, 0x95, 0x02, 0x79, 0xb2, 0xb3, 0xc2,
  0xaf, 0xe2, 0xe5, 0x21, 0x41, 0x02, 0x35, 0xe1, 0xc2, 0xaf, 0xe2, 0xc3,
  0x94, 0xe1, 0x78, 0xb7, 0xca, 0x14, 0xe3, 0x7d, 0x21, 0x41, 0x02, 0xae,
  0x80, 0x47, 0x1f, 0xa8, 0x78, 0xf2, 0x13, 0xe3, 0xc6, 0x80, 0x77, 0xca,
  0x77, 0xe2, 0xcd, 0x8f, 0xe3, 0x77, 0x2b, 0xc9, 0xef, 0x2f, 0xe1, 0xb7,
  0xe1, 0xf2, 0x58, 0xe1, 0xc3, 0x94, 0xe1, 0xcd, 0x75, 0xe3, 0x78, 0xb7,
  0xc8, 0xc6, 0x02, 0xda, 0x94, 0xe1, 0x47, 0xcd, 0xf2, 0xe0, 0x21, 0x41,
  0x02, 0x34, 0xc0, 0xc3, 0x94, 0xe1, 0x3a, 0x40, 0x02, 0xfe, 0x2f, 0x17,
  0x9f, 0xc0, 0x3c, 0xc9, 0xef, 0x06, 0x88, 0x11, 0x00, 0x00, 0x21, 0x41,
  0x02, 0x4f, 0x70, 0x06, 0x00, 0x23, 0x36, 0x80, 0x17, 0xc3, 0x40, 0xe1,
  0xef, 0xf0, 0x21, 0x40, 0x02, 0x7e, 0xee, 0x80, 0x77, 0xc9, 0xeb, 0x2a,
  0x3e, 0x02, 0xe3, 0xe5, 0x2a, 0x40, 0x02, 0xe3, 0xe5, 0xeb, 0xc9, 0xcd,
  0x78, 0xe3, 0xeb, 0x22, 0x3e, 0x02, 0x60, 0x69, 0x22, 0x40, 0x02, 0xeb,
  0xc9, 0x21, 0x3e, 0x02, 0x5e, 0x23, 0x56, 0x23, 0x4e, 0x23, 0x46, 0x23,
  0xc9, 0x11, 0x3e, 0x02, 0x06, 0x04, 0x1a, 0x77, 0x13, 0x23, 0x05, 0xc2,
  0x86, 0xe3, 0xc9, 0x21, 0x40, 0x02, 0x7e, 0x07, 0x37, 0x1f, 0x77, 0x3f,
  0x1f, 0x23, 0x23, 0x77, 0x79, 0x07, 0x37, 0x1f, 0x4f, 0x1f, 0xae, 0xc9,
  0x78, 0xb7, 0xca, 0x28, 0x00, 0x21, 0x36, 0xe3, 0xe5, 0xef, 0x79, 0xc8,
  0x21, 0x40, 0x02, 0xae, 0x79, 0xf8, 0xcd, 0xbc, 0xe3, 0x1f, 0xa9, 0xc9,
  0x23, 0x78, 0xbe, 0xc0, 0x2b, 0x79, 0xbe, 0xc0, 0x2b, 0x7a, 0xbe, 0xc0,
  0x2b, 0x7b, 0x96, 0xc0, 0xe1, 0xe1, 0xc9, 0x47, 0x4f, 0x57, 0x5f, 0xb7,
  0xc8, 0xe5, 0xcd, 0x75, 0xe3, 0xcd, 0x8f, 0xe3, 0xae, 0x67, 0xfc, 0xf3,
  0xe3, 0x3e, 0x98, 0x90, 0xcd, 0xb9, 0xe1, 0x7c, 0x17, 0xdc, 0x8a, 0xe1,
  0x06, 0x00, 0xdc, 0xa5, 0xe1, 0xe1, 0xc9, 0x1b, 0x7a, 0xa3, 0x3c, 0xc0,
  0x0d, 0xc9, 0x21, 0x41, 0x02, 0x7e, 0xfe, 0x98, 0x3a, 0x3e, 0x02, 0xd0,
  0x7e, 0xcd, 0xcf, 0xe3, 0x36, 0x98, 0x7b, 0xf5, 0x79, 0x17, 0xcd, 0x40,
  0xe1, 0xf1, 0xc9, 0x21, 0x00, 0x00, 0x78, 0xb1, 0xc8, 0x3e, 0x10, 0x29,
  0xda, 0x00, 0xdd, 0xeb, 0x29, 0xeb, 0xd2, 0x29, 0xe4, 0x09, 0xda, 0x00,
  0xdd, 0x3d, 0xc2, 0x1b, 0xe4, 0xc9, 0xfe, 0x2d, 0xf5, 0xca, 0x3a, 0xe4,
  0xfe, 0x2b, 0xca, 0x3a, 0xe4, 0x2b, 0xcd, 0x58, 0xe1, 0x47, 0x57, 0x5f,
  0x2f, 0x4f, 0xd7, 0xda, 0x97, 0xe4, 0xfe, 0x2e, 0xca, 0x72, 0xe4, 0xfe,
  0x45, 0xc2, 0x76, 0xe4, 0xd7, 0xe5, 0x21, 0x66, 0xe4, 0xe3, 0x15, 0xfe,
  0xb4, 0xc8, 0xfe, 0x2d, 0xc8, 0x14, 0xfe, 0x2b, 0xc8, 0xfe, 0xb3, 0xc8,
  0xf1, 0x2b, 0xd7, 0xda, 0xb9, 0xe4, 0x14, 0xc2, 0x76, 0xe4, 0xaf, 0x93,
  0x5f, 0x0c, 0x0c, 0xca, 0x42, 0xe4, 0xe5, 0x7b, 0x90, 0xf4, 0x8f, 0xe4,
  0xf2, 0x85, 0xe4, 0xf5, 0xcd, 0x7e, 0xe2, 0xf1, 0x3c, 0xc2, 0x79, 0xe4,
  0xd1, 0xf1, 0xcc, 0x52, 0xe3, 0xeb, 0xc9, 0xc8, 0xf5, 0xcd, 0x1b, 0xe3,
  0xf1, 0x3d, 0xc9, 0xd5, 0x57, 0x78, 0x89, 0x47, 0xc5, 0xe5, 0xd5, 0xcd,
  0x1b, 0xe3, 0xf1, 0xd6, 0x30, 0xcd, 0xae, 0xe4, 0xe1, 0xc1, 0xd1, 0xc3,
  0x42, 0xe4, 0xcd, 0x5a, 0xe3, 0xcd, 0x3d, 0xe3, 0xc1, 0xd1, 0xc3, 0xf2,
  0xe0, 0x7b, 0x07, 0x07, 0x83, 0x07, 0x86, 0xd6, 0x30, 0x5f, 0xc3, 0x66,
  0xe4, 0xe5, 0x21, 0xd7, 0xd0, 0xcd, 0xa4, 0xde, 0xe1, 0xeb, 0xaf, 0x06,
  0x98, 0xcd, 0x42, 0xe3, 0x21, 0xa3, 0xde, 0xe5, 0x21, 0x43, 0x02, 0xe5,
  0xef, 0x36, 0x20, 0xf2, 0xe4, 0xe4, 0x36, 0x2d, 0x23, 0x36, 0x30, 0xca,
  0x8d, 0xe5, 0xe5, 0xfc, 0x52, 0xe3, 0xaf, 0xf5, 0xcd, 0x93, 0xe5, 0x01,
  0x43, 0x91, 0x11, 0xf8, 0x4f, 0xcd, 0xa4, 0xe3, 0xe2, 0x10, 0xe5, 0xf1,
  0xcd, 0x90, 0xe4, 0xf5, 0xc3, 0xf3, 0xe4, 0xcd, 0x7e, 0xe2, 0xf1, 0x3c,
  0xf5, 0xcd, 0x93, 0xe5, 0xcd, 0xe0, 0xe0, 0x3c, 0xcd, 0xcf, 0xe3, 0xcd,
  0x6a, 0xe3, 0x01, 0x06, 0x02, 0xf1, 0x81, 0xfa, 0x2b, 0xe5, 0xfe, 0x07,
  0xd2, 0x2b, 0xe5, 0x3c, 0x47, 0x3e, 0x01, 0x3d, 0xe1, 0xf5, 0x11, 0xa5,
  0xe5, 0x05, 0x36, 0x2e, 0xcc, 0x7f, 0xe3, 0xc5, 0xe5, 0xd5, 0xcd, 0x75,
  0xe3, 0xe1, 0x06, 0x2f, 0x04, 0x7b, 0x96, 0x5f, 0x23, 0x7a, 0x9e, 0x57,
  0x23, 0x79, 0x9e, 0x4f, 0x2b, 0x2b, 0xd2, 0x40, 0xe5, 0xcd, 0x99, 0xe1,
  0x23, 0xcd, 0x6a, 0xe3, 0xeb, 0xe1, 0x70, 0x23, 0xc1, 0x0d, 0xc2, 0x31,
  0xe5, 0x05, 0xca, 0x71, 0xe5, 0x2b, 0x7e, 0xfe, 0x30, 0xca, 0x65, 0xe5,
  0xfe, 0x2e, 0xc4, 0x7f, 0xe3, 0xf1, 0xca, 0x90, 0xe5, 0x36, 0x45, 0x23,
  0x36, 0x2b, 0xf2, 0x81, 0xe5, 0x36, 0x2d, 0x2f, 0x3c, 0x06, 0x2f, 0x04,
  0xd6, 0x0a, 0xd2, 0x83, 0xe5, 0xc6, 0x3a, 0x23, 0x70, 0x23, 0x77, 0x23,
  0x71, 0xe1, 0xc9, 0x01, 0x74, 0x94, 0x11, 0xf7, 0x23, 0xcd, 0xa4, 0xe3,
  0xe1, 0xe2, 0x07, 0xe5, 0xe9, 0x00, 0x00, 0x00, 0x80, 0xa0, 0x86, 0x01,
  0x10, 0x27, 0x00, 0xe8, 0x03, 0x00, 0x64, 0x00, 0x00, 0x0a, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x21, 0x52, 0xe3, 0xe3, 0xe9, 0xcd, 0x5a, 0xe3, 0x21,
  0xa1, 0xe5, 0xcd, 0x67, 0xe3, 0xc1, 0xd1, 0xef, 0xca, 0x01, 0xe6, 0x78,
  0xb7, 0xca, 0x59, 0xe1, 0xd5, 0xc5, 0x79, 0xf6, 0x7f, 0xcd, 0x75, 0xe3,
  0xf2, 0xe9, 0xe5, 0xd5, 0xc5, 0xcd, 0xfa, 0xe3, 0xc1, 0xd1, 0xf5, 0xcd,
  0xa4, 0xe3, 0xe1, 0x7c, 0x1f, 0xe1, 0x22, 0x40, 0x02, 0xe1, 0x22, 0x3e,
  0x02, 0xdc, 0xb7, 0xe5, 0xcc, 0x52, 0xe3, 0xd5, 0xc5, 0xcd, 0xee, 0xe1,
  0xc1, 0xd1, 0xcd, 0x2c, 0xe2, 0xcd, 0x5a, 0xe3, 0x01, 0x38, 0x81, 0x11,
  0x3b, 0xaa, 0xcd, 0x2c, 0xe2, 0x3a, 0x41, 0x02, 0xfe, 0x88, 0xd2, 0x10,
  0xe3, 0xcd, 0xfa, 0xe3, 0xc6, 0x80, 0xc6, 0x02, 0xda, 0x10, 0xe3, 0xf5,
  0x21, 0xdd, 0xe1, 0xcd, 0xe3, 0xe0, 0xcd, 0x23, 0xe2, 0xf1, 0xc1, 0xd1,
  0xf5, 0xcd, 0xef, 0xe0, 0xcd, 0x52, 0xe3, 0x21, 0x41, 0xe6, 0xcd, 0x71,
  0xe6, 0x11, 0x00, 0x00, 0xc1, 0x4a, 0xc3, 0x2c, 0xe2, 0x08, 0x40, 0x2e,
  0x94, 0x74, 0x70, 0x4f, 0x2e, 0x77, 0x6e, 0x02, 0x88, 0x7a, 0xe6, 0xa0,
  0x2a, 0x7c, 0x50, 0xaa, 0xaa, 0x7e, 0xff, 0xff, 0x7f, 0x7f, 0x00, 0x00,
  0x80, 0x81, 0x00, 0x00, 0x00, 0x81, 0xcd, 0x5a, 0xe3, 0x11, 0x2a, 0xe2,
  0xd5, 0xe5, 0xcd, 0x75, 0xe3, 0xcd, 0x2c, 0xe2, 0xe1, 0xcd, 0x5a, 0xe3,
  0x7e, 0x23, 0xcd, 0x67, 0xe3, 0x06, 0xf1, 0xc1, 0xd1, 0x3d, 0xc8, 0xd5,
  0xc5, 0xf5, 0xe5, 0xcd, 0x2c, 0xe2, 0xe1, 0xcd, 0x78, 0xe3, 0xe5, 0xcd,
  0xf2, 0xe0, 0xe1, 0xc3, 0x7a, 0xe6, 0xef, 0xfa, 0xaf, 0xe6, 0x21, 0x52,
  0x02, 0xcd, 0x67, 0xe3, 0xc8, 0x01, 0x35, 0x98, 0x11, 0x7a, 0x44, 0xcd,
  0x2c, 0xe2, 0x01, 0x28, 0x68, 0x11, 0x46, 0xb1, 0xcd, 0xf2, 0xe0, 0xcd,
  0x75, 0xe3, 0x7b, 0x59, 0x4f, 0x36, 0x80, 0x2b, 0x46, 0x36, 0x80, 0xcd,
  0x43, 0xe1, 0x21, 0x52, 0x02, 0xc3, 0x81, 0xe3, 0x21, 0x0a, 0xe7, 0xcd,
  0xe3, 0xe0, 0xcd, 0x5a, 0xe3, 0x01, 0x49, 0x83, 0x11, 0xdb, 0x0f, 0xcd,
  0x6a, 0xe3, 0xc1, 0xd1, 0xcd, 0x8c, 0xe2, 0xcd, 0x5a, 0xe3, 0xcd, 0xfa,
  0xe3, 0xc1, 0xd1, 0xcd, 0xef, 0xe0, 0x21, 0x0e, 0xe7, 0xcd, 0xe9, 0xe0,
  0xef, 0x37, 0xf2, 0xf6, 0xe6, 0xcd, 0xe0, 0xe0, 0xef, 0xb7, 0xf5, 0xf4,
  0x52, 0xe3, 0x21, 0x0e, 0xe7, 0xcd, 0xe3, 0xe0, 0xf1, 0xd4, 0x52, 0xe3,
  0x21, 0x12, 0xe7, 0xc3, 0x62, 0xe6, 0xdb, 0x0f, 0x49, 0x81, 0x00, 0x00,
  0x00, 0x7f, 0x05, 0xba, 0xd7, 0x1e, 0x86, 0x64, 0x26, 0x99, 0x87, 0x58,
  0x34, 0x23, 0x87, 0xe0, 0x5d, 0xa5, 0x86, 0xda, 0x0f, 0x49, 0x83, 0xcd,
  0x5a, 0xe3, 0xcd, 0xca, 0xe6, 0xc1, 0xe1, 0xcd, 0x5a, 0xe3, 0xeb, 0xcd,
  0x6a, 0xe3, 0xcd, 0xc4, 0xe6, 0xc3, 0x8a, 0xe2, 0xef, 0xfc, 0xb7, 0xe5,
  0xfc, 0x52, 0xe3, 0x3a, 0x41, 0x02, 0xfe, 0x81, 0xda, 0x57, 0xe7, 0x01,
  0x00, 0x81, 0x51, 0x59, 0xcd, 0x8c, 0xe2, 0x21, 0xe9, 0xe0, 0xe5, 0x21,
  0x61, 0xe7, 0xcd, 0x62, 0xe6, 0x21, 0x0a, 0xe7, 0xc9, 0x09, 0x4a, 0xd7,
  0x3b, 0x78, 0x02, 0x6e, 0x84, 0x7b, 0xfe, 0xc1, 0x2f, 0x7c, 0x74, 0x31,
  0x9a, 0x7d, 0x84, 0x3d, 0x5a, 0x7d, 0xc8, 0x7f, 0x91, 0x7e, 0xe4, 0xbb,
  0x4c, 0x7e, 0x6c, 0xaa, 0xaa, 0x7f, 0x00, 0x00, 0x00, 0x81, 0x00, 0x00,
  0xef, 0xcd, 0x2c, 0xd7, 0x1a, 0xc3, 0xbc, 0xdd, 0xcd, 0x6c, 0xda, 0xef,
  0xcd, 0x2c, 0xd7, 0xc3, 0xd7, 0xe0, 0xef, 0xcd, 0x2c, 0xd7, 0xeb, 0xcd,
  0xa5, 0xe7, 0xc3, 0xbc, 0xdd, 0xe9, 0xaf, 0x32, 0x00, 0x03, 0x21, 0xba,
  0xe7, 0x7e, 0xb7, 0xca, 0x7f, 0xd1, 0x4e, 0x23, 0xcd, 0xf0, 0xc7, 0xc3,
  0xad, 0xe7, 0x07, 0x2a, 0x2a, 0x2a, 0x20, 0x54, 0x2d, 0x42, 0x41, 0x53,
  0x49, 0x43, 0x20, 0x2a, 0x2a, 0x2a, 0x0d, 0x00, 0xcd, 0xaf, 0xe0, 0x32,
  0x57, 0x02, 0xcf, 0x2c, 0xcd, 0xaf, 0xe0, 0x32, 0x56, 0x02, 0xfe, 0x19,
  0xd2, 0x3f, 0xd7, 0x3a, 0x57, 0x02, 0xfe, 0x40, 0xd2, 0x3f, 0xd7, 0xe5,
  0xcd, 0xbe, 0xf7, 0x3a, 0x56, 0x02, 0xcd, 0xdc, 0xf7, 0xe1, 0xc9, 0xe5,
  0xcd, 0xa0, 0xf9, 0x3a, 0xfa, 0x01, 0xb7, 0xc4, 0x00, 0xe8, 0xe1, 0xc9,
  0xe5, 0xd5, 0xc5, 0xf5, 0x01, 0x00, 0x00, 0x21, 0x00, 0x00, 0x39, 0x31,
  0x00, 0xc0, 0x16, 0x30, 0x1e, 0x20, 0xc5, 0xc5, 0xc5, 0xc5, 0x1d, 0xc2,
  0x12, 0xe8, 0x15, 0xc2, 0x10, 0xe8, 0xf9, 0xf1, 0xc1, 0xd1, 0xe1, 0xc9,
  0xeb, 0xcf, 0x2c, 0xcd, 0x6c, 0xda, 0xcd, 0x28, 0xd7, 0xeb, 0xc9, 0x3e,
  0x00, 0xc3, 0x36, 0xe8, 0x3e, 0x01, 0x32, 0xfb, 0x01, 0xcd, 0x59, 0xe9,
  0xe5, 0x2a, 0xfc, 0x01, 0x22, 0xe0, 0x8f, 0x2a, 0xfe, 0x01, 0x22, 0xe2,
  0x8f, 0xe1, 0xcd, 0x78, 0xe9, 0xca, 0x5e, 0xe8, 0x22, 0xe4, 0x8f, 0xeb,
  0xe5, 0xd5, 0xc5, 0xcd, 0x06, 0xc8, 0xc1, 0xd1, 0xe1, 0xc9, 0x2a, 0x00,
  0x02, 0x3a, 0xfb, 0x01, 0xb7, 0xca, 0x50, 0xe8, 0x2a, 0x02, 0x02, 0xc3,
  0x50, 0xe8, 0xcd, 0x59, 0xe9, 0xe5, 0x2a, 0xfc, 0x01, 0x22, 0xe8, 0x8f,
  0x2a, 0xfe, 0x01, 0x22, 0xea, 0x8f, 0xe1, 0x7e, 0xcd, 0x98, 0xd5, 0xcf,
  0xb4, 0xcd, 0x59, 0xe9, 0xe5, 0x2a, 0xfc, 0x01, 0x22, 0xec, 0x8f, 0x2a,
  0xfe, 0x01, 0x22, 0xee, 0x8f, 0xe1, 0xcd, 0x78, 0xe9, 0xc2, 0x9f, 0xe8,
  0x2a, 0x00, 0x02, 0x22, 0xe4, 0x8f, 0xeb, 0xe5, 0xd5, 0xc5, 0xcd, 0x09,
  0xc8, 0xc1, 0xd1, 0xe1, 0xc9, 0xcd, 0x59, 0xe9, 0xe5, 0x2a, 0xfc, 0x01,
  0x22, 0xe0, 0x8f, 0x2a, 0xfe, 0x01, 0x22, 0xe2, 0x8f, 0xe1, 0xcd, 0x78,
  0xe9, 0xc2, 0xc7, 0xe8, 0x2a, 0x00, 0x02, 0x22, 0xe4, 0x8f, 0xeb, 0xe5,
  0xd5, 0xc5, 0xcd, 0x00, 0xc8, 0xc1, 0xd1, 0xe1, 0xc9, 0xcd, 0x59, 0xe9,
  0xe5, 0x2a, 0xfc, 0x01, 0x22, 0xe0, 0x8f, 0x2a, 0xfe, 0x01, 0x22, 0xe2,
  0x8f, 0xe1, 0xeb, 0xcd, 0x24, 0xe8, 0x22, 0xe6, 0x8f, 0xeb, 0xcd, 0x78,
  0xe9, 0xc2, 0xf7, 0xe8, 0x2a, 0x00, 0x02, 0x22, 0xe4, 0x8f, 0xeb, 0xcd,
  0x03, 0xc8, 0xc9, 0x7e, 0xcd, 0x98, 0xd5, 0xcf, 0x28, 0xcd, 0x6c, 0xda,
  0xef, 0xcd, 0x2c, 0xd7, 0xeb, 0x22, 0x04, 0x02, 0xcd, 0x24, 0xe8, 0x22,
  0x06, 0x02, 0xcd, 0x24, 0xe8, 0x22, 0x08, 0x02, 0xcd, 0x24, 0xe8, 0x22,
  0x0a, 0x02, 0xeb, 0x7e, 0xcd, 0x98, 0xd5, 0xcf, 0x29, 0xcd, 0x0c, 0xc8,
  0xcd, 0x0f, 0xc8, 0xcd, 0x12, 0xc8, 0xcd, 0x15, 0xc8, 0xc9, 0xcd, 0x6c,
  0xda, 0xef, 0xcd, 0x2c, 0xd7, 0xeb, 0x26, 0x00, 0x7d, 0xe6, 0x03, 0x6f,
  0x22, 0x00, 0x02, 0xeb, 0xcd, 0x78, 0xe9, 0xca, 0x57, 0xe9, 0x26, 0x00,
  0x7d, 0xe6, 0x03, 0x6f, 0x22, 0x02, 0x02, 0xeb, 0xc9, 0x7e, 0xcd, 0x98,
  0xd5, 0xcf, 0x28, 0xcd, 0x6c, 0xda, 0xef, 0xcd, 0x2c, 0xd7, 0xeb, 0x22,
  0xfc, 0x01, 0xcd, 0x24, 0xe8, 0x22, 0xfe, 0x01, 0xeb, 0x7e, 0xcd, 0x98,
  0xd5, 0xcf, 0x29, 0xc9, 0x7e, 0xcd, 0x98, 0xd5, 0x7e, 0xeb, 0xfe, 0x3a,
  0xc8, 0xfe, 0x00, 0xc8, 0xcd, 0x24, 0xe8, 0xf6, 0x01, 0xc9, 0xc5, 0xcd,
  0x59, 0xe9, 0xc1, 0xe5, 0xc5, 0xe5, 0xd5, 0xc5, 0x2a, 0xfc, 0x01, 0x11,
  0x80, 0x01, 0x7d, 0x93, 0x7c, 0x9a, 0xd2, 0xb2, 0xe9, 0x3a, 0xfe, 0x01,
  0x2f, 0x5f, 0xcd, 0x3f, 0xca, 0xcd, 0x14, 0xca, 0xc1, 0xd1, 0xe1, 0xc3,
  0xbc, 0xdd, 0xc1, 0xd1, 0xe1, 0x1e, 0x08, 0xc3, 0x47, 0xd1, 0xd5, 0xc5,
  0xcd, 0x02, 0xea, 0xe5, 0x21, 0x00, 0xc9, 0x22, 0x2f, 0xc8, 0xcd, 0x27,
  0xed, 0xcd, 0x46, 0xeb, 0xe1, 0xc1, 0xd1, 0xc9, 0xcd, 0x02, 0xea, 0xcd,
  0x4b, 0xd2, 0x21, 0x00, 0xc9, 0x22, 0x2f, 0xc8, 0x21, 0x01, 0x03, 0x22,
  0x33, 0xc8, 0x3e, 0xd3, 0x32, 0x31, 0xc8, 0xcd, 0x7b, 0xeb, 0x2a, 0x3b,
  0xc8, 0x22, 0x36, 0x02, 0x21, 0x01, 0x03, 0x22, 0x72, 0x02, 0xcd, 0x46,
  0xeb, 0x21, 0xdc, 0xd0, 0xcd, 0xa4, 0xde, 0xc3, 0xf9, 0xd1, 0xc5, 0xd5,
  0x7e, 0xcd, 0x98, 0xd5, 0xcd, 0x1d, 0xd7, 0x11, 0x00, 0xc9, 0xda, 0x2f,
  0xea, 0x0e, 0x06, 0x7e, 0xb7, 0xca, 0x2f, 0xea, 0xfe, 0x3a, 0xca, 0x2f,
  0xea, 0xfe, 0x20, 0xc2, 0x26, 0xea, 0x0c, 0xc3, 0x28, 0xea, 0x12, 0x13,
  0x23, 0x0d, 0xc2, 0x13, 0xea, 0x2b, 0xd7, 0x3e, 0x0d, 0x12, 0xd1, 0xc1,
  0xc9, 0xc5, 0xd5, 0xcd, 0x02, 0xea, 0xe5, 0x21, 0x00, 0xc9, 0x22, 0x2f,
  0xc8, 0x21, 0x01, 0x03, 0x22, 0x33, 0xc8, 0x3e, 0xff, 0x32, 0x31, 0xc8,
  0xcd, 0x7b, 0xeb, 0xcd, 0x46, 0xeb, 0xe1, 0xd1, 0xc1, 0xc9, 0xcd, 0x02,
  0xea, 0xcd, 0x4b, 0xd2, 0x21, 0x00, 0xc9, 0x22, 0x2f, 0xc8, 0x21, 0x2c,
  0x04, 0x22, 0x33, 0xc8, 0x3e, 0xea, 0x32, 0x31, 0xc8, 0xcd, 0x7b, 0xeb,
  0xc3, 0xf6, 0xe9, 0xcd, 0x02, 0xea, 0xe5, 0x21, 0x00, 0xc9, 0x22, 0x2f,
  0xc8, 0xcd, 0xd4, 0xed, 0xe1, 0xaf, 0x32, 0x6b, 0x02, 0x11, 0x00, 0x00,
  0xcd, 0x50, 0xd4, 0xcd, 0x46, 0xeb, 0xc9, 0xcd, 0x6c, 0xda, 0xef, 0xcd,
  0x2c, 0xd7, 0xeb, 0x22, 0x59, 0x02, 0xeb, 0xcf, 0x2c, 0xcd, 0x6c, 0xda,
  0xcd, 0x28, 0xd7, 0x2b, 0xd7, 0xe5, 0xc5, 0x2a, 0x59, 0x02, 0xeb, 0xcd,
  0xb1, 0xea, 0xc1, 0xe1, 0xc9, 0x42, 0x4b, 0x50, 0x59, 0xd3, 0xb0, 0x2b,
  0x7c, 0xb5, 0xc8, 0x1b, 0x7a, 0xb3, 0xc2, 0xb7, 0xea, 0xc3, 0xb3, 0xea,
  0x31, 0x00, 0xc9, 0xcd, 0xa0, 0xf9, 0xcd, 0x00, 0xe8, 0x21, 0x00, 0x00,
  0x22, 0x02, 0x02, 0x21, 0x01, 0x00, 0x22, 0x00, 0x02, 0xaf, 0x32, 0x00,
  0x03, 0xcd, 0x09, 0xeb, 0x01, 0x50, 0xeb, 0x11, 0x7b, 0xeb, 0x21, 0x6e,
  0x02, 0xcd, 0x11, 0xfa, 0x3e, 0x2c, 0x32, 0x00, 0x01, 0x21, 0x52, 0xc7,
  0x22, 0x52, 0x02, 0x21, 0x4f, 0x80, 0x22, 0x54, 0x02, 0xcd, 0x4b, 0xd2,
  0xc3, 0xa6, 0xe7, 0xcd, 0x09, 0xeb, 0xc3, 0x7f, 0xd1, 0xaf, 0x32, 0x09,
  0xc8, 0x3e, 0x40, 0x32, 0x02, 0xc8, 0xcd, 0x46, 0xeb, 0x3e, 0x03, 0xd3,
  0x90, 0x3e, 0x0d, 0xd3, 0x91, 0x3e, 0x00, 0xd3, 0x92, 0x3e, 0x0b, 0xd3,
  0x93, 0x3e, 0xc3, 0x32, 0xf0, 0xc7, 0x32, 0xf3, 0xc7, 0x32, 0x00, 0x00,
  0x21, 0xfb, 0xf7, 0x22, 0xf1, 0xc7, 0x21, 0xfc, 0xf5, 0x22, 0xf4, 0xc7,
  0x21, 0x03, 0xeb, 0x22, 0x01, 0x00, 0xaf, 0xd3, 0xa8, 0xc9, 0xd3, 0xf8,
  0xd3, 0xb9, 0x3e, 0xff, 0x32, 0xfa, 0x01, 0xc9, 0xff, 0x7e, 0xff, 0x6a,
  0x01, 0x03, 0xc3, 0x56, 0xd4, 0xcd, 0x19, 0xd1, 0xe9, 0xc3, 0x13, 0xdd,
  0xdb, 0xff, 0xc9, 0xd3, 0xff, 0xc9, 0xce, 0x00, 0xc3, 0x66, 0xe2, 0xd6,
  0x00, 0x6f, 0x7c, 0xde, 0x00, 0x67, 0x78, 0xde, 0x00, 0x47, 0x3e, 0x00,
  0xc3, 0xb5, 0xe2
};

asm(" org 0xEB7B");

// Интрактивная функция загрузка файла с ленты

void TapeVerifyLoad() {
    // Установка черно-белого видеорежима
    out(PORT_VIDEO_MODE_1_HIGH, a);
    out(PORT_VIDEO_MODE_0_LOW, a);
    
    // Выбор функции загрузки
    a = vTempTapeRequiredType;
    hl = &TapeVerifyLoadBasic;
    if (a != TAPE_BASIC) {
        hl = &TapeLoadAscii;
        if (a != TAPE_ASCII) {
            hl = &TapeLoadBinary;
            if (a != TAPE_BINARY) {
                vTempTapeRequiredType = a = TAPE_BASIC;
                hl = &TapeVerifyLoadOther;
            }
        }
    }
    vTempTapeFunction = hl;

    // Вывод на экран:
    // Press PLAY on tape
    //  & any key on keyboard
    // И ожидание нажати клавиши
    TapeBeginDialog(hl = &romPressPlayOnTape);

    // Вывод на экран:
    // Searching
    VideoPrintRomString(hl = &romSearching);

TapeVerifyLoadRetry:
    TapeReadPilot();
    if (flag_c) return TapeLoadError();
    TapeReadByte();
    if (flag_c) return TapeLoadError();
    
    // Первый байт содержит тип
    if (a != TAPE_BINARY) {
        if (a != TAPE_BASIC) {
            if (a != TAPE_ASCII) {
                TapeReadByte(); // Взять тип из следующего байта.
                if (flag_c) return TapeLoadError();
            }
        }
    }

    // Следующие 9 байт должны повторять первый.
    c = a;
    b = 9;
    do {
        TapeReadByte();
        if (flag_c) return TapeLoadError();
        if (a != c) return TapeVerifyLoadRetry();
    } while(flag_nz b--);
    
    vTempTapeFoundType = a;
    
    // Далее загружаем 6 байт имени
    hl = &vTempTapeName;
    b = 6;
    do {
        TapeReadByte();
        if (flag_c) return TapeLoadError();
        *hl = a;
        hl++;
    } while(flag_nz b--);
        
    // Вывод на экран типа и имя файла загруженного с ленты
    TapePrintFound();
    
    // Сравниваем тип с требуемым
    a = vTempTapeRequiredType;
    hl = &vTempTapeFoundType;
    if (a != *hl) return TapeVerifyLoadRetry();
    
    // Сравниваем имя с требуемым
    hl = vTempTapeRequiredName;
    de = &vTempTapeName;
    c = 6;
    do {
        a = *hl;
        if (a == 0x0D) break;
        b = a;
        a = *de;
        if (a != b) return TapeVerifyLoadRetry();
        hl++;
        de++;
    } while(flag_nz c--);

    // Вывод на экран:
    // Reading
    VideoPrintRomString(hl = &romReading);
    
    // Переход на функцию загрузки второго блока
    hl = vTempTapeFunction;
    goto hl;
    noreturn;
}

void TapeVerifyLoadBasic() {
    TapeReadPilot();
    if (flag_c) return TapeLoadError();
    
    hl = vTempTape1;
loc_EC31:
    vTempTapeCounter = (a ^= a);
    do {
        TapeReadByte();
        if (flag_c) return TapeLoadError();
        *hl = a;
        hl++;
        
        if (flag_nz a |= a) goto loc_EC31;
        
        a = vTempTapeCounter;
        a++;
        vTempTapeCounter = a;
    } while (a != 3);
    vTempTape2 = hl;
    return TapePrintDone();
    noreturn;
}

void TapeLoadAscii() {
    vTempTapeAsciiRead = hl = vTempTape1;

    while() {
        push(hl) {
            TapeReadPilot();
        }
        if (flag_c) return TapeLoadError();
        
        b = 0;
        do {
            TapeReadByte();
            if (flag_c) return TapeLoadError();
            *hl = a;
            hl++;
            if (a == 0x1A) goto loc_EC87;
        } while(flag_nz b++);

        swap(hl, de);        
        hl = word_26E;
        h--;
        swap(hl, de); 
        if ((a = d) < h) return TapeLoadAsciiOverflow();
        if ((a = e) < l) return TapeLoadAsciiOverflow();
    }

loc_EC87:            
    vInputAddress = hl = &TapeAsciiInput;
    return TapePrintDone();
    noreturn;
}

// Эта функция подменяет собой функцию RealInput во время загрузки ASCII файла с ленты
// Вход: a - символ

void TapeAsciiInput() {
    while() {
        TapeAsciiInputInternal();
        if (a != 0x0A) return;
    }
    noreturn;
}

// Эта функция вызывается функцией выше
// Вход: a - символ

void TapeAsciiInputInternal() {
    push(hl) {
        hl = vTempTapeAsciiRead;
        a = *hl;
        hl++;
        vTempTapeAsciiRead = hl;
    }
    if (a != 0x1A) return;
    push(hl) {
        vInputAddress = hl = &RealInput;
        a = 0x0D;
    }
}

void TapeLoadAsciiOverflow() {
    *hl = 0x1A;
    VideoPrintRomString(hl = &romFileTooLong);
    return loc_EC87();
    noreturn;
}

// Загрузка BINARY блока с ленты

void TapeLoadBinary() {
    TapeReadPilot();
    if (flag_c) return TapeLoadError();

    TapeReadWord(); // Адрес загрузки первого байта
    if (flag_c) return TapeLoadError();
    swap(hl, de);

    TapeReadWord(); // Адрес загрузки последнего байта
    if (flag_c) return TapeLoadError();
    push(hl);

    TapeReadWord(); // Игнорируется
    pop(hl);
    if (flag_c) return TapeLoadError();

    do {
        TapeReadByte();
        if (flag_c) return TapeLoadError();
        *de = a;
        de++;

        if ((a = d) != h) continue;
    } while((a = e) != l);

    return TapePrintDone();
    noreturn;
}

void TapePrintDone() {
    return VideoPrintRomString(hl = &romDone); // Done$
    noreturn;
}

void TapeVerifyLoadOther() {
    TapeReadPilot();
    if (flag_c) return TapeLoadError();
    hl = vTempTape1;
loc_ECFB:
    vTempTapeCounter = (a ^= a);
    do {
        TapeReadByte();
        if (flag_c) return TapeLoadError();
        a ? *hl;
        hl++;
        if (flag_nz) return printVerifyError();
        a |= a;
        if (flag_nz) goto loc_ECFB;

        a = vTempTapeCounter;
        a++;
        vTempTapeCounter = a;
    } while(a != 3);

    return TapePrintDone();
    noreturn;
}

// Загрузка слова в регистр HL с ленты

void TapeReadWord() {
    TapeReadByte();
    if (flag_c) return;
    l = a;    
    TapeReadByte();
    h = a;
}

// Записать BASIC блока на ленту

void TapeWriteBasicBlock() {
    vTempTapeBegin = hl = vBasicProgrammBegin;
    vTempTapeEnd = hl = vBasicProgrammEnd;
    TapeIntractiveWriteHeader(a = TAPE_BASIC);
    TapeWritePilot(a ^= a); // Короткий пилот-тон
    TapeWriteArray();

    // В конце записать 7 нулей
    b = 7;
    do {
        a ^= a;
        EmptyFunction2(); // Задержка
        TapeWriteByte(a);
    } while(flag_nz b--);

    return TapePrintDone();
    noreturn;
}

// Записать BINARY блока на ленту

void TapeWriteBinaryBlock() {
    TapeIntractiveWriteHeader(a = TAPE_BINARY);
    TapeWritePilot(a ^= a); // Короткий пилот-тон
    TapeWriteWord(hl = vTempTapeBegin);
    TapeWriteWord(hl = vTempTapeEnd);
    TapeWriteWord(hl = vTempTapeBegin);
    return TapeWriteArray();
    noreturn;
}

// Записать массив байт на ленту

void TapeWriteArray() {
    hl = vTempTapeEnd;
    hl++;
    swap(de, hl);
    hl = vTempTapeBegin;
    do {
        TapeWriteByte(a = *hl);
        hl++;
        if ((a = d) != h) continue;
    } while((a = e) != l);
}

// Записать слово из регистра HL на ленту
// Вход: hl - значение для записи

void TapeWriteWord() {
    TapeWriteByte(a = l);
    EmptyFunction2(); // Задержка
    TapeWriteByte(a = h);
}

// Вывод на экран текста "Press RECORD & PLAY on tape & any key on keyboard", ожидание нажатия клавиши,
// вывод на экран текста "Saving" и запись заголовка на ленту.

void TapeIntractiveWriteHeader() {
    push(a) {
        // Установка черно-белого видеорежима
        out(PORT_VIDEO_MODE_1_HIGH, a);
        out(PORT_VIDEO_MODE_0_LOW, a);

        // Вывод текста на экран:
        // Press RECORD & PLAY on tape
        // & any key on keyboard
        // и ожидание нажатия клавиши
        TapeBeginDialog(hl = &romPressRecord);

        // Вывод на экран текста "Saving"
        VideoPrintRomString(hl = &romSaving);

        // Запись на ленту длинного пилот-тона
        TapeWritePilot(a = 1);

        // Запись на ленту типа файа 10 раз
        b = 10;
        do {
            pop(a);
            push(a);
            TapeWriteByte(a);
        } while(flag_nz b--);
    }

    // Запись на ленту имени файла. Имя дополняется до 6 символов пробелами справа.
    b = 6;
    hl = vTempTapeRequiredName;
    do {
        TapeWriteByte(a = *hl);
        b--;
        if (flag_z) goto TapeIntractiveWriteHeaderReturn;
        hl++;
    } while((a = *hl) != 13);

    do {
        TapeWriteByte(a = ' ');
        EmptyFunction2();
    } while(flag_nz b--);
TapeIntractiveWriteHeaderReturn:
}

void sub_EDD4() {
    TapeIntractiveWriteHeader(a = TAPE_ASCII);
    vTempTapeAscii = hl = TAPE_ASCII_BUFFER;
    vPrintAddress = hl = &TapeAsciiPrint;
}

// Эта функция подменяет собой функцию VideoPrint во время записи ASCII файла на ленту
// Вход: a - символ

void TapeAsciiPrint() {
    push(a) {
        TapeAsciiPrintInternal();
    }
    if (a != 0x0D) return;
    a = 0x0A;
    return TapeAsciiPrintInternal();
    noreturn;
}

// Эта функция вызывается функцией выше
// Вход: a - символ

void TapeAsciiPrintInternal() {
    // Сохранить байт в буфер
    push(hl, de);
    hl = vTempTapeAscii;
    de = TAPE_ASCII_BUFFER;
    *hl = a;
    hl++;
    vTempTapeAscii = hl;

    if (a != 0x1A) {
        // Если буфер заполнен, то записать его на ленту
        h--;
        if ((a = h) == d) {
            if ((a = l) == e) TapeAsciiFlush();
        }
        pop(hl, de);
        return;
    }

    // Если это последний записываемый символ, то записать бфер на ленту и вернуть управление VideoPrint
    TapeAsciiFlush();
    vPrintAddress = hl = &VideoPrint;
    pop(hl, de);
}

// Записать ASCII буфер на ленту

void TapeAsciiFlush() {
    push(bc, hl) {
        // Запись короткого пилот-тона на ленту
        TapeWritePilot(a ^= a);

        // Запись 256 байт из буфера на ленту
        b = 0;
        hl = TAPE_ASCII_BUFFER;
        do {
            TapeWriteByte(a = *hl);
            hl++;
            EmptyFunction2(); // Задержка
        } while(flag_nz b--);

        // Очищаем буфер
        vTempTapeAscii = hl = TAPE_ASCII_BUFFER;
    }
}

// Вывод на экран типа и имени файла.
void TapePrintFound() {
    // Вывод на экран текста:
    // Found
    VideoPrintRomString(hl = &romFound);

    // Вывод на экран типа загружаемого файла, один из:
    // (BASIC), (ASCII), (BINARY), (UNKNOWN)
    a = vTempTapeFoundType;
    hl = &romBasic;
    if (a != TAPE_BASIC) {
        hl = &romAscii;
        if (a != TAPE_ASCII) {
            hl = &romBinary;
            if (a != TAPE_BINARY) {
                hl = &romUnknown;
            }
        }
    }
    VideoPrintRomString(hl);

    // Вывод на экран имени файла
    hl = &vTempTapeName;
    b = 6;
    do {
        VideoPrint(a = *hl);
        hl++;
    } while(flag_nz b--);

    // Перевод строки
    PrintNewLine();
}

// Вызывается, если произошла ошибка загрузки с ленты
void TapeLoadError() {
    return VideoPrintRomString(hl = &romLoadError);
    noreturn;
}

void printVerifyError() {
    return VideoPrintRomString(hl = &romVerifyError);
    noreturn;
}

// Вывод строки текста на экран из ПЗУ CHARGEN_ROM
// Вход: hl - адрес строки
// Строка оканчивается символом $

void VideoPrintRomString() {
    while() {
        out(PORT_CHARGEN_ROM, a);
        a = *hl;
        out(PORT_CODE_ROM, a);
        if (a == '$') return;
        VideoPrint(a);
        hl++;
    }
    noreturn;
}

// TODO

void TapeBeginDialog() {
    VideoPrintRomString(hl);
    PrintNewLine();
    VideoPrintRomString(hl = &romAndAnyKeyOnKeyboard);
    RealInput2();
    PrintNewLine();
    noreturn;
}

void EmptyFunction2() {
}

uint8_t data4[80];

asm(" org 0xF000");

// Директива монитора P
// Вывести значения ячеек адресного пространства
// <начальный адрес>p<длина>

void MonitorDirectiveP() {
    push(bc, hl);
    MonitorParseChar(); // Пропуск директивы
    MonitorParseNumber();
    if (flag_c) {
        bc = 0x80; // Второй параметр по умолчанию
    }
    vTempMonitorArgument2 = ((hl = vMonitorArgument1) += bc);
    return MonitorPrintHexDump();
    noreturn;
}

// Эта функция вызывается MonitorDirectiveEmpty

void MonitorDirectiveEmpty2() {
    push(bc, hl);
    hl = vTempMonitorArgument2;
    noreturn;
}

void MonitorPrintHexDump() {
    bc = hl;
    hl = vMonitorArgument1;

loc_F022:
    do {
        PrintHexWord(hl);
        vPrint(a = ':');
        PrintSpace();
        PrintSpace();
        push(hl) {
            do {
                PrintHexByte(a = *hl);
                PrintSpace();
                MonitorPrintHexDumpLoop();
            } while(flag_nz);
        }
        PrintSpace();
        PrintSpace();

        do {
            a = *hl;
            if (a < 0x20) {
                a = '.';
            }
            vPrint(a);
            MonitorPrintHexDumpLoop();
        } while(flag_nz);

        push(a) {
            vMonitorArgument1 = hl;
            VideoNextLineClear();
        }
    } while(flag_nc);
    pop(bc, hl);
}

void MonitorPrintHexDumpLoop() {
    hl++;
    if ((a = l) == c) {
        if ((a = h) == b) {
            a ^= a;
            set_flag_c();
            return;
        }
    }
    a = l;
    a &= 7;
}

// Безымянная директива монитора
// Вывести значение ячейки адресного пространства
// <адрес>
// <пустая строка>

void MonitorDirectiveEmpty() {
    hl = vMonitorArgument1;
    hl++;
    vTempMonitorArgument2 = hl;
    return MonitorDirectiveEmpty2();
    noreturn;
}

// Директива монитора L
// Дизассемблер
// <адрес>I<кол-во строк>

void MonitorDirectiveL() {
    MonitorParseChar(); // Пропуск директивы
    MonitorParseNumber();
    if (flag_c) {
        c = 21; // Второй параметр по умолчанию
    }
    return MonitorDirectiveLInternal(a = c);
    noreturn;
}

void MonitorExecute() {
    // Выделяем первый аргумент директивы
    vTempMonitorAble1 = (a ^= a);
    vTempMonitorParse = hl = &vMonitorString;
    MonitorParseNumber();
    if (flag_nc) {
        vTempMonitorArgument1 = a = c;
        *[&vTempMonitorArgument1 + 1] = a = b;
        vTempMonitorAble1 = a = 0xFF;
    }

    // Сама директива
    a = *hl;
    if (a == '!') return MonitorDirectiveEx();
    a &= 0x5F;
    if (a == 'Z') return VideoClearScreen0();
    if (a == 'X') return VideoInverse();
    if (a == 'N') return VideoNormal();
    if (a == 'I') return MonitorDirectiveI();
    if (a == 'O') return MonitorDirectiveO();
    if (a == 'W') return MonitorDirectiveW();
    if (a == 'R') return MonitorDirectiveR();
    if (a == 'Q') return vMonitorQuit();
    push(a) {
        if (flag_nz (a = vTempMonitorAble1) |= a) {
            vMonitorArgument1 = hl = vTempMonitorArgument1;
        }
    }
    if (a == 0x1A) { // Это условия для ':'
        if (flag_nz (a = vTempMonitorAble1) |= a) return MonitorDirectiveSet();
        hl = vMonitorArgument1;
        hl--;
        vMonitorArgument1 = hl;
        return MonitorDirectiveSet();
    }
    if (a == 'L') return MonitorDirectiveL();
    if (a == 'P') return MonitorDirectiveP();
    if (a == 'G') return MonitorDirectiveG();
    if (a == 0x0D) return MonitorDirectiveEmpty();
    if (a == 'M') return MonitorDirectiveM();
    if (a == 'V') return MonitorDirectiveV();
    if (a == 'T') return MonitorDirectiveT();
    noreturn;
}

void MonitorError() {
    vPrint(a = 7);
    VideoNextLineClear();
}

// Вывод строки текста в консоль, а затем перевод строки.
// Строка завершающаяся кодом 0x0D.
// Вход: hl - адрес строки текста

void PrintStringNewLine() {
    PrintString(c = 0x0D);
    vPrint(a = c);
}

// Вывод строки текста в консоль.
// Вход: hl - адрес строки текста, c - код окончания строки

void PrintString() {
    while () {
        a = *hl;
        if (a == c) return;
        vPrint(a);
        hl++;
    }
    noreturn;
}

// Получить очедерной числовой параметр дириктивы монитора
// Выход: bc - число, cf - произошла ошибка, a и d - кол-во обработанных цифр

void MonitorParseNumber() {
    bc = 0;
    d = 0;
    hl = vTempMonitorParse;
    SkipSpaces(hl);
    while() {
        a = *hl;
        CharCodeToNumber();
        if (a == 0xFF) break;
        push(hl) {
            hl = bc;
            hl += hl += hl += hl += hl;
            b = h;
            c = (a |= l);
        }
        hl++;
        d++;
    }
    vTempMonitorParse = hl;
    if (flag_nz (a = d) |= a) return;
    set_flag_c();
}

// Директива монитора W
// Сохранение на ленту в формате BINARY
// <начальный адрес>W<конечный адрес> <имя>

void MonitorDirectiveW() {
    if (flag_z (a = vTempMonitorAble1) |= a) return MonitorError();
    hl = vTempMonitorParse; // Лишняя команда
    MonitorParseChar(); // Пропустить директиву
    MonitorParseNumber();
    if (flag_c) return MonitorError();

    vTempTapeEnd = hl = bc;
    vTempTapeBegin = hl = vTempMonitorArgument1;
    hl = vTempMonitorParse; // Лишняя команда
    MonitorParseSkip(hl);
    vTempTapeRequiredName = hl;
    return TapeWriteBinaryBlock();
    noreturn;
}

// Директива монитора R
// Загрузка с ленты в формате BINARY
// R<имя>

void MonitorDirectiveR() {
    vTempTapeRequiredType = a = TAPE_BINARY;
    MonitorParseSkip(); // Пропустить директиву и пробелы
    vTempTapeRequiredName = hl;
    return TapeVerifyLoad();
    noreturn;
}

// Распознавание введенной пользователем строки в Мониторе.
// Пропустить символ, а затем все пробелы.
// Выход: hl - адрес строки. hl необходимо сохранить в vMonitorParse.

void MonitorParseSkip() {
    MonitorParseChar();
    noreturn;
}

// Пропустить все пробелы в строке
// Вход: hl - адрес строки
// Выход: hl - адрес строки

void SkipSpaces() {
    while () {
        a = *hl;
        if (a != ' ') return;
        hl++;
    }
    noreturn;
}

// Директива монитора !
// Изменяет режим экрана 48/64 символа в ширину

void MonitorDirectiveEx() {
    a = vVideoTextWidth;
    if (a != 48) {
        a = 48;
    } else {
        a = 64;
    }
    vVideoTextWidth = a;
    return VideoRedrawTextScreen();
    noreturn;
}

void MonitorDirectiveSet() {
    hl = vMonitorArgument1;
    swap(de, hl);
    while() {
        MonitorParseChar(); // Пропуск директивы или разделителя значений
        push(de) {
            MonitorParseNumber();
        }
        if (flag_c) return;
        *de = a = c;
        de++;
    }
    noreturn;
}

// Директива монитора T
// Записать текст по указанному адресу
// <адрес>G<текст>

void MonitorDirectiveT() {
    hl = vMonitorArgument1;
    swap(hl, de);
    MonitorParseChar(); // Пропуск директивы
    while() {
        a = *hl;
        if (a == 0x0D) return;
        *de = a;
        de++;
        hl++;
    }
}

// Директива монитора G
// Запустить программу по указанному адресу
// <адрес>G
// G<адрес>

void MonitorDirectiveG() {
    hl = vMonitorArgument1;
    goto hl;
    noreturn;
}

// Директива монитора I
// Прочитать байт из порта ввода-вывода
// <порт>I

void MonitorDirectiveI() {
    // Первый параметр директивы I запоминается. Следующие разы его можно не писать.
    if (flag_nz (a = vTempMonitorAble1) |= a) {
        vMonitorDirectiveIPort = a = vTempMonitorArgument1;
    }
    vTempMonitorProgramm1 = a = vMonitorDirectiveIPort;
    PrintHexByte(a);
    vPrint(a = '=');
    MonitorDirectiveIO(a = OPCODE_IN);
    vTempMonitorProgramm0();
    PrintHexByte(a);
    return VideoNextLineClear();
    noreturn;
}

// Директива монитора O
// Записать байт в порт ввода-вывода
// <порт>O<значение>

void MonitorDirectiveO() {
    // Первый параметр директивы O запоминается. Следующие разы его можно не писать.
    if (flag_nz (a = vTempMonitorAble1) |= a) {
        vMonitorDirectiveOPort = a = vTempMonitorArgument1;
    }
    vTempMonitorProgramm1 = a = vMonitorDirectiveOPort;
    PrintHexByte(a);
    vPrint(a = ':');
    vPrint(a = '=');
    MonitorDirectiveIO(a = OPCODE_OUT);
    MonitorParseChar();
    MonitorParseNumber();
    if (flag_c) {
        VideoInverse();
        vPrint(a = '?');
        VideoNormal();
        return VideoNextLineClear();
    }
    PrintHexByte(a = c);
    VideoNextLineClear();
    return vTempMonitorProgramm0(a = c);
    noreturn;
}

// Используется директивами монитора I и O. Подготавливается програма.

void MonitorDirectiveIO() {
    vTempMonitorProgramm0 = a;
    vTempMonitorProgramm2 = a = OPCODE_RET;
}

void MonitorParseArguments23() {
    MonitorParseChar(); // Пропуск директивы
    MonitorParseNumber();
    if (flag_c) {
        pop(hl);
        return MonitorError();
    }
    vTempMonitorArgument2 = hl = bc;

    MonitorParseChar(); // Пропуск разделителя
    MonitorParseNumber();
    if (flag_c) {
        pop(hl);
        return MonitorError();
    }
    bc++;
    de = bc;
    bc = hl = vTempMonitorArgument2;
    hl = vMonitorArgument1;
}

// Распознавание введенной пользователем строки в Мониторе
// Получить очередной символ
// Выход: a - символ, hl - содержимое vMonitorParse

void MonitorParseChar() {
    hl = vTempMonitorParse;
    a = *hl;
    if (a == 0x0D) return;
    hl++;
    vTempMonitorParse = hl;
}

void CharCodeToNumber() { // TODO: Rewrite
    if (flag_p a ? 'A') goto loc_F2B0;
    if (flag_p a ? 0x3A) goto loc_F2BA;
    if (flag_m a ? '0') goto loc_F2BA;
    a -= '0';
    return;

loc_F2B0:
    a &= 0x5F;
    if (flag_p a ? 0x47) goto loc_F2BA;
    a -= '7';
    return;

loc_F2BA:
    a = 0xFF;
}

// Вывести в консоль 16-ричное число из регистровой пары HL. Четыре символа.
// Вход: HL

void PrintHexWord() {
    PrintHexByte(a = h);
    PrintHexByte(a = l);
}

// Вывести в консоль 16-ричное число из регистра A. Два символа.
// Вход: A

void PrintHexByte() {
    push(a) {
        a >>r= 4;
        PrintHexNibble(a);
    }
    PrintHexNibble();
}

// Вывести в консоль 16-ричное число из 4-х младших битов регистра A. Один символ.
// Вход: A

void PrintHexNibble() {
    a &= 0x0F;
    if (a < 10) {
        a += '0';
    } else {
        a += ['A' - 10];
    }
    vPrint();
}

// Директива монитора M
// Скопировать блок адресного пространства
// <адрес куда>V<адрес откуда> <конец откуда>
// V<адрес откуда> <конец откуда>

void MonitorDirectiveM() {
    MonitorParseArguments23();
    return MemcpyHlBcDe();
    noreturn;
}

// Директива монитора V
// Сравнить два блока адресного пространства
// <адрес 1>V<адрес 2> <конец 2>
// V<адрес 2> <конец 2>

void MonitorDirectiveV() {
    MonitorParseArguments23();
    while() {
        if ((a = c) == e) {
            if ((a = b) == d) return;
        }
        if ((a = *bc) != *hl) MonitorDirectiveVPrint();
        bc++;
        hl++;
    }
    noreturn;
}

void MonitorDirectiveVPrint() {
    push(bc, de, hl) {
        push(bc);
        push(hl) {
            PrintHexWord(hl);
            vPrint(a = ':');
            PrintSpace();
        }
        PrintHexByte(a = *hl);
        PrintSpace();
        vPrint(a = '(');
        pop(hl);
        PrintHexByte(a = *hl);
        vPrint(a = ')');
        VideoNextLineClear();
    }
}

void Init3() {
    VideoNormal();
    VideoClearScreen0();
    vUnused = (a ^= a);
    vMonitorQuit = a = OPCODE_RET;
    Rst38 = a;
    InitVariablesAndHardware();
    PrintStringNewLine(hl = &aIskra1080Tartu);
}

uint8_t aIskra1080Tartu[] = { @"\x1B= 5Iskra 1080 Tartu\x07\r" }; // TODO

void InitVariablesAndHardware() {
    // Установка черно-белого видеорежима
    out(PORT_VIDEO_MODE_0_LOW, a);
    out(PORT_VIDEO_MODE_1_HIGH, a);
    out(PORT_CODE_ROM, a);
    vVideoInverse = (a ^= a);

    // Подключить ОЗУ
    out(PORT_ROM_0000, a = PORT_ROM_0000__RAM);

    // Установка палитры
    out(PORT_PALETTE_3, a = 0x03);
    out(PORT_PALETTE_2, a = 0x0D);
    out(PORT_PALETTE_1, a = 0x00);
    out(PORT_PALETTE_0, a = 0x0B);

    vPrint = a = OPCODE_CALL;
    vInput = a;
    vPrintAddress = hl = &VideoPrint;
    vInputAddress = hl = &RealInput;
    vVideoFontHeight10 = (a ^= a);
    vVideoEscState = a;
    vVideoEscCursorState = a;
    vKeyboardCapsLock = a;
    vKeyboardNumLock = a;
    vVideoTextWidth = a = 64;
    vKeyboardLast = a = 0xFF;
    vKeyboardDelay = hl = 0x1FF;
    vVideoFont = hl = FONT_ADDRESS;
    vKeyboardLayout = hl = &romKeybaordEnglishLayout;
    vKeyboardLeds = a = [LED_CAPS_LOCK | LED_NUM_LOCK];
    UartSetMode(a = [UART_SPEED_3 | UART_MODE__DATA_8 | UART_MODE__STOP_1]);
    vKeyboardF1 = a = 0x9B;
    vKeyboardF2 = a = 0x9C;
    vKeyboardF3 = a = 0x9D;
    vKeyboardF4 = a = 0x97;
    vKeyboardF5 = a = 0x98;
    vKeyboardF6 = a = 0x99;
}

// Инициализация.
// Вызывается обработчиком Rst0

void Init() {
    if ((a = vInited12) != 0x12) return InitFull();
    if ((a = vInited34) != 0x34) return InitFull();
    sp = STACK_ADDRESS;
    KeyboardIsCtrPressed();
    if (flag_c) {
        KeyboardIsShiftPressed();
        if (flag_c) return InitFull();
        return MonitorEntry();
    }
    InitVariablesAndHardware();
    noreturn;
}

void Init2() {
    if ((a = vResetOpcode) == OPCODE_CALL) return vResetOpcode();

    // Ничего не делает
    EmptyCheck();
    if (flag_c) return EmptyFunction();

    // Если контроллер дисководов подключен, то загружаемся с него
    BiosIsNetworkConnected();
    if (flag_c) return BiosBoot();

    Init3();
    return BasicEntry();
    noreturn;
}

// Точка входа в монитор

void MonitorEntry() {
    Init3();

    // Кнопка "сброс" возвращает в Монитор
    vResetAddress = hl = &MonitorResetHandler;
    vResetOpcode = a = OPCODE_CALL;

    // Восстаналиваем приглашение
    vMonitorPrompt = a = 0x7F; // Это смайлик

    return MonitorLoop();
    noreturn;
}

// Вызывается при нажатии на клавишу "Сброс"

void MonitorResetHandler() {
    sp = STACK_ADDRESS;
    vVideoCursorX = (a ^= a);
    VideoSetCursorY(a = 24);
    noreturn;
}

// Основной цикл монитора

void MonitorLoop() {
    while() {
        sp = STACK_ADDRESS;
        MonitorInput();
        MonitorExecute();
    }
    noreturn;
}

void InitFull() {
    sp = STACK_ADDRESS;
    InitVariablesAndHardware();
    Test();
    vInited12 = hl = 0x3412;
    return Init2();
    noreturn;
}

void EmptyCheck() {
    a ^= a;
}

uint8_t data5[] = { 0xFF, 0xFF, 0xFF };

void EmptyFunction() {
}

uint8_t data6[] = { 0xFF, 0xFF, 0xFF };

// Возвращает флаг C, если контроллер дисковода подключен.

void BiosIsNetworkConnected() {
    a = in(PORT_TAPE_AND_IDX2);
    a &= PORT_TAPE_AND_IDX2_ID12;
    set_flag_c();
    if (flag_nz) return;
    invert_flag_c();
}

// Загрузить CP/M. Функция вызывается при включении питания.

void BiosBoot() {
    return BiosBootInternal();
    noreturn;
}

// Обработка прерываний.
// Эта функция вызывается, если произошло прерывание при включенном ПЗУ в адресах 0000.
// Эта функция отключает ПЗУ и повторно вызывает прерывание

void CallRamRst38Handler() {
    vTempRst38 = a;
    out(PORT_ROM_0000, a = PORT_ROM_0000__RAM);
    rst(0x38);
    out(PORT_ROM_0000, a = PORT_ROM_0000__ROM);
    a = vTempRst38;
}

// Продолжение выполнения директивы монитора L
// Вход: a - кол-во строк (0 обозначает 256)

void MonitorDirectiveLInternal() {
    push (hl, bc, de, a) {
        do {
            push(a) {
                Disassembler();
                out(PORT_CODE_ROM, a);
            }
        } while(flag_nz a--);
    }
}

// Дизассемблер

void Disassembler() {
    // Вывод адреса на экран
    PrintHexWord(hl = vMonitorArgument1);
    VideoPrintSpaces(d = 6);    
    swap(de, hl);

    // Вариант 1

    hl = &romDisassemlerOpcodes0;
    // Содержимое массива:
    // 0xC3, 0xCD, 0xC9, 0xEB, 0x2A, 0x22, 0xFE, 0xE6,
    // 0xF6, 0xEE, 0xC6, 0xD6, 0xCE, 0xDE, 0x2F, 0x00,
    // 0xD3, 0x1F, 0x17, 0x0F, 0x07, 0xE9, 0xF9, 0x37,
    // 0x3F, 0xE3, 0x27, 0x76, 0xFB, 0xF3, 0xDB, 0x3A,
    a = *de; // Опкод
    c = 32; // Кол-во элементов в массиве
    out(PORT_CHARGEN_ROM, a);
    do {
        if (a == *hl) return DisassemblerPrintVariant1();
        c--;
        hl++;
    } while(flag_p);

    // Вариант 2 MOV

    a &= 0xC0;
    if (a == 0x40) return DisassemblerPrintVariantMov();

    // Вариант 3

    hl = &asc_C2A1;
    c = 0x16;
loc_F4C7:
    b = ((a = *de) &= *hl);
    a = *hl;
    hl++;
    a &= *hl;
    if (a != b) {
        hl++;
        c--;
        if (flag_p) goto loc_F4C7;
        hl = 0xC2CF; // TODO: Replace
        c = 4;
        DisassemblerPrintOpcode2();
    } else {
        hl--;
        push(hl, a) {
            hl = 0xC35C; // TODO: Replace
            DisassemblerPrintOpcode();
        }
        d = a = *de;
        a = *hl;
        invert(a);
        c = a;
        d = (a &= d);
        hl++;
        e = ((a = *hl) &= c);
        DisassemblerPrintRegister8Loop();
    }
    noreturn;
}

void loc_F4FA() {
    hl = vMonitorArgument1;
    a = vTempDisassembler;
    if (a != 1) {
        push(a) {
            VideoPrintSpaces11();
            a = '$';
            out(PORT_CODE_ROM, a);
            VideoPrint(a);
            out(PORT_CHARGEN_ROM, a);
        }
        hl++;
        if (a == 3) PrintHexByteFromHl(hl);
        out(PORT_CHARGEN_ROM, a);
        a = *hl;
        out(PORT_CODE_ROM, a);
        PrintHexByte(a);
        out(PORT_CHARGEN_ROM, a);
        hl--;
    }

    c = a = vTempDisassembler;
    VideoPrintSpaces(d = 0x14);

    out(PORT_CHARGEN_ROM, a);
    do {
        a = *hl;
        out(PORT_CODE_ROM, a);
        PrintHexByte(a);
        PrintSpace();
        out(PORT_CHARGEN_ROM, a);
        c--;
        hl++;
    } while(flag_nz);
    out(PORT_CODE_ROM, a);

    PrintNewLine();   
    out(PORT_CHARGEN_ROM, a);
    vMonitorArgument1 = hl;
}

void DisassemblerPrintVariant1() {
    hl = &romDisassemlerNames0;
    // Содержимое массива:
    // 0xD3, 0xD4, 0xC1, 0x20  3  STA
    // 0xCC, 0xC4, 0xC1, 0x20  3  LDA
    // 0xC9, 0xCE, 0x20, 0x04  2  IN \x04   TODO: Bug
    // 0xC4, 0x49, 0x20, 0x20  1  DI
    // 0xC5, 0x49, 0x20, 0x20  1  EI
    // 0xC8, 0x4C, 0x54, 0x20  1  HLT
    // 0xC4, 0x41, 0x41, 0x20  1  DAA
    // 0xD8, 0x54, 0x48, 0x4C  1  XTHL
    // 0xC3, 0x4D, 0x43, 0x20  1  CMC
    // 0xD3, 0x54, 0x43, 0x20  1  STC
    // 0xD3, 0x50, 0x48, 0x4C  1  SPHL
    // 0xD0, 0x43, 0x48, 0x4C  1  PCHL
    // 0xD2, 0x4C, 0x43, 0x20  1  RLC
    // 0xD2, 0x52, 0x43, 0x20  1  RRC
    // 0xD2, 0x41, 0x4C, 0x20  1  RAL
    // 0xD2, 0x41, 0x52, 0x20  1  RAR
    // 0xCF, 0xD5, 0x54, 0x20  2  OUT
    // 0xCE, 0x4F, 0x50, 0x20  1  NOP
    // 0xC3, 0x4D, 0x41, 0x20  1  CMA
    // 0xD3, 0xC2, 0x49, 0x20  2  SBI
    // 0xC1, 0xC3, 0x49, 0x20  2  ACI
    // 0xD3, 0xD5, 0x49, 0x20  2  SUI
    // 0xC1, 0xC4, 0x49, 0x20  2  ADI
    // 0xD8, 0xD2, 0x49, 0x20  2  XRI
    // 0xCF, 0xD2, 0x49, 0x20  2  ORI
    // 0xC1, 0xCE, 0x49, 0x20  2  ANI
    // 0xC3, 0xD0, 0x49, 0x20  2  CPI
    // 0xD3, 0xC8, 0xCC, 0x44  3  SHLD
    // 0xCC, 0xC8, 0xCC, 0x44  3  LHLD
    // 0xD8, 0x43, 0x48, 0x47  1  XCHG
    // 0xD2, 0x45, 0x54, 0x20  1  RET
    // 0xC3, 0xC1, 0xCC, 0x4C  3  CALL
    // 0xCA, 0xCD, 0xD0, 0x20  3  JMP
    DisassemblerPrintOpcode();
    return loc_F4FA();
    noreturn;
}

void DisassemblerPrintVariantMov() {
    // Вывод опкода MOV
    c = 4; // Размер элемента массива
    hl = &romDisassemlerNames1; // Содержит MOV и 3
    DisassemblerPrintOpcode2();

    a = *de;
    push(de) {
        e = 32;
        a &= (c = 0x38);
        DisassemblerPrintRegister8();
    }
    a = *de;
    c = 7;
    a &= c;
    e = 4;
    DisassemblerPrintRegister8();
    return loc_F4FA();
    noreturn;
}

void DisassemblerPrintRegister8Loop() {
    a = d;
    noreturn;
}

void DisassemblerPrintRegister8() {
    a >>r= 1;
    d = a;
    e = ((a = e) >>r= 1);
    c = ((a = c) >>r= 1);
    if (flag_nc) return DisassemblerPrintRegister8Loop();

    c = ((a = d) <<r= 1);

    a = e;
    a <<r= 1;
    push(de) {
        hl = 0xC3B7;
        push(a) {
            if (a < 6) VideoPrintSpaces11();
        }
        do {
            hl++;
            hl++;
        } while(flag_nz a--);

        out(PORT_CHARGEN_ROM, a);
        e = *hl;
        hl++;
        d = *hl;
        swap(de, hl);
    }
    noreturn;
}

void DisassemblerPrintOpcode() {
    // Вычислить в HL адрес текстовой строки с опкодом, в C длина текста
    push(de) {
        d = 0;
        e = *hl;
        hl++;

        a = c;
        while(flag_nz a &= a) {
            hl += de;
            a--;
        }

        c = e;
    }
    noreturn;
}

void DisassemblerPrintOpcode2() {
    // Вывести на экран текст из HL длиной C, записать в vCmdL тип аргумента
    push(bc) {
        b = 0;
        do {
            a = *hl;
            if (flag_m a &= a) sub_F5CC();
            a &= 0x7F;
            out(PORT_CODE_ROM, a);
            VideoPrint(a);
            out(PORT_CHARGEN_ROM, a);
            c--;
            hl++;
        } while(flag_nz);

        if (flag_nz (a = b) &= a) {
            vTempDisassembler = a;
        }
    }
}

void sub_F5CC() {
    if ((a = c) == 4) {
loc_F5D2:
        b++;
loc_F5D3:
        a = *hl;
        return;
    }
    if (flag_nz (a = b) &= a) goto loc_F5D2;
    goto loc_F5D3;
    noreturn;
}

void VideoPrintSpaces11() {
    d = 11;
    noreturn;
}

void VideoPrintSpaces() {
    while () {
        a = vVideoCursorX;
        if (a == d) return;
        out(PORT_CODE_ROM, a);
        if (flag_nc) break;
        PrintSpace();
    }
    return VideoPrint(a = ',');
    noreturn;
}

void PrintHexByteFromHl() {
    hl++;
    a = *hl;
    hl--;
    out(PORT_CODE_ROM, a);
    return PrintHexByte(a);
    noreturn;
}

void RealInput() {
    RealInput2();
    if (a == KEY_NUM_LOCK) {
        a = vKeyboardNumLock;
        invert(a);
        vKeyboardNumLock = a;
        vKeyboardLeds = ((a = vKeyboardLeds) ^= LED_NUM_LOCK);
        return RealInput();
    }
    push(hl) {
        vTempInputPrint = a;
        KeyboardReplaceFKeys();
        a = *hl;
    }
    push(a);
    if (flag_nz (a = vKeyboardNumLock) |= a) {
        pop(a);
        if (a == KEY_EXT_POINT) {
            a = '.';            
            goto input_1; // TODO: Optimize
        }
        if (a < KEY_EXT_0) goto input_1; // TODO: Optimize
        if (a >= [KEY_EXT_9 + 1]) goto input_1; // TODO: Optimize
        a -= [KEY_EXT_0 - '0'];
    } else {
        pop(a);
    }
input_1:
    if (a == KEY_UP) {
        VideoMoveCursorUp();
        return RealInput();
    }
    if (a == KEY_DOWN) {
        VideoMoveCursorDown();
        return RealInput();
    }
    if (a == KEY_LEFT) {
        VideoMoveCursorLeft();
        return RealInput();
    }
    if (a == KEY_RIGHT) {
        VideoMoveCursorRight();
        return RealInput();
    }
    if (a == KEY_LEFT_DOWN) {
        VideoMoveCursorDown();
        VideoMoveCursorLeft();
        return RealInput();
    }
    if (a == KEY_RIGHT_DOWN) {
        VideoMoveCursorDown();
        VideoMoveCursorRight();
        return RealInput();
    }
    if (a == KEY_LEFT_UP) {
        VideoMoveCursorUp();
        VideoMoveCursorLeft();
        return RealInput();
    }
    if (a == KEY_RIGHT_UP) {
        VideoMoveCursorUp();
        VideoMoveCursorRight();
        return RealInput();
    }
    if (a == KEY_COP) return VideoGetCharCodeUnderCursor();
    if (a == KEY_EXT_POINT) return VideoGetCharCodeUnderCursor();
    if (a == KEY_EXT_5) {
        a = 0x13;
    }
    if (a == KEY_CAPS_LOCK) {
        a = vKeyboardCapsLock;
        invert(a);
        vKeyboardCapsLock = a;
        vKeyboardLeds = ((a = vKeyboardLeds) ^= LED_CAPS_LOCK);
        return RealInput();
    }
    if (a == KEY_RUS) {
        KeyboardSetRussianLayout();
        return RealInput();
    }
    if (a == KET_LAT) {
        KeyboardSetEnglishLayout();
        return RealInput();
    }
    if (a == KEY_EXT_0) {
        a = 8;
        return;
    }
    push(a);
    if (flag_nz (a = vKeyboardCapsLock) |= a) {
        pop(a);
        if (a < 'A') return;
        if (a < ['Z' + 1]) goto RealInputEnglishChar;
        if (a < 'a') return;
        if (a < ['z' + 1]) goto RealInputEnglishChar;
        if (a < 0xB0) return;
        if (a >= 0xF0) return;
        a += 0x10;
        a ^= 0x20;
        a -= 0x10;
        return;
RealInputEnglishChar:
        a ^= 0x20;
        return;
    }
    pop(a);
}

// Включить русскую раскладку клавиатуры

void KeyboardSetRussianLayout() {
    push(hl);
    hl = &romKeybaordRussianLayout;
    noreturn;
}

// Внутренняя функция использующаяся при установен раскладки клавиатуры

void KeyboardSetLayout() {
    vKeyboardLayout = hl;
    pop(hl);
}

// Включить английскую раскладку клавиатуры

void KeyboardSetEnglishLayout() {
    push(hl);
    return KeyboardSetLayout(hl = &romKeybaordEnglishLayout);
    noreturn;
}

void KeyboardReplaceFKeys() {
    hl = &vTempInputPrint;
    if (a < KEY_F1) return; // TODO: Что за код?
    if (a >= [KEY_F6 + 1]) return;
    a -= KEY_F1;
    push (de) {
        e = a;
        d = 0;
        (hl = &vKeyboardF1) += de;
    }
}

void MonitorInputNextLine() {
    VideoNextLine();
    noreturn;
}

void MonitorInput() {
    // Вывести приглашение
    vPrint(a = vMonitorPrompt);

    push(hl);
    hl = &vMonitorString;
    do {
        RealInput();
        if (a == 8) {
            MonitorInputBackspace();
            continue;
        }
        if (a < ' ') {
            if (a == 0x18) return MonitorInputError();
            if (a == 0x0A) {
                a = 0x0D;
            }
            if (a != 0x0D) continue;            
            *hl = a;
            VideoNextLineClear();
            vMonitorStringLength = a = l;
            pop(hl);
            return;            
        }
        *hl = a;
        hl++;
        vPrint(a);
    } while((a = l) != 0xC0);
    noreturn;
}

void MonitorInputError() {
    vPrint(a = 0x5C); // TODO: Backslash
    vPrint(a = 7);
    VideoNextLine();
    pop(hl);
    return MonitorInput();
    noreturn;
}

// Выключить инверсию при выводе текста
// Функция сохраняет все регистры

void VideoNormal() {
    push(a);
    return VideoInverseInternal(a ^= a);
    noreturn;
}

// Включить инверсию при выводе текста
// Функция сохраняет все регистры

void VideoInverse() {
    push(a);
    a = 0xFF;
    noreturn;
}

// Используется функциями VideoNormal и VideoInverse

void VideoInverseInternal() {
    vVideoInverse = a;
    pop(a);
}

// Включить режим 48 символов в строке
// Функция сохраняет все регистры

void VideoSetMode48() {
    push(a);
    return VideoSetModeInternal(a = 48);
    noreturn;
}

// Включить режим 64 символа в строке
// Функция сохраняет все регистры

void VideoSetMode64() {
    push(a);
    a = 64;
    noreturn;
}

// Используется функциями VideoSetMode48 и VideoSetMode64

void VideoSetModeInternal() {
    vVideoTextWidth = a;
    VideoRedrawTextScreen();
    pop(a);
}

// Высота символа в установленном знакогенераторе 8 пикселей
// Функция сохраняет все регистры

void VideoSetFontHeight8() {
    push(a);
    a ^= a;
    return VideoSetFontHeightInternal();
    noreturn;
}

// Высота символа в установленном знакогенераторе 10 пикселей
// Функция сохраняет все регистры

void VideoSetFontHeight10() {
    push(a);
    a = 0xFF;
    noreturn;
}

// Используется функциями VideoSetFontHeight8 и VideoSetFontHeight10

void VideoSetFontHeightInternal() {
    vVideoFontHeight10 = a;
    pop(a);
}

void VideoSetCursorX() {
    push(de) {
        d = a;
        a = vVideoTextWidth;
        a--;
        a ? d;
        a = d;
    }
    if (flag_c) return;

    push(de, hl);
    vVideoCursorX = a;
    e = a;
    d = 0;
    l = a = vVideoCursorY;
    h = 0;
    MultipleHlBy64();
    return VideoSetCursorInternal();
    noreturn;
}

void VideoSetCursorY() {
    if (a >= TEXT_SCREEN_HEIGHT) return;
    push(de, hl);
    vVideoCursorY = a;
    l = a;
    h = 0;
    MultipleHlBy64();
    e = a = vVideoCursorX;
    d = 0;
    noreturn;
}

void VideoSetCursorInternal() {
    hl += de;
    hl += (de = TEXT_SCREEN_ADDRESS);
    vVideoCursorAddress = hl;
    pop(de, hl);
}

// Вывод в консоль
// Вход: a - код

void VideoPrint() {
    push(a) {
        if (flag_nz (a = vVideoEscCursorState) |= a) return VideoPrintEscCursor();
        if (flag_z (a = vVideoEscState) |= a) return VideoPrintNoEsc();
        vVideoEscState = (a ^= a);
    }
    if (a == 0x2A) return VideoClearScreen0();
    if (a == 0x54) return VideoClearRight();
    if (a == 0x29) return VideoNormal();
    if (a == 0x28) return VideoInverse();
    if (a != 0x3D) return;
    vVideoEscCursorState = a = 2;
}

// Обработка 3 и 4 ого символа ESC-последовательности устанавливающей положение курсора
// Последовательность: 0x1B, 0x3D, Y + 0x20, X + 0x20

void VideoPrintEscCursor() {
    // Тут A = vVideoEscCursorState
    if (a == 2) {
        a--;
        vVideoEscCursorState = a;
        pop(a);
        a -= 0x20;
        if (a >= TEXT_SCREEN_HEIGHT) return;
        vVideoCursorY = a;
        return;
    }
    vVideoEscCursorState = (a ^= a);
    pop(a);
    a -= 0x20;
    return VideoSetCursorX(a);
    noreturn;
}

void VideoPrintNoEsc() {
    pop(a);
    if (a == 0x1B) {
        vVideoEscState = a = 0xFF;
        return;
    }
    if (a >= 0x20) {
        VideoDrawChar(a);
        return VideoMoveCursorRight2();
    }
    if (a == 0x0D) return VideoNextLine();
    if (a == 0x07) return Beep();
    if (a == 0x08) return VideoMoveCursorLeft();
    if (a == 0x0B) return VideoMoveCursorUp();
    if (a == 0x0C) return VideoMoveCursorRight();
    if (a == 0x1E) return VideoMoveCursorLeftTop();
}

void VideoClearRightInternal() {
    push(bc) {
        b = a = vVideoCursorX;
        b = ((a = vVideoTextWidth) -= b);
        if (flag_nz) {
            VideoMoveCursorLeft();
            do {
                VideoMoveCursorRight2();
                VideoDrawChar(a = ' ');
            } while(flag_nz b--);
        }
    }
}

void VideoClearRight() {
    a = vVideoCursorX;
    push(a) {
        VideoClearRightInternal();
    }
    return VideoSetCursorX();
    noreturn;
}

void VideoNextLineClear() {
    VideoClearRightInternal();
    return vPrint(a = 0x0D);
    noreturn;
}

void VideoDrawChar() {
    push(hl, de, bc, a);
        
    // Сохранить код символа
    vTempInputPrint = (a -= 0x20);

    // Получить в E адрес текстовой строки в видеопамяти
    bc = &cVideoTextRowAddess;
    l = a = vVideoCursorY;
    h = 0;
    hl += bc;
    e = *hl;

    // Вычислить в HL адрес символа в знакогенераторе
    // В регистре C высоту символа в знакогенераторе
    bc = hl = vVideoFont;
    l = a = vTempInputPrint;
    h = 0;
    hl += hl += hl += hl;
    hl += bc;
    c = 8;
    if (flag_nz (a = vVideoFontHeight10) |= a) {
        c = a = vTempInputPrint;
        b = 0;
        hl += bc;
        hl += bc;
        c = 10;
    }

    // Если в стрке 64 символа, то продолжаем в другой функции.
    if ((a = vVideoTextWidth) == 64) {
        vTempVideoInverse = a = vVideoInverse;
        vTempVideoCursorX = a = vVideoCursorX;
        vTempVideoFontHeight10 = a = vVideoFontHeight10;
        return VideoDrawChar64();
    }   

    // Получить в D адрес текстового столбца в видеопамяти.
    b = a = vVideoCursorX;
    d = ((a = 0xFF) -= b);

    // Скопировать символ из знакогенератора в видеопамять.
    b = a = vVideoInverse;
    do {
        *de = ((a = *hl) ^= b);
        de--;
        hl++;
    } while(flag_nz c--);
    if (flag_z (a = vVideoFontHeight10) |= a) {
        *de = a = vVideoInverse;
        de--;
        *de = a;
    }
    noreturn;
}

void VideoDrawCharEnd() {
    pop(a);
    hl = vVideoCursorAddress;
    *hl = a;
    pop (hl, de, bc);
}

// Переместить курсор вправо

void VideoMoveCursorRight2() {
    push (hl) {
        hl = vVideoCursorAddress;
        hl++;
        vVideoCursorAddress = hl;
        
        a = vVideoCursorX;
        a++;
        hl = &vVideoTextWidth;
        a ? *hl;
    }
    if (flag_nz) return VideoSetCursorXInternal();
    noreturn;
}

// Перевод строки
// Сохраняет: de, hl

void VideoNextLine() {
    push(de, hl) {
        a = vVideoCursorY;
        a++;
        if (a == TEXT_SCREEN_HEIGHT) {
            VideoScrollUp();
            a = [TEXT_SCREEN_HEIGHT - 1];
        }
        vVideoCursorY = a;

        l = a;
        h = 0;
        MultipleHlBy64();
        hl += (de = TEXT_SCREEN_ADDRESS);
        vVideoCursorAddress = hl;

        waitUntilKeyPressed();
        a ^= a;
    }
    noreturn;
}

void VideoSetCursorXInternal() {
    vVideoCursorX = a;
}

void PrintNewLine() {
    return vPrint(a = 0x0D);
    noreturn;
}

void PrintSpace() {
    return vPrint(a = ' ');
    noreturn;
}

uint8_t data7[] = { 0x3E, 0x20, 0xCD, 0xB0, 0xF8, 0xC3, 0x2E, 0xF9 };

void waitUntilKeyPressed() {
    KeyboardGet();
    if (flag_m) return;

    if (a != 0x20) {
        if (a != 0x13) {
            if (a != 0x85) return;
        }
    }

    push(bc) {
        b = a;
        do {
            KeyboardGet();
        } while (flag_z a ^= b);
    }

    do {
        KeyboardGet();
    } while(flag_m);
}

// Очистить черно-белый экран и переместить курсор в координаты 0, 0
// Инверсия влияет на очистку экрана.
// Функция сохраняет все регистры.

void VideoClearScreen0() {
    push(hl, de, bc, a) {
        a = vVideoInverse;
        VideoClearScreenInternal(b = a, c = a, de = [SCREEN_0_ADDRESS + SCREEN_SIZE]);
        MemsetHlBDe(hl = TEXT_SCREEN_ADDRESS, de = [TEXT_SCREEN_WIDTH * TEXT_SCREEN_HEIGHT], b = ' ');
        VideoMoveCursorLeftTop();
    }
}

// Заполняет область памяти DE-2..DE-0x3000 словом BC

void VideoClearScreenInternal() {
    vTempSP = ((hl = 0) += sp);
    swap(hl, de);
    sp = hl;
    d = [SCREEN_WIDTH / BIT_PER_BYTE];
    do {
        e = [SCREEN_HEIGHT / 16]; // 16 это количество push
        do {
            push(bc, bc, bc, bc, bc, bc, bc, bc);
        } while(flag_nz --e);
    } while(flag_nz --d);
    sp = hl = vTempSP;
}

// Очистить дополнительную видеоплоскость.
// Инверсия влияет на очистку экрана.
// Функция сохраняет все регистры.

void VideoClearScreen1() {
    push (hl, de, bc, a) {
        a = vVideoInverse;
        VideoClearScreenInternal(b = a, c = a, de = [SCREEN_1_ADDRESS + SCREEN_SIZE]);
    }
}

// Переместить курсор в левый верхний угол экрана
// Функция сохраняет регистры BC, DE, HL

void VideoMoveCursorLeftTop() {
    push(hl) {
        a ^= a;
        vVideoCursorX = a;
        vVideoCursorY = a;
        vVideoCursorAddress = hl = TEXT_SCREEN_ADDRESS;
    }
}

// Заполнить память от hl до de - 1 байтом b

void MemsetHlBDe() {
    while () {
        if (flag_z (a = d) |= e) return;
        *hl = b;
        hl++;
        de--;
    }
    noreturn;
}

// Скопировать память от bc до de - 1 в hl

void MemcpyHlBcDe() {
    while () {
        if ((a = c) == e) {
            if ((a = b) == d) return;
        }
        *hl = a = *bc;
        bc++;
        hl++;
    }
    noreturn;
}        

// Умножить HL на 64
// Функция сохраняет регистры A, BC, DE

void MultipleHlBy64() {
    hl += hl += hl += hl += hl += hl += hl;
}

// Адрес строки текста (0 - 24) в графической памяти

uint8_t cVideoTextRowAddess[] = {
    [0xFF -  0 * 10], [0xFF -  1 * 10], [0xFF -  2 * 10], [0xFF -  3 * 10], [0xFF -  4 * 10],
    [0xFF -  5 * 10], [0xFF -  6 * 10], [0xFF -  7 * 10], [0xFF -  8 * 10], [0xFF -  9 * 10],
    [0xFF - 10 * 10], [0xFF - 11 * 10], [0xFF - 12 * 10], [0xFF - 13 * 10], [0xFF - 14 * 10],
    [0xFF - 15 * 10], [0xFF - 16 * 10], [0xFF - 17 * 10], [0xFF - 18 * 10], [0xFF - 19 * 10],
    [0xFF - 20 * 10], [0xFF - 21 * 10], [0xFF - 22 * 10], [0xFF - 23 * 10], [0xFF - 24 * 10]
};

// Звуковой сигнал
// Функция сохраняет регистры BC, DE, HL

void Beep() {
    push(hl, bc) {
        bc = 255;
        do {
            out(PORT_TAPE_OUT, a);
            hl = 31;
            do {
                hl--;
            } while(flag_nz (a = h) |= l);
            bc--;
        } while(flag_nz (a = b) |= c);
    }
}

void RealInput2() {
    push(hl, de, bc) {
        d = a = vVideoInverse;

        while() {
            a = vVideoInverse;
            invert(a);
            vVideoInverse = a;

            bc = 0x1FF;
            VideoDrawChar(a = *(hl = vVideoCursorAddress));
            do {
                bc--;
                KeyboardGet();
                if (a != 0xFF) goto RealInput2Exit;
            } while(flag_nz (a = b) |= c);
        }
RealInput2Exit:
        push(a) {
            vVideoInverse = a = d;
            VideoDrawChar(a = *(hl = vVideoCursorAddress));
        }
    }
}

// Переместить курсор вверх

void VideoMoveCursorUp() {
    a = vVideoCursorY;
    a--;
    return VideoSetCursorY(a);
    noreturn;
}

// Переместить курсор вниз.
// Если курсор находится в последней строке, то происходит прокрутка экрана.

void VideoMoveCursorDown() {
    a = vVideoCursorY;
    a++;
    if (a != TEXT_SCREEN_HEIGHT) return VideoSetCursorY(a);
    
    a = vVideoCursorX;
    push(a) {
        VideoNextLine();
        vVideoCursorY = a = [TEXT_SCREEN_HEIGHT - 1];
    }
    return VideoSetCursorX(a);
    noreturn;
}

// Переместить курсор влево.

void VideoMoveCursorLeft() {
    // Если курсор находится не в крайней левой колонке, то курсор перемещается влево.
    a = vVideoCursorX;
    if (flag_nz a |= a) {
        a--;
        return VideoSetCursorX(a);
    }
    
    // Если курсор находится в левом верхнем углу экрана, то ничего не происходит.
    a = vVideoCursorY;
    if (flag_z a |= a) return;

    // Если курсор находится в крайней левой колонке, то курсор перемещается
    // в крайнюю правую колонку и на строку выше.
    a--;
    vVideoCursorY = a;

    a = vVideoTextWidth;
    a--;
    return VideoSetCursorX(a);
    noreturn;
}

// Переместить курсор вправо

void VideoMoveCursorRight() {
    // Если курсор находится не в крайней правой колонке, то курсор перемещается вправо.
    push (bc) {
        b = a = vVideoTextWidth;
        a = vVideoCursorX;
        a++;
        a ? b;
    }
    if (flag_nz) return VideoSetCursorX(a);

    // Иначе курсор перемещается в крайнюю левую колонку.
    // Если курсор находится в последней строке, то происходит прокрутка
    // экрана, иначе курсор перемещается на строку ниже.
    vVideoCursorX = (a ^= a);
    return VideoMoveCursorDown();
    noreturn;
}

// Получить код символа под курсором

void VideoGetCharCodeUnderCursor() {
    push(hl) {
        a = *(hl = vVideoCursorAddress);
    }
}

// Внутренняя функция.
// Вызывается из MonitorInput, когда пользователь нажимает клавишу влево.

void MonitorInputBackspace() {
    hl--;
    if ((a = [(&vMonitorString - 1) & 0xFF]) == l)  {
        if ((a = [(&vMonitorString - 1) >> 8]) == h)  {
            pop(a);
            return MonitorInputError();
        }
    }
    VideoMoveCursorLeft();
}

// Перерисовать все символы на черно-белом графическом экране по информации из текстового экрана (буферу)
// Функция сохраняет регистр BC
// Инверсия не сохраняется. Инверсия влияет на работу этой функции.

void VideoRedrawTextScreen() {
    push (bc) {
        VideoMoveCursorLeftTop();
        b = TEXT_SCREEN_HEIGHT;
        do {
            c = a = vVideoTextWidth;
            do {
                VideoGetCharCodeUnderCursor();
                VideoPrint(a);
            } while(flag_nz c--);
        } while(flag_nz b--);
    }
}

// Прокрутить на одну строку вверх текстовый и черно-белый экран

void VideoScrollUp() {
    push(hl, de, bc) {
        VideoScrollUp0();
        // Прокрутить на одну строку вверх текстовый экран без очистки нижней строки
        MemcpyHlBcDe(hl = TEXT_SCREEN_ADDRESS, bc = [TEXT_SCREEN_ADDRESS + TEXT_SCREEN_WIDTH], de = [TEXT_SCREEN_ADDRESS + TEXT_SCREEN_WIDTH * TEXT_SCREEN_HEIGHT]);
        // Очистить нижнюю строку
        MemsetHlBDe(hl = [TEXT_SCREEN_ADDRESS + TEXT_SCREEN_WIDTH * (TEXT_SCREEN_HEIGHT - 1)], de = TEXT_SCREEN_WIDTH, b = ' ');
    }
}        

// Прокрутить на одну строку вверх графический черно-белый экран

void VideoScrollUp0() {
    // Прокрутить без очистки нижней строки
    Call0000(hl = &VideoCopy0UpAt0000);

    // Очистить нижнюю строку
    vTempSP = ((hl = 0) += sp);
    hl = 0xFF10;
    b = a = vVideoInverse;
    c = a;
    a = 48;
    do {
        sp = hl;
        push(bc, bc, bc, bc, bc, bc, bc, bc);
        (hl = -240) += sp;
    } while(flag_nz --a);
    sp = hl = vTempSP;
}

// Вызвать функцию по адресу HL и подключить ПЗУ в адреса 0000..00FF на время выполнения этой функции.

void Call0000() {
    vTempCall0000 = hl;

    hl = &Call0000EnableRom;
    vTempVideoRom = (a ^= a);
    if (flag_nz (a = vTempVideoRom) |= a) {
        hl = &Call0000End;
    }
    push(hl);

    hl = vTempCall0000;
    Enable0000Rom();
    goto hl;
    noreturn;
}

void Call0000EnableRom() {
    Enable0000Ram();
    noreturn;
}

void Call0000End() {
}

void Enable0000Rom() {
    push(a);
    a = PORT_ROM_0000__ROM;
    noreturn;
}

void Enable0000Internal() {
    out(PORT_ROM_0000, a);
    pop(a);
}

void Enable0000Ram() {
    push(a);
    a = PORT_ROM_0000__RAM;
    return Enable0000Internal();
    noreturn;
}

void KeyboardGet() {
    push(bc, de, hl);

    KeyboardGetNoWait();
    if (a == 0xFF) goto KeyboardGet4;

    KeyboardCompareWithLastKey();
    if (flag_nz) goto KeyboardGet5;

    hl = vKeyboardDelay;
    do {
        hl--;
        KeyboardGetNoWait();
        if (a == 0xFF) {
            DelayHl(hl = 31);

            KeyboardGetNoWait();
            if (a == 0xFF) goto KeyboardGet4;
        }

        KeyboardCompareWithLastKey();
        if (flag_nz) goto KeyboardGet5;

        b = a;
    } while(flag_nz (a = h) |= l);

    a = b;
    vKeyboardDelay = hl = 31;
    goto KeyboardGet2;

KeyboardGet1:
    DelayHl(hl = 31);
    vKeyboardLast = a;
    vKeyboardDelay = hl = 511;

KeyboardGet2:
    b = a;
    a ^= a;
    a = b;

KeyboardGet3:
    pop(bc, de, hl);
    return;

KeyboardGet4:
    vKeyboardLast = a;
    vKeyboardDelay = hl = 511;
    a |= a;
    goto KeyboardGet3;

KeyboardGet5:
    vKeyboardLast = a = b;
    goto KeyboardGet1;

    noreturn;
}

void KeyboardCompareWithLastKey() {
    b = a;
    a = vKeyboardLast;
    a ? b;
}

// Задержка
// Вход: hl - длительность

void DelayHl() {
    push(hl, a) {
        nop();
        do {
            hl--;
            nop();
        } while(flag_nz (a = h) |= l);
    }
}

// Получить код нажатой клавиши (с учетом шифтов)
// Аргументы: нет
// Результат: a - код символа, регистры bc, de, hl сохраняются

void KeyboardGetNoWait() {
    push(bc, de, hl);
    b = 9;
    do {
        out(PORT_KEYBOARD, (a = vKeyboardLeds) |= b);
        a = in(PORT_KEYBOARD);
        if (flag_nz a |= a) {
            c = 7;
            d = 0x80;
            e = a;
            do {
                if (flag_nz (a = e) &= d) {
                    KeyboardIsShiftKey();
                    if (flag_nc) return KeyboardScancodeToCharcode();
                }
                d = (((a = d) |= a) >>@= 1); // Это d >>= 1
            } while(flag_p c--);
        }
    } while(flag_p b--);
    a = 0xFF;
    return KeyboardScancodeToCharcodeEnd(a);
    noreturn;
}

void KeyboardScancodeToCharcode() {
    ((((a = b) += a) += a) += a) += c; // Это a = b * 8 + c
    hl = vKeyboardLayout;
    
    KeyboardIsShiftPressed();
    if (flag_c) {
        hl += (de = 80);
    } else {
        KeyboardIsCtrPressed();
        if (flag_c) {
            hl += (de = 160);
        } else {
            KeyboardIs71Pressed();
            if (flag_c) {
                (hl = 240) += de;
            }
        }
    }
    e = a;
    d = 0;
    hl += de;
    out(PORT_CHARGEN_ROM, a);
    a = *hl;
    out(PORT_CODE_ROM, a);
    noreturn;
}

void KeyboardScancodeToCharcodeEnd() {
    pop(bc, de, hl);
}

void KeyboardIsShiftKey() {
    push(hl, a);
    hl = 0x303;
    CompareBcHl();
    if (flag_nz) {
        hl = 0x803;
        CompareBcHl();
        if (flag_nz) {
            hl = 0x700;
            CompareBcHl();
            if (flag_nz) {
                pop(a);
                set_flag_c();
                invert_flag_c();
                pop(hl);
                return;
            }
        }
    }
    pop(a);
    set_flag_c();
    pop(hl);
}

// Сравнить BC и HL. Функция возвращает флаг Z, если регистры равны.
// Функция сохраняет регистры BC, DE, HL.

void CompareBcHl() {
    if ((a = b) != h) return;
    (a = c) ? l;
}

void KeyboardIsShiftPressed() {
    push(bc);
    bc = 0x308;
    noreturn;
}

void KeyboardIsKeyPressedInternal() {
    KeyboardIsKeyPressed();
    pop(bc);
}

void KeyboardIsCtrPressed() {
    push(bc);
    return KeyboardIsKeyPressedInternal(bc = 0x808);
    noreturn;
}

void KeyboardIs71Pressed() {
    push(bc);
    return KeyboardIsKeyPressedInternal(bc = 0x701);
    noreturn;
}

void KeyboardIsKeyPressed() {
    push(a) {
        out(PORT_KEYBOARD, a = b);
        a = in(PORT_KEYBOARD);
        a &= c;
        if (flag_nz) {
            pop(a);
            set_flag_c();
            return;
        }
    }
    a |= a; // Clear CF flag
}

// Тестирование компьютера при включении

void Test() {
    // *** Проверка, что ПЗУ по адресам C000..CFFF, F000..FFFF не пустые ***
    TestEmptyRom(b = 0);
    TestEmptyRom(b = 0xFF);

    // Очистка экрана
    VideoClearScreen0();
    VideoClearScreen1();

    // *** Проверка верхней памяти ***
    // Заполнение памяти от 0x9000 до 0xFFFF кодом 0xA5.
    b = 0xA5;
    de = 0x9000;
    hl = 0;
    push(de, hl) {
        MemsetHlBDe();
    }
    // Проверка, что память содержит эти значения
    TestCheckFill();
    if (flag_nz) return TestFailed();
    // Тест пройден
    VideoPrint(a = 'F');

    // *** Проверка шины адреса и мультиплексоров ОЗУ ***
    // Заполнение ячеек памяти 1, 2, 4, 8 .. 0x8000 числами 1, 2, 3, 4 .. 16
    hl = 1;
    b = 1;
    while() {
        *hl = b;
        hl += hl;
        if (flag_c) break;
        b++;
    }
    // Проверка, что память содержит эти значения
    hl = 1;
    b = 1;
    while() {
        a = *hl;
        if (a != b) return TestFailed();
        PrintHexNibble(); // Тут выводятся  16-ричные цифры от 1 до F
        hl += hl;
        if (flag_c) break;
        b++;
    }
    // Тест пройден
    VideoNextLineClear();

    // *** Проверка переключения ОЗУ/ПЗУ в начале адресного пространства ***
    hl = &TestRomAt0000;
    *hl = OPCODE_HALT;
    // Подключить ПЗУ к 0x0000 .. 0x00FF
    out(PORT_ROM_0000, a ^= a); // Тут a == PORT_ROM_0000__ROM
    // ПЗУ содержит RET, а ОЗУ содержит HALT
    TestRomAt0000();
    // Подключить ОЗУ к 0x0000 .. 0x00FF
    invert(a);
    out(PORT_ROM_0000, a); // Тут a != PORT_ROM_0000__ROM
    // Тест пройден
    VideoPrint(a = 'Z');

    // *** Проверка переключения ПЗУ по адресу 0xC000 ***
    out(PORT_CHARGEN_ROM, a);
    hl = 0xC0FF;
    a = *hl;
    if (a == OPCODE_RET) return TestFailed();
    out(PORT_CODE_ROM, a);
    // Тест пройден
    VideoPrint(a = 'C');
    VideoNextLineClear();

    // *** Вывод знакогенератора в консоль ***
    a = 0x20;
    do {
        push(a) {
            VideoPrint(a);
        }
        a++;
    } while(flag_nz);

    // *** Очистка экрана ***
    VideoClearScreen0();
    VideoClearScreen1();
}

// Проверка, что ПЗУ по адресам C000..CFFF, F000..FFFF не заполнено значением регистра B
// Вход: b - значение для проверки

void TestEmptyRom() {
    TestCheckFill(hl = 0xF000, de = 0x1000);
    if (flag_z) return TestFailed();
    TestCheckFill(hl = 0xC000, de = 0x1000);
    if (flag_z) return TestFailed();
}

// Проверка, что память HL .. HL + DE - 1 заполнена константой B.
// Вход: B - константа, HL - адрес, DE - длина
// Результат: Z - память заполнена этой константой, портит все регистры

void TestCheckFill() {
    while() {
        if ((a = *hl) != b) return;
        hl++;
        de--;
        if (flag_z (a = d) |= e) return;
    }
    noreturn;
}

// Вызывается, если тест не пройден.

void TestFailed() {
    halt();
    noreturn;
}

void BiosBootInternal() {
    out(PORT_RESET_CU2, a);
    out(PORT_RESET_CU4, a);
    sp = CPM_STACK_ADDRESS;

    // Очистка черно-белого экрана
    VideoClearScreen0();

    // Выбор ПЗУ c CP/M BIOS и переход туда
    out(PORT_CHARGEN_ROM, a);
    BiosBoot2();
    out(PORT_CODE_ROM, a);    
    noreturn;
}

void BiosWarmBoot() {
    sp = CPM_STACK_ADDRESS;
    out(PORT_CHARGEN_ROM, a);
    BiosInit2();
    BiosLoadDph();
    BiosLoadCpm();
    out(PORT_CODE_ROM, a);
    return cpmEntry();
    noreturn;
}

void BiosConst() {
    KeyboardGet();
    a ^= 0xFF;
    if (flag_z) return;
    a = 0xFF;
}

void BiosWaitKey() {
    return vInput();
    noreturn;
}

void BiosPutch() {
    a = c;
    if (a == 0x1D) goto loc_FDC0;
    if (a != 0x1E) return vPrint();
    a = 64;
loc_FDBC:
    vVideoTextWidth = a;
    return;
loc_FDC0:
    a = 48;
    goto loc_FDBC;
    noreturn;
}

void BiosList() {
    out(PORT_CHARGEN_ROM, a);
    BiosList2();
    out(PORT_CODE_ROM, a);
}

void BiosUnknown() {
    a ^= a;
    noreturn;
}

void BiosAuxOut() {
}

void BiosAuxIn() {
    a = 0x1A;
}

void BiosRead4() {
    BiosRead();
    out(PORT_CHARGEN_ROM, a);
}

void BiosSetDsk() {
    hl = 0;  // Return value
    if ((a = c) >= 1) return;
    vCpmDisk = a;
    vBiosDisk = a;

    a = vCpmDisk;
    l = a;
    h = 0; 
    hl += hl += hl += hl += hl;
    hl += (de = &vBiosEntryDisks);
}

void BiosHome() {
    return vBiosEntrySetTrk(bc = 0);
    noreturn;
}

void BiosSetTrk() {
    vBiosTrackLow = a = c;
    vBiosTrackHigh = a = b;
}

void BiosSetSec() {
    vBiosSector = a = c;
}

void BiosSectTran(bc) {
    hl = bc;
}

void BiosSetDma(bc) {
    l = c;
    h = b;
    vBiosDma = hl;
}

void BiosRead() {
    out(PORT_RESET_CU2, a);
    out(PORT_RESET_CU4, a);
    out(PORT_A0, a);

    // Установка черно-белого видеорежима
    out(PORT_VIDEO_MODE_1_HIGH, a);
    out(PORT_VIDEO_MODE_0_LOW, a);

    // Выбор ПЗУ c CP/M BIOS и переход туда
    out(PORT_CHARGEN_ROM, a);
    BiosRead2();
    return BiosWriteReadInternal();
    noreturn;
}

void BiosWrite() {
    out(PORT_RESET_CU2, a);
    out(PORT_RESET_CU4, a);
    out(PORT_A0, a);

    // Установка черно-белого видеорежима
    out(PORT_VIDEO_MODE_1_HIGH, a);
    out(PORT_VIDEO_MODE_0_LOW, a);

    // Выбор ПЗУ c CP/M BIOS и переход туда
    out(PORT_CHARGEN_ROM, a);
    BiosWrite2();
    noreturn;
}

void BiosWriteReadInternal() {
    out(PORT_CODE_ROM, a);
    return vBiosReadWrite();
    noreturn;
}

void UartCheckWrite() {
    a = vUartWriteByte;
    noreturn;
}

void UartSetMode() {
    push(a);
    a &= UART_MODE__ASYNC_MASK;
    if (flag_z) return UartSetModeSpeed0();
    a--;
    if (flag_z) return UartSetModeSpeed1();
    a--;
    if (flag_z) return UartSetModeSpeed2();

    // Speed 3
    out(PORT_UART_SPEED_0, a);
    noreturn;
}

void UartSetModeInternal() {
    pop(a);
    (a &= [0xFF ^ UART_MODE__ASYNC_MASK]) |= UART_MODE__ASYNC_16;
    out(PORT_UART_CONFIG, a);
}

void UartSetModeSpeed2() {
    out(PORT_UART_SPEED_1, a);
    return UartSetModeInternal();
    noreturn;
}

void UartSetModeSpeed1() {
    out(PORT_UART_SPEED_0, a);
    noreturn;
}

void UartModeInternal10() {
    pop(a);
    (a &= [0xFF ^ UART_MODE__ASYNC_MASK]) |= UART_MODE__ASYNC_64;
    out(PORT_UART_CONFIG, a);
}

void UartSetModeSpeed0() {
    out(PORT_UART_SPEED_1, a);
    return UartModeInternal10();
    noreturn;
}

void UartCheck1() {
    a = in(PORT_UART_CONFIG);
    a &= 2;
    a = 0xFF;
    if (flag_nz) return;
    a ^= a;
}

void UartCheck2() {
    a = in(PORT_UART_CONFIG);
    a &= 1;
    a = 0xFF;
    if (flag_nz) return;
    a ^= a;
}

void UartRead() {
    a = in(PORT_UART_DATA);
}

void UartWrite() {
    out(PORT_UART_DATA, a = vUartWriteByte);
}

// Записать пилот-тон на ленту
// Вход: a = 0 - короткий пилот-тон, иначе длинный

void TapeWritePilot() {
    // Запись тишины
    a |= a;
    push(a) {
        hl = 0;
        do {
            hl--;
        } while(flag_nz (a = h) |= l);
    }

    // Короткий или длинный пилот-тон
    bc = 4000;
    if (flag_nz) {
        bc = 16000;
    }

    // Запись пилот-тона
    do {
        TapeWriteHalfBit1();
        a = in(PORT_TAPE_AND_IDX2); // Задержка
        a = in(PORT_TAPE_AND_IDX2); // Задержка
        bc--;
    } while(flag_nz (a = b) |= c);
}

// Записать байт на ленту
// Вход: a - байт

void TapeWriteByte() {
    push(bc, hl) {
        hl = 0x3B31; // Длительности периода
        push(a) {
          l = ((a = l) -= 3);
          TapeWritePeriod();
        }
        b = 8;
        do {
          a >>r= 1;
          if (flag_c) TapeWriteBit1();
          if (flag_nc) TapeWriteBit0();
        } while(flag_nz b--);
        TapeWriteBit1();
        TapeWriteBit1();
    }
}

// Записать нулевой бит на ленту

void TapeWriteBit0() {
    hl = 0x3B31; // Длительности периода
    nop(); // Задержка
    nop(); // Задержка
    TapeWritePeriod();
}

// Записать единичный бит на ленту

void TapeWriteBit1() {
    TapeWriteHalfBit1();
    swap(*sp, hl); // Задержка
    swap(*sp, hl); // Задержка
    nop(); // Задержка
    nop(); // Задержка
    nop(); // Задержка
    TapeWriteHalfBit1();
}

// Записать один период частоты единичного бита на ленту

void TapeWriteHalfBit1() {
    hl = 0x1D14; // Длительности периода
    nop(); // Задержка
    nop(); // Задержка
    noreturn;
}        

// Записать один период на ленту
// Вход: h, l - длительности

void TapeWritePeriod() {
    push(a) {
        do {
        } while(flag_nz l--);
        out(PORT_TAPE_OUT, a);
        do {
        } while(flag_nz h--);
        out(PORT_TAPE_OUT, a);
    }
}

void TapeReadPilot() {
    hl = 0x457;
loc_FEF4:
    d = c;
    readDblInterval();
    if (flag_c) return;
    a = c;
    if (a >= 222) return TapeReadPilot();
    if (a < 5) return TapeReadPilot();
    a -= d;
    if (flag_c) {
        invert(a);
        a++;
    }
    if (a >= 8) return TapeReadPilot();
    hl--;
    (a = h) |= l;
    if (flag_nz) goto loc_FEF4;
    hl = 0;
    b = l;
    d = l;

loc_FF1A:
    readDblInterval();
    if (flag_c) return;
    hl += bc;
    d--;
    if (flag_nz) goto loc_FF1A;

    bc = 1710;
    hl += bc;

    a = h;
    a >>@= 1;
    a &= 0x7F;
    d = a;

    hl += hl;

    a = h;
    a -= d;
    d = a;

    a -= 6;
    vTempTape3 = a;

    a = d;
    a += a;
    a += d;
    a &= 0xFC;
    a >>r= 1;
    a >>r= 1;
    a -= 3;
    vTempTape4 = a;
    a |= a;
}

void TapeReadByte() {
    push(de, bc, hl);
    d = a = vTempTape3;

    do {
        checkStop();
        if (flag_c) goto loc_FF97;
        a = in(PORT_TAPE_AND_IDX2);
        a >>r= 1;
    } while(flag_nc);

    do {
        checkStop();
        if (flag_c) goto loc_FF97;
        a = in(PORT_TAPE_AND_IDX2);
        e = a;
        a >>r= 1;
    } while(flag_c);

    readInterval0S();

loc_FF66:
    b = c;
    readInterval0S();
    if (flag_c) goto loc_FF97;
    a = b;
    a += c;
    if (flag_c) goto loc_FF66;
    a ? d;
    if (flag_c) goto loc_FF66;

    l = 8;
loc_FF78:
    someReadWait();
    a ? 4;
    invert_flag_c();
    if (flag_c) goto loc_FF97;
    a ? 2;
    invert_flag_c();
    a = d;
    a >>@= 1;
    d = a;
    a = c;
    a >>r= 1;
    if (flag_nc) readInterval0();
    readInterval0S();
    l--;
    if (flag_nz) goto loc_FF78;
    checkStop();
    a = d;

loc_FF97:
    pop(de, bc, hl);
}

// Сколько было преходов за заданный интервал

void someReadWait() {
    b = a = vTempTape4;
    c = 0;

loc_FFA1:
    do {
        a = in(PORT_TAPE_AND_IDX2);
        a ^= e;
        if (flag_z) return loc_FFB0();
        a ^= e;
        e = a;
        c++;
    } while(flag_nz b--);
    a = c;
}

void loc_FFB0() {
    nop();
    nop();
    nop();
    a++;
    b--;
    if (flag_nz) return loc_FFA1();
    a = c;
}

void readInterval0S() {
    checkStop();
    if (flag_c) return;
    noreturn;
}

void readInterval0() {
    c = 0;
    noreturn;
}

void readIntervalEx() {
    do {
        c++;
        if (flag_z) return loc_FFCD();
        a = in(PORT_TAPE_AND_IDX2);
        a ^= e;
    } while(flag_z);
    a ^= e;
    e = a;
}

void loc_FFCD() {
    c--;
}

void readDblInterval() {
    do {
        checkStop();
        if (flag_c) return;
        e = a = in(PORT_TAPE_AND_IDX2);
        a >>r= 1;
    } while(flag_c);
    readInterval0();
    return readIntervalEx();
    noreturn;
}

void checkStop() {
    out(PORT_KEYBOARD, a = 9);
    a = in(PORT_KEYBOARD);
    a >>r= 1;
}

uint8_t unused[4];

void CopyFromHiddenRom() {
    while () {
        if ((a = c) == e) {
            if ((a = b) == d) return;
        }        
        out(PORT_CHARGEN_ROM, a);
        a = *bc;
        out(PORT_CODE_ROM, a);
        *hl = a;
        bc++;
        hl++;
    }
    noreturn;
}

uint8_t data8 = 0xFF;

asm (" savebin \"i1080.bin\", 0xC000, 0xFFFF");
