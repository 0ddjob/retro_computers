;  * Debug Version For Home Computer POISK  - 2.0 *
;ver 26.02.90
;****** ОТКРЫТА ПАМЯТЬ (96К) ******
INCLUDE EQU.ASM       ;Константы и переменные
;--------------------------------------------------------------------------
; Константы
;-----------------------------------------------------------------------------
;  коррекции:
;     14.02.89 - переменная SCAN_CODE_OLD
;-----------------------------------------------------------------------------
FALSE           EQU        0
TRUE            EQU        NOT FALSE
FIRST_TIME      EQU        8
SECOND_TIME     EQU        2
DATA_ORG        EQU        80H
KEY_INT         EQU        9
CURSOR_TIME     EQU        4
PORT_A          EQU        60H         ;Адрес порта А 8255
PORT_B          EQU        61H         ;Адрес порта B 8255
PORT_C		EQU        62H	       ;Адрес порта C 8255
INTA00          EQU        20H         ;Порт 8259
INTA01          EQU        21H         ;Порт 8259
EOI             EQU        20H
TIMER           EQU        40H
TIM_CTL         EQU        43H         ;Адрес порта управления таймером 8253
TIMER0          EQU        40H         ;Адрес порта счетчика/таймера 0  8253
TMINT           EQU        01          ;Маска прерывания таймера 0
MOTOR_TURN_BIT  EQU	   04H
KBD_IN          EQU        60H         ;Адрес порта ввода данных клавиатуры
BDINT           EQU        02          ;Маска прерываний клавиатуры
KB_DATA         EQU        60H         ;Порт сканкодов клавиатуры
KB_CTL          EQU        61H         ;Управляющие биты клавиатуры
;----------------------------------------------------------------------------
; Определение порта 8255 для PPI_TRAP или PPI_KBD
;----------------------------------------------------------------------------
TRAP_A		EQU	28H		;
TRAP_D		EQU	2AH		;
SCR_MODE        EQU     68H             ;Порт режима
P61		EQU	61H
P6A             EQU     6AH             ;PORT SET COLOR!!!!!!!!!!!!!!!!!!!!!!!!
P62             EQU     62H
PPIC		EQU	63H		;Порт режима PPI_TRAP
;
LINE_SEL	EQU	60H		;Выбор строки или сохранение сканкод
COL_READ	EQU	69H		;Чтение колонок KBD
KEY_SERV_MODE	EQU	6BH		;Порт режима PPI_KBD
;----------------------------------------------------------------------------
; Адреса прерываний К1810 ВМ88
;----------------------------------------------------------------------------
ABS0   SEGMENT         AT 0
STG_LOC0               LABEL     BYTE
       ORG             2*4
NMI_PTR                LABEL     WORD
       ORG             5*4
INT5_PTR               LABEL     WORD
       ORG             8*4
INT_ADDR               LABEL     WORD
INT_PTR                LABEL     DWORD
       ORG             10H*4
VIDEO_INT              LABEL     WORD
       ORG             1DH*4
PARM_PTR               LABEL     DWORD       ;Указатель параметров ВИДЕО
       ORG             01EH*4                ;Указатель параметров диска
DISK_POINTER           LABEL     DWORD
       ORG             01FH*4                ;Расположение знакогенератора
EXT_PTR                LABEL     DWORD       ;Для графического режима
       ORG             7C00H
BOOT_LOCN              LABEL     FAR
ABS0   ENDS
;-----------------------------------------------------------------------------
; Стек - используется только во время инициализации
;------------------------------------------------------------------------------
STOCK  SEGMENT         AT  30H
       DW              128 DUP(?)
TOS    LABEL           WORD
STOCK  ENDS
;-----------------------------------------------------------------------------
; Области данных для ПЗУ BIOS
;------------------------------------------------------------------------------
DATA   SEGMENT         AT  40H
RS232_BASE             DW     4 DUP(?)     ;Адреса портов адаптеров RS232
PRINTER_BASE           DW     4 DUP(?)     ;Адреса портов принтеров
EQUIP_FLAG             DW     ?            ;Установленное оборудование
                                           ;              (аппаратура)
MFG_TST                DB     ?            ;Флаг инициализации
MEMORY_SIZE            DW     ?            ;Размер памяти в Кбайтах
IO_RAM_SIZE            DW     ?            ;Размер памяти канала ввода-вывода
;-----------------------------------------------------------------------------
; Область данных клавиатуры
;------------------------------------------------------------------------------
KB_FLAG                DB     ?
;------Расположение флагов SHIFT внутри переменной KB_FLAG
INS_STATE              EQU    80H          ;Состояние вставки (INS)
CAPS_STATE             EQU    40H          ;Нажата клавиша ФИКС.ВЕРХ (CAPS)
NUM_STATE              EQU    20H          ;Нажата клавиша ЦИФРА (NUM)
SCROLL_STATE           EQU    10H          ;Нажата клавиша свертки
ALT_SHIFT              EQU    08H          ;Нажата клавиша ДОП(ALT)
CTL_SHIFT              EQU    04H          ;Нажата клавиша УПР (CTL)
LEFT_SHIFT             EQU    02H          ;Нажата клавиша ВЕРХ (слева)
RIGHT_SHIFT            EQU    01H          ;Нажата клавиша ВЕРХ (справа)
KB_FLAG_1              DB     ?            ;Второй байт состояния клавиатуры
INS_SHIFT              EQU    80H          ;Нажата клавиша вставки (INS)
CAPS_SHIFT             EQU    40H          ;Нажата клавиша ФИКС.ВЕРХ (CAPS)
NUM_SHIFT              EQU    20H          ;Нажата клавиша ЦИФРА (NUM)
SCROLL_SHIFT           EQU    10H          ;Нажата клавиша свертки
HOLD_STATE             EQU    08H          ;Задержка нажатия клавиши
ALT_INPUT              DB     ?            ;Ячейка для ввода ALT
BUFFER_HEAD            DW     ?            ;Указатель вершины буфера клавиатуры
BUFFER_TAIL            DW     ?            ;Указатель начала буфера клавиатуры
KB_BUFFER              DW     16 DUP(?)    ;Область для 15-ти вводов в буфер
KB_BUFFER_END          LABEL  WORD         ;Конец буфера клавиатуры
;-----Вершина=началу показывает, что буфер пуст
NUM_KEY                EQU    69           ;Код сканирования клавиши ЦИФРА
SCROLL_KEY             EQU    70           ;Код сканирования клавиши свертки
ALT_KEY                EQU    56           ;Код сканирования клавиши ДОП
CTL_KEY                EQU    29           ;Код сканирования клавиши УПР
CAPS_KEY               EQU    58           ;Код сканирования клавиши ИКС.ВЕРХ
LEFT_KEY               EQU    42           ;SCAN-код левой клавиши ВЕРХ
RIGHT_KEY              EQU    54           ;SCAN-код правой клавиши ВЕРХ
INS_KEY                EQU    82           ;SCAN-код клавиши вставки
DEL_KEY                EQU    83           ;SCAN-код клавиши удаления
RUS_KEY                EQU    91           ;SCAN-код клавиши РУС/ЛАТ
SHIFT2_KEY             EQU    92           ;SCAN-код клавиши SHIFT2
;----------------------------------------------------------------------------
; Области данных НГМД
;----------------------------------------------------------------------------
SEEK_STATUS            DB     ?             ;Состояние перекалибровки
;                                           Биты 3-0= Устройство нуждается
;                                           в перекалибровке перед следующей
;                                           щперацией поиска, если бит=0
INT_FLAG               EQU    080H          ;Флаг обнаружения прерывания
MOTOR_STATUS           DB     ?             ;Состояние двигателя
;                             Биты 3-0 = Устройство 3-0 работает
;                             Бит 7 = текущая операция - запись,
;                             задержка ответа НГМД
MOTOR_WAIT             EQU    37            ;Счетчик задержки (2сек) для
;                                            запуска двигателя
MOTOR_COUNT     	DB	?           ;Счетчик времени запуска
;
DISKETTE_STATUS        DB     ?             ;Байт кода возврата
;                                      Байты состояний контроллера НГМД (7байт)
NEC_STATUS		LABEL BYTE      	;7 BYTE
TRACK_PTR              DB     2 DUP(?)
STEP_MULT              DB     ?
			DB	4 DUP (?)	;Резерв
;-----------------------------------------------------------------------
;--------------------------
; Контакты для ВИДЕО
;--------------------------
;                    !/Высокое разрешение
;                    !!/Активная страница ВИДЕО
;                    !!!/Цветовая палитра
;                    !!!!/Фон палитры
;                    !!!!!/Бит разрешения NMI
CHAR_40_MODE   EQU   01000000B
CHAR_80_MODE   EQU   11000000B
MED_RES_MODE   EQU   00101000B
HIGH_RES_MODE  EQU   10001000B
CRT_MODE_PORT  EQU   3DEH              ;Порт текущего режима отображения
START_BUFFER   EQU   0B800H            ;Начало буфера
EXTRA_BUFFER   EQU   START_BUFFER+400h ;Конец буфера (16К)
REG3D4         EQU   3D4H
REG3D5         EQU   3D5H
REG3D8         EQU   3D8H
REG3D9         EQU   3D9h
REG3DA         EQU   3DAH
REG3DE         EQU   3DEH
DSEGMENT       EQU   40h
INT_VIDEO      EQU   10H
;---------------------------------------------------------------------------
;  Область данных ВИДЕО
;--------------------------------------------------------------------------
CRT_MODE      DB      ?       ;Текущий режим отображения
CRT_COLS      DW      ?       ;Число колонок экрана
CRT_LEN       DW      ?       ;Длина видеопамяти в байтах
CRT_START     DW      ?       ;Начальный адрес видеобуфера
CURSOR_POSN   DW      8 DUP(?);Курсор для каждой из 8-ми страниц
CURSOR_MODE   DW      ?       ;Текущий режим курсора
ACTIVE_PAGE   DB      ?       ;Текущая отображаемая страница
ADDR_6845     DW      ?
CRT_MODE_SET  DB      ?       ;Текущее назначение для 3x8 регистров
CRT_PALLETTE  DB      ?       ;Текущая палитра для цветной графики
;----------------------------------------------------------------------------
;  Область данных кассетного магнитофона
;----------------------------------------------------------------------------
EDGE_CNT               DW      ?             ;Счетчик длительности конца данных
CRC_REG                DW      ?             ;Регистр CRC
;----------------------------------------------------------------------------
INTR_FLAG              DB      ?             ;Флаг прерывания
;----------------------------------------------------------------------------
;  Область данных таймера
;----------------------------------------------------------------------------
TIMER_LOW              DW       ?            ;Мл. слово счетчика таймера
TIMER_HIGH             DW       ?            ;Ст. слово счетчика таймера
TIMER_OFL              DB       ?            ;Признак цикла таймера
                                             ;После последнего чтения
;COUNTS_SEC            EQU      18
;COUNTS_MIN            EQU      1092
;COUNTS_HOUR           EQU      65543
;COUNTS_DAY            EQU      1573040=1800B0H
;-----------------------------------------------------------------------------
; Область системных данных
;-----------------------------------------------------------------------------
BIOS_BREAK             DB        ?            ;Бит 7=1 если клавиша
;                                              отпускается
RESET_FLAG             DW        ?            ;Слово=1234H если сброс
;                                              от клавиатуры
;------------ Переменная INT15H ----------------------------------------------
LOWLIM		DW	?		;MIN ДЛИТ. ПЕРИОДА "1"
;
ORG DATA_ORG
;
;--------Дополнительная область ВИДЕО-----------------------------------------
;
CURSOR_COUNT           DB        ?
;                                             Сброс
CRT_MODE_SAFE DB      ?       ;Текущий режим отображения
CURSOR_ON     DB      ?       ;Флаг установки курсора
CRT_STATUS    DB      ?
REG_6845      DB      ?
CURSOR_POS_L  DB      ?
CURSOR_POS_H  DB      ?
;
;--------Область данных эмуляции клавиатуры-----------------------------------
;
KB_STAT_L     EQU     8     ; количество линий в матрице клавиатуры
KB_STAT_C     EQU     800H  ; код старшей колонки (клавиши в линии)
KB_STAT_S     EQU     80H   ; код старшей линии
KB_KEY        EQU     96    ; количество клавиш
KB_L_KEY      EQU     12    ; количество линий
KB_STAT       DW      KB_STAT_L DUP (?) ; состояние клавиатуры по линиям )
RUSS          DB      ?     ; признак наличия TRUE или FALSE
FBEEP         DB      ?     ; признак наличия TRUE или FALSE
TIME          DB      ?     ; количество тиков до повторения кода клавиши
LAST          DW      ?     ; адрес последней нажатой клавиши
                            ; 00 - нет клавиши для повторения
EMPTY	      DW      ?     ; состояние клавиатуры после последнего
                            ; опроса (интегральная оценка: пустая/ не пустая)
                            ; 00 - пустая клавиатура
                            ; другой код - не пустая клавиатура
W_SCAN        DB      ?     ; работает сканирование аппаратуры
; SHIFT1        DB      ?
SHIFT2        DB      ?
MEM_KEY       DB      15 DUP (?)  ; память нажатий особых клавиш
                            ;   ( с тремя скан-кодами )
SCAN_CODE_OLD DB      ?     ; последний скан_код из порта 60H
;------------- имя файла для кассетного магнитофона -----------------------
LOAD_ADDR               DW       ?
BUFFERM         DB      8 DUP (?)
LAST_VAL        DB      ?        ;Последнее введенное значение
K_CICL          DB      ?
T_CURSOR        DB      ?
DATA   ENDS
;----------------------------------------------------------------------------
;----------------------------------------------------------------------------
;  Область дополнительных данных
;----------------------------------------------------------------------------
XXDATA  SEGMENT         AT       50H
STATUS_BYTE             DB       ?
                        ORG      6
;ADDR_MON                DW       ?
XXDATA ENDS
;-----------------------------------------------------------------------------
; Видеобуфер
;-----------------------------------------------------------------------------
VIDEO_RAM               SEGMENT AT 0B800H
REGEN   LABEL           BYTE
REGENW  LABEL           WORD
        DB              16384 DUP(?)
VIDEO_RAM   ENDS
VECTOR  SEGMENT AT 0F000H
        ASSUME CS:VECTOR
        ORG    0E016H
RESETV  LABEL   FAR
VECTOR  ENDS
hard    segment at 5400h
	assume cs:hard
	org    0h
hd	label    far
hard    ends
INT13   SEGMENT AT 0E000H
        ASSUME CS:INT13
        ORG    40H
INT13_SERVICE	LABEL	FAR
INT13   ENDS
KARTR   SEGMENT AT 0C000H           ;Область памяти картридиса
        ASSUME CS:KARTR
        ORG    0000H
KARTRIDJ	LABEL	FAR
KARTR   ENDS
BOOTM   SEGMENT AT 60H
        ASSUME CS:BOOTM
        ORG    0000H
BOOT_SM LABEL	FAR
BOOTM   ENDS
;----------------------------------------------------------------------------
;  Коды ПЗУ
;----------------------------------------------------------------------------
CODE    SEGMENT
        ORG    0E000H
DB             'POISK (C) 1989 UkSSR  '  ;Метка фирмы
INCLUDE TEST.ASM      ;Начальный тест и инициализация
;---------------------------------------------------------------------------
; Начальные тест-программы, инициализация
;---------------------------------------------------------------------------
        ASSUME  CS:CODE, DS:DATA
RESET   LABEL   NEAR
START:  CLI                          ;Точка ахода в BIOS (по сбросу,
                                     ;по включению питания)
        IN      AL,TRAP_A            ;Сброс триггера NMI
        MOV     AL,89H               ;Установка режима 8255 (TRAP)
        OUT     PPIC,AL
        MOV     AL,88H               ;Установка режима
        OUT     SCR_MODE,AL
        IN      AL,TRAP_A            ;Сброс триггера NMI
        MOV     AL,83H               ;Установка режима 8255 (KBD)
        OUT     KEY_SERV_MODE,AL     ;Установка режима клавиатуры
; Передача управления привелигированному ПЗУ, если оно есть
        MOV     AX,0C000H
        SUB     BX,BX
        MOV     DS,AX
        CMP     DS:[BX],055AAH
        JNZ     ST0
        JMP     KARTRIDJ+3
ST0:    SUB     AX,AX
        MOV     ES,AX                ;Сегмент=0
        XOR     DI,DI
        MOV     CX,0FFFFH
        CLD                          ;Очистка области памяти=64К
        REP     STOSB
        MOV     CX,0800H
        MOV     ES,CX
        MOV     DI,8000H
        MOV     CX,DI
        CLD
        REP     STOSB
        MOV     ES,AX                ;Сегмент=0
        XOR     DI,DI
        MOV     CX,0FFFFH
        CLD                          ;Очистка области памяти=64К
        REP     SCASB
        CMP     CX,0
        JZ      CLR1
        HLT
CLR1:   MOV     CX,0800H
        MOV     ES,CX
        MOV     DI,8000H
        MOV     CX,DI
        CLD
        REP     SCASB
        CMP     CX,0
        JZ      CLR2
	MOV	DX,04
	CALL	BEEP_ERROR
        HLT
CLR2:
        MOV     ES,AX
	MOV	SS,AX
	MOV	SP,03FFH
        PUSH    CS                   ;Установка таблицы прерываний:
        PUSH    CS
        POP     BX
        POP     DS
        MOV     CX,1EH               ;Установка счетчика векторов
        MOV     SI,OFFSET VECTOR_TABLE      ;Смещение таблицы векторов
        MOV     DI,OFFSET INT5_PTR
SM0:    LODSW                        ;Пересылка таблицы векторов
        STOSW                        ;(Адреса обслуживания прерываний)
        MOV     AX,BX
        STOSW
        LOOP    SM0
        MOV     DI,8
        MOV     AX,OFFSET NMI_SERVICE ;Засылка вектора NMI
        STOSW
        MOV     AX,BX
        STOSW
        MOV     AX,DATA
        MOV     ES,AX
        MOV     CX,10H               ;Размер TEST_TABLIC
        MOV     SI,OFFSET TEST_TABLIC ;(Таблица конфигурации)
        MOV     DI,OFFSET RS232_BASE
        REP     MOVSW
	SUB	AX,AX
IX0:    ADD     AX,4000H
	PUSH	AX
	MOV	DS,AX
	SUB	BX,BX
	MOV	AX,5AA5H
	MOV	[BX],AX
	NOT	AX
	NOT	WORD PTR [BX]
	CMP	WORD PTR [BX],AX
	POP	AX
	PUSH	ES
	POP	DS
	JNZ	IX1
	ADD	MEMORY_SIZE+1,1
	JMP	IX0
IX1:    MOV     MOTOR_STATUS,1
    ;;; MOV     EMPTY,0            ; клавиатура пустая
        MOV     FBEEP,TRUE
    ;;;	MOV	RUSS,FALSE
    ;;; MOV     SHIFT1,LEFT_KEY    ; клавиша отжата
        MOV     AL,13H                ;Установить режим 8259
        OUT     INTA00,AL             ;Контроллер прерываний
        MOV     AL,8
        OUT     INTA01,AL
        MOV     AL,9
        OUT     INTA01,AL
        MOV     AL,36H               ;Установить режим 8253
        OUT     TIM_CTL,AL           ;Таймер
        XOR     AL,AL
        OUT     TIMER0,AL            ;Канал 0
        OUT     TIMER0,AL
        MOV     AL,76H
        OUT     TIM_CTL,AL
        XOR     AL,AL
        OUT     TIMER0+1,AL          ;Канал 1
        OUT     TIMER0+1,AL
; Установка режима VIDEO
        MOV     AX,0003H
        INT     10H
; Тест BIOS
        PUSH    DS
        PUSH    CS
        POP     DS
        MOV     BX,0E000H
        MOV     CX,2000H
        CALL    ROS_CHECKSUM         ;Проверка контрольной суммы
        JZ      IX2
        MOV     DX,3
        CALL    BEEP_ERROR
        HLT
; Установка начальных значений дисковых переменных
IX2:    POP     DS
        MOV     BYTE PTR TRACK_PTR,0H
        MOV     BYTE PTR TRACK_PTR+1,0H
;Заполнение начального значения адреса загрузки
        MOV     WORD PTR LOAD_ADDR,0060H
        STI                          ;Разрещить прерывания
; Выдачы заставки
; Проверка и инициализация ПЗУ и картреджей
        MOV     DX,0C000H
ROM_CH0:
        MOV     DS,DX
        SUB     BX,BX
        CMP     [BX],0AA55H
        JNE     ROM_CH1
        CALL    ROM_INIT
ROM_CH1:
        ADD     DX,20H
        CMP     DX,0FE00H
        JL      ROM_CH0
SYS_BOOT:
        PUSH    DS
        INT     19H                  ;Загрузка системы
        POP     DS
        INT     18H                  ;Передача управления ПЗУ
                                     ;или работа с кассетой
INCLUDE MONN.ASM      ;Монитор
MONITOR      PROC    FAR
        JMP    M0
MONITOR      ENDP
;
;---------------------------------------------
;   НАСТРОЙКА ЭКРАНА - 40*25 ЦВЕТНОЙ
;---------------------------------------------
M0:
        SUB     AX,AX
	MOV	SS,AX
	MOV	SP,03FFH
        mov    ax,01
        int    10h
;---------------------------------------------
;        Вывод полного меню
;---------------------------------------------
MX0:    lea    si,s0
	mov	cx,LS0
        call   P_MSG
mX1:    call   read_char   ;ПРИЕМ ОТВЕТА
        cmp    AH,3BH      ;РАБОТА С КАССЕТОЙ?
        JZ     READ_CAS    ;ДА
        cmp    AH,3CH      ;РАБОТА С ПЗУ
        JNZ    MX1         ;НЕТ
        PUSH   DS
        MOV    AX,KARTR    ;(DS) - ОБЛАСТЬ КАРТРИДЖА
        MOV    BX,0
        MOV    DS,AX
;ПРОВЕРКА КЛЮЧА (ПЕРВЫЙ БАЙТ = E9Н)
        MOV    AL,BYTE PTR DS:[BX]
        CMP    AL,0E9H
        POP    DS
        JNZ    MX0          ;КЛЮЧА НЕТ
	MOV	AX,2
	INT	10H
        JMP     KARTRIDJ
;---------------------------------------------
;      Загрузка файла с кассеты
;---------------------------------------------
READ_CAS:
        ASSUME DS:DATA
        MOV    AX,DATA
        MOV    DS,AX
	mov    AX,LOAD_ADDR   ;УСТАНОВКА ОБЛАСТИ ЗАГРУЗКИ
        mov    es,ax
        CALL   READ_NAME   ;ПРИЕМ ИМЕНИ ФАЙЛА
        LEA    si,SW5
        MOV    cx,LSW5
          CALL    P_MSG       ;ПОДГОТОВИТЬ МАГНИТОФОН
RC4:      CALL    READ_CHAR   ;ПРИЕМ ОТВЕТА
          CMP     AL,13       ;ГОТОВ?
          JNZ     RC4         ;НЕТ
          PUSH    ES
          LEA     BX,BUFFERM
          MOV     AH,4
          INT     15H
          JC      RCERROR
          lea     si,sX12
          MOV     cx,LSX12
          call    P_MSG      ;запускать?
          call    read_char
          call    wr_1_char
          cmp     al,'N'
          jz      RC5
          cmp     al,'n'
          jz      RC5
          cmp     al,'Н'
	  jz	  rc5
	  cmp	  al,'н'
          jz      rc5
          MOV     AX,0
          PUSH    AX
          DB      0CBH         ;(RETF) ПЕРЕДАТЬ УПРАВЛЕНИЕ ЗАГРУЖЕННОЙ ПРОГРАММЕ
RC5:      JMP     M0           ;возврат в монитор
rcerror:
          lea     si,sX2
          mov     cx,LSX2   ;---------------------
          call    P_MSG
          call    read_char
	  JMP	  MX0
;        П/П ВВОДА ИМЕНИ ФАЙЛА
;---------------------------------------------
READ_NAME:
       LEA   si,SW2
       MOV   cx,LSW2
       CALL  P_MSG
       MOV   SI,0
RN1:   MOV   BUFFERM[SI],' '
       INC   SI
       CMP   SI,8
       JNZ   RN1
       MOV   SI,0
RN2:   CALL  READ_CHAR
       CMP   AL,13
       JZ    RN3
       CMP   AL,1BH
       JZ    READ_NAME
       CMP   AL,20H
       JB    RN2
       CALL  WR_1_CHAR
       MOV   BUFFERM[SI],AL
       INC   SI
       CMP   SI,8
       JNZ   RN2
RN3:   RET
wr_1_char    proc
        push   cx
        PUSH   BX
        PUSH   DX
        MOV    AH,14
        INT    10H
        POP    DX
        POP    BX
        pop    cx
        ret
wr_1_char    endp
;Чтение введенного символа
read_char    proc   near
        mov    ah,0
        int    16h
r_ret:  ret
read_char    endp
;Сообщения монитора
s0:     db    13,10,0F6H,' "ПОИСК" ',0F7H,13,10
        db    13,10
s01:    db    'F1 - Работа с кассетой',13,10,13,10
s03:    db    'F2 - Работа с ПЗУ',13,10,13,10
S05:    DB    'Выберите РЕЖИМ'
LS05	= $ - OFFSET S05
LS0     = $ - OFFSET S0
sX12:   db    13,10,'Запускать?'
LSX12	= $ - OFFSET SX12
sX2:    db    13,10,'Ошибка чтения ***',13,10
LSX2	= $ - OFFSET SX2
SW2:    DB    13,10,'Введите имя файла:'
LSW2	= $ - OFFSET SW2
SW5:    DB    13,10,'Вкл.  магнитофон, нажмите (BK)'
LSW5	= $ - OFFSET SW5
fn:     db    13,10,'Файл найден!',13,10
LFN	= $ - OFFSET FN
INCLUDE ALTTAB.ASM    ; Таблица альтернативных кодов 128 - 256
; Таблица альтернативных кодов 128 - 256
ALTC:   DB      007H,00FH,01BH,033H,07FH,063H,063H,000H ;А
        DB      07EH,060H,060H,07EH,063H,063H,07EH,000H ;Б
        DB      07CH,066H,066H,07EH,063H,063H,07EH,000H ;В
        DB      07EH,060H,060H,060H,060H,060H,060H,000H ;Г
        DB      03EH,036H,036H,036H,036H,036H,07FH,063H ;Д
        DB      07EH,060H,060H,07CH,060H,060H,07FH,000H ;Е
        DB      06BH,06BH,03EH,008H,03EH,06BH,06BH,000H ;Ж
        DB      01EH,033H,003H,01EH,003H,063H,03EH,000H ;З
        DB      063H,063H,067H,06FH,07BH,073H,063H,000H ;И
        DB      06BH,063H,067H,06FH,07BH,073H,063H,000H ;Й
        DB      063H,066H,06CH,07CH,066H,063H,063H,000H ;К
        DB      003H,007H,00FH,01BH,033H,063H,063H,000H ;Л
        DB      063H,077H,07FH,06BH,063H,063H,063H,000H ;М
        DB      063H,063H,063H,07FH,063H,063H,063H,000H ;Н
        DB      03EH,063H,063H,063H,063H,063H,03EH,000H ;О
        DB      07FH,063H,063H,063H,063H,063H,063H,000H ;П
        DB      07EH,063H,063H,07EH,060H,060H,060H,000H ;Р
        DB      03EH,063H,060H,060H,060H,063H,03EH,000H ;С
        DB      07EH,018H,018H,018H,018H,018H,018H,000H ;Т
        DB      063H,063H,063H,03FH,003H,063H,03EH,000H ;У
        DB      008H,03EH,06BH,06BH,06BH,03EH,008H,000H ;Ф
        DB      063H,036H,01CH,008H,01CH,036H,063H,000H ;Х
        DB      066H,066H,066H,066H,066H,066H,07FH,003H ;Ц
        DB      063H,063H,063H,03FH,003H,003H,003H,000H ;Ч
        DB      06BH,06BH,06BH,06BH,06BH,06BH,07FH,000H ;Ш
        DB      06BH,06BH,06BH,06BH,06BH,06BH,07FH,001H ;Щ
        DB      078H,018H,018H,01EH,01BH,01BH,01EH,000H ;Ъ
        DB      061H,061H,061H,079H,06DH,06DH,079H,000H ;Ы
        DB      060H,060H,060H,07EH,063H,063H,07EH,000H ;Ь
        DB      03EH,063H,003H,00FH,003H,063H,03EH,000H ;Э
        DB      04EH,05BH,05BH,07BH,05BH,05BH,04EH,000H ;Ю
        DB      03FH,063H,063H,03FH,01BH,033H,063H,000H ;Я
        DB      000H,000H,03CH,006H,03EH,066H,03FH,000H ;а
        DB      002H,03CH,060H,07CH,066H,066H,03CH,000H ;б
        DB      000H,000H,07CH,066H,07CH,063H,07EH,000H ;в
        DB      000H,000H,07EH,060H,060H,060H,060H,000H ;г
        DB      000H,000H,03EH,036H,036H,036H,07FH,063H ;д
        DB      000H,000H,03CH,066H,07EH,060H,03EH,000H ;е
        DB      000H,000H,06BH,03EH,008H,03EH,06BH,000H ;ж
        DB      000H,000H,03CH,066H,00CH,066H,03CH,000H ;з
        DB      000H,000H,066H,066H,06EH,076H,066H,000H ;и
        DB      018H,000H,066H,066H,06EH,076H,066H,000H ;й
        DB      000H,000H,066H,06CH,078H,066H,066H,000H ;к
        DB      000H,000H,007H,00FH,01BH,033H,063H,000H ;л
        DB      000H,000H,063H,077H,06BH,063H,063H,000H ;м
        DB      000H,000H,066H,066H,07EH,066H,066H,000H ;н
        DB      000H,000H,03CH,066H,066H,066H,03CH,000H ;о
        DB      000H,000H,07EH,066H,066H,066H,066H,000H ;п
        DB      022H,088H,022H,088H,022H,088H,022H,088H ;░
        DB      055H,0AAH,055H,0AAH,055H,0AAH,055H,0AAH ;▒
        DB      0DBH,077H,0DBH,0EEH,0DBH,077H,0DBH,0EEH ;▓
        DB      018H,018H,018H,018H,018H,018H,018H,018H ;│
        DB      010H,010H,010H,010H,0F0H,010H,010H,010H ;┤
        DB      010H,010H,0F0H,010H,0F0H,010H,010H,010H ;╡
        DB      014H,014H,014H,014H,0F4H,014H,014H,014H ;╢
        DB      000H,000H,000H,000H,0FCH,014H,014H,014H ;╖
        DB      000H,000H,0F0H,010H,0F0H,010H,010H,010H ;╕
        DB      014H,014H,0F4H,004H,0F4H,014H,014H,014H ;╣
        DB      036H,036H,036H,036H,036H,036H,036H,036H ;║
        DB      000H,000H,0FEH,006H,0F6H,036H,036H,036H ;╗
        DB      036H,036H,0F6H,006H,0FEH,000H,000H,000H ;╝
        DB      014H,014H,014H,014H,0FCH,000H,000H,000H ;╜
        DB      010H,010H,0F0H,010H,0F0H,000H,000H,000H ;╛
        DB      000H,000H,000H,000H,0F8H,018H,018H,018H ;┐
        DB      018H,018H,018H,018H,01FH,000H,000H,000H ;└
        DB      018H,018H,018H,018H,0FFH,000H,000H,000H ;┴
        DB      000H,000H,000H,000H,0FFH,018H,018H,018H ;┬
        DB      018H,018H,018H,018H,01FH,018H,018H,018H ;├
        DB      000H,000H,000H,000H,0FFH,000H,000H,000H ;─
        DB      018H,018H,018H,018H,0FFH,018H,018H,018H ;┼
        DB      010H,010H,01FH,010H,01FH,010H,010H,010H ;╞
        DB      014H,014H,014H,014H,017H,014H,014H,014H ;╟
        DB      036H,036H,037H,030H,03FH,000H,000H,000H ;╚
        DB      000H,000H,03FH,030H,037H,036H,036H,036H ;╔
        DB      036H,036H,0F7H,000H,0FFH,000H,000H,000H ;╩
        DB      000H,000H,0FFH,000H,0F7H,036H,036H,036H ;╦
        DB      036H,036H,037H,030H,037H,036H,036H,036H ;╠
        DB      000H,000H,0FFH,000H,0FFH,000H,000H,000H ;═
        DB      036H,036H,0F7H,000H,0F7H,036H,036H,036H ;╬
        DB      010H,010H,0FFH,000H,0FFH,000H,000H,000H ;╧
        DB      014H,014H,014H,014H,0FFH,000H,000H,000H ;╨
        DB      000H,000H,0FFH,000H,0FFH,010H,010H,010H ;╤
        DB      000H,000H,000H,000H,0FFH,014H,014H,014H ;╥
        DB      014H,014H,014H,014H,01FH,000H,000H,000H ;╙
        DB      010H,010H,01FH,010H,01FH,000H,000H,000H ;╘
        DB      000H,000H,01FH,010H,01FH,010H,010H,010H ;╒
        DB      000H,000H,000H,000H,01FH,014H,014H,014H ;╓
        DB      014H,014H,014H,014H,0FFH,014H,014H,014H ;╫
        DB      010H,010H,0FFH,010H,0FFH,010H,010H,010H ;╪
        DB      018H,018H,018H,018H,0F8H,000H,000H,000H ;┘
        DB      000H,000H,000H,000H,01FH,018H,018H,018H ;┌
        DB      0FFH,0FFH,0FFH,0FFH,0FFH,0FFH,0FFH,0FFH ;█
        DB      000H,000H,000H,000H,0FFH,0FFH,0FFH,0FFH ;▄
        DB      0F0H,0F0H,0F0H,0F0H,0F0H,0F0H,0F0H,0F0H ;▌
        DB      00FH,00FH,00FH,00FH,00FH,00FH,00FH,00FH ;▐
        DB      0FFH,0FFH,0FFH,0FFH,000H,000H,000H,000H ;▀
        DB      000H,000H,07CH,066H,066H,07CH,060H,060H ;р
        DB      000H,000H,03CH,066H,060H,066H,03CH,000H ;с
        DB      000H,000H,07EH,018H,018H,018H,018H,000H ;т
        DB      000H,000H,066H,066H,03EH,006H,066H,03CH ;у
        DB      000H,008H,03EH,06BH,06BH,03EH,008H,008H ;ф
        DB      000H,000H,063H,036H,01CH,036H,063H,000H ;х
        DB      000H,000H,066H,066H,066H,066H,07FH,003H ;ц
        DB      000H,000H,066H,066H,03EH,006H,006H,000H ;ч
        DB      000H,000H,06BH,06BH,06BH,06BH,07FH,000H ;ш
        DB      000H,000H,06BH,06BH,06BH,06BH,07FH,001H ;щ
        DB      000H,000H,078H,018H,01EH,01BH,01EH,000H ;ъ
        DB      000H,000H,061H,061H,079H,06DH,079H,000H ;ы
        DB      000H,000H,060H,060H,07CH,066H,07CH,000H ;ь
        DB      000H,000H,03EH,063H,00FH,063H,03EH,000H ;э
        DB      000H,000H,04EH,05BH,07BH,05BH,04EH,000H ;ю
        DB      000H,000H,03EH,066H,03EH,036H,066H,000H ;я
        DB      014H,07EH,060H,07CH,060H,060H,07FH,000H ;Ё
        DB      014H,000H,03CH,066H,07EH,060H,03EH,000H ;ё
        DB      000H,000H,000H,000H,001H,003H,006H,00CH ;Є
        DB      000H,000H,000H,000H,060H,030H,018H,00CH ;є
        DB      00CH,018H,030H,060H,000H,000H,000H,000H ;Ї
        DB      00CH,006H,003H,001H,000H,000H,000H,000H ;ї
        DB      000H,006H,003H,07FH,003H,006H,000H,000H ;Ў
        DB      000H,018H,030H,07FH,030H,018H,000H,000H ;ў
        DB      00CH,00CH,00CH,00CH,03FH,01EH,00CH,000H ;°
        DB      000H,00CH,01EH,03FH,00CH,00CH,00CH,00CH ;∙
        DB      00CH,00CH,000H,03FH,000H,00CH,00CH,000H ;·
        DB      018H,018H,07EH,018H,018H,000H,07EH,000H ;√
        DB      045H,064H,054H,04CH,044H,044H,044H,000H ;№
        DB      000H,061H,01EH,033H,033H,01EH,061H,000H ;¤
        DB      000H,000H,01EH,01EH,01EH,01EH,000H,000H ;■
        DB      000H,000H,000H,000H,000H,000H,000H,000H ;
        ORG 0E6F2H
INCLUDE INT19.ASM     ;INT19 - загрузка системы
;---INT 19------------------------------------------------
;Программа загрузки системы
;     Если устройство А - дискетта 5 1/4", то загрузка возможна
;     Дорожка 0, сектор 1считываются по адресу BOOT(0:7C00)
;     и на него передается управление.
;     Если дискетта отсутствует или произошла аппаратная ошибка,
;     то управление передается в точку CASSETE-BASIC.
;
; Если загрузка идет с дискетты, то бит 0=1 для порта 60H
;----------------------------------------------------------
        ASSUME CS:CODE,DS:DATA
BOOT_STRAP     PROC    NEAR
      STI                      ;Разрешить прерывание
      MOV      AX,DATA         ;Установка аресации данных
      MOV      DS,AX
      MOV      AX,EQUIP_FLAG   ;Получить состояние переключателей
      TEST     AL,1H           ;Выделить состояние переключателя IPL
      JZ       H3              ;Перейти на вход CASSETTE BASIC
;-------------Система загружается с дискетты
                             ;CX-счетчик повторов
      MOV       AX,0
      MOV       DS,AX
      MOV       CX,4         ;Установить счетчик повторов
H1:
      PUSH      CX           ;Сохранить счетчик повторов
      MOV       DX,0         ;Устройство 0, головка 0
      MOV       AH,0         ;Сброс НГМД
      INT       13H          ;Ввод/вывод дискетты
      JC        H2           ;Если ошибка, повторить
      MOV       AH,2         ;Чтение одного сектора
      MOV       BX,0         ;По фдресу BOOT
      MOV       ES,BX
      MOV       BX,OFFSET BOOT_LOCN
      MOV       DX,0         ;Устройство 0, головка 0
      MOV       CX,1         ;Сектор 1, дорожка 0
      MOV       AL,1         ;Считывание сектора
      INT       13H
H2:   POP       CX           ;Восстановить счетчик повторов
      JNC       H4           ;Установить CF при ошибке чтения
      LOOP      H1           ;На повтор
;---------Загрузка с дискетты невозможна
H3:
      IRET
;---------Загрузка завершилась успешно
H4:
      JMP       BOOT_LOCN    ;Передача управления системе
BOOT_STRAP   ENDP
INCLUDE INT10_B2.ASM    ;Write_TTY и световое перо
;-----------------------------------------------------
; WRITE_TTY
;  Эта программа обеспечивает работу с ВИДЕО в режиме телетайпа. Выводимый
;  символ записывается в текущую позицию курсора, и курсор перемещаетя в
;  следующую позицию. После записи символа в последнюю позицию строки
;  выполняется автоматический переход на новую строку. Если активная страница
;  экрана заполнена, выполняется перемещение экрана на одну строку вверх
;  (свертка). Освободившаяся строка заполняется цветом атрибута из последней
;  позиции курсора перед сверткой (в символьном режиме). В графическом режиме
;  используется цвет 0.
;Вход:
;  (AH) - текущий режим экрана
;  (AL) - выодимый символ
;  (BL) - цвет переднего плана для символа в графическом режиме
;Замечание: возврат на шаг, возврат каретки, перевод строки и звонок
;           отрабатываются как команды.
;Выход:
;  Все регистры сохраняются
;---------------------------------------------------------------------------
        ASSUME  CS:CODE,DS:DATA
WRITE_TTY       PROC   NEAR
        PUSH    AX            ;Сохранить регистры
        PUSH    AX            ;Сохранить символ для записи
        MOV     BH,ACTIVE_PAGE ;Получить текущую активную страницу
        MOV     AH,3
        INT     INT_VIDEO     ;Прочесть значение текущей позиции курсора
        POP     AX            ;Восстановить символ
;
;------ DX содержит текущую позицию курсора
;
        CMP     AL,8          ;Это возврат на шаг?
        JE      U8            ;Да, переход
        CMP     AL,0DH        ;Это возврат каретки?
        JE      U9            ;Да, переход
        CMP     AL,0AH        ;Это перевод строки?
        JE      U10           ;Да, переход
        CMP     AL,07H        ;Это звонок?
        JE      U11           ;Да, переход
;
;------ Запись символа на экран
;
        MOV     AH,10         ;Запись только символа
        MOV     CX,1          ;Только один символ
        INT     INT_VIDEO     ;Запись символа
;
;------ Позиция курсора для следующего символа
;
        INC     DL
        CMP     DL,BYTE PTR CRT_COLS   ;Проверка переполнения колонки
        JNZ     U7            ;Установить курсор
        MOV     DL,0          ;Колонка для курсора
        CMP     DH,24
        JNZ     U6            ;Установить курсор
;
;------ Требуется свертка (прокрутка)
U1:
        MOV     AH,2
        MOV     BH,ACTIVE_PAGE ;Получить текущую активную страницу
        INT     INT_VIDEO      ;Установить курсор
;
;------ Определение значения заполнителя во время свертки
;
        CMP     CRT_MODE,4
        JC      U2            ;Считывание курсора
        MOV     BH,0          ;Заполнение фона
        JMP SHORT  U3         ;Установить прокрутку
U2:                           ;Считывание курсора
        MOV     BH,ACTIVE_PAGE ;Получить текущую активную страницу
        MOV     AH,8
        INT     INT_VIDEO     ;Прочесть символ/атрибут текущего курсора
        MOV     BH,AH         ;Заполнить в BH
U3:                           ;Прокрутка
        MOV     AX,601H       ;Прокрутка одной строки
        MOV     CX,0          ;Верхний левый угол
        MOV     DH,24         ;Нижняя правая строка
        MOV     DL,BYTE PTR CRT_COLS   ;Нижняя правая колонка
        DEC     DL
U4:
        INT     INT_VIDEO     ;Прокрутка экрана
U5:                           ;Возврат из TTY
        POP     AX            ;Восстановить символ
        JMP     VIDEO_RETURN  ;Возврат
U6:                           ;Установить курсор
        INC     DH            ;Следующая строка
U7:                           ;Установить курсор
        MOV     BH,ACTIVE_PAGE ;Получить текущую активную страницу
        MOV     AH,2
        JMP     U4            ;Установить новый курсор
;
;------ Определен возврат на шаг
U8:
        CMP     DL,0          ;Уже конец строки?
        JE      U7            ;Установить  курсор
        DEC     DL            ;Нет- вернуть его на шаг
        JMP     U7            ;Установить  курсор
;
;------ Определен возврат каретки
U9:
        MOV     DL,0          ;Передвинуть на первую колонку
        JMP     U7            ;Установить  курсор
;
;------ Определен перевод строки
U10:
        CMP     DH,24         ;Последняя строка экрана?
        JNE     U6            ;Да, прокрутка экрана
        JMP     U1            ;Нет, установить курсор снова
;
;------ Определен звонок
U11:
        MOV     BX,0602H      ;Установить счетчик для сигнала
        CALL    BEEP          ;Включить звук BELL
        JMP     U5            ;Возврат из TTY
WRITE_TTY       ENDP
;---------------------------------------------------------------------------
;LIGHT PEN
;       В БМ ЭВМ световое перо отсутствует, и режим считывания положения
;       светового пера не поддерживается.
;----------------------------------------------------------------------------
        ASSUME  CS:CODE,DS:DATA
READ_LPEN       PROC   NEAR
        MOV     AH,0
        JMP     VIDEO_RETURN     ;Нет светового пера, возврат
READ_LPEN       ENDP
INCLUDE TBL_KBDP.ASM
;----------------------------------------------------------------------------
;   таблица для комплекса "ПОИСК"
;----------------------------------------------------------------------------
;  12.02.88   Батьковский  М.Б.
;----------------------------------------------------------------------------
;          таблица описания матрицы клавиатуры (12*8)
;      отрицательный код (-1..-0FH) --  ссылка на строку таблицы LN_KEY1
;- колонки--1----2----3----4----5----6----7----8----9----10---11--12-
LINE1  DB  55H, 4CH, 00H, 56H, 35H, 1CH, 48H, 50H,-0CH, 18H,-0BH,57H
LINE2  DB -0FH, 4BH, 52H, 41H,-0DH, 0EH, 47H, 4FH, -2H, -3H, 19H,54H
LINE3  DB  21H, 49H, 51H, 31H, 20H, 1FH, 2CH, 00H, 32H, 25H, 30H,22H
LINE4  DB  3DH, 00H, 00H, 40H, 3CH, 3BH, -1H, 01H, -9H,-0AH, 3FH,3EH
LINE5  DB  12H, 00H, 9DH, 23H, 11H, 10H, 1EH, 3AH, 24H, 17H, 14H,13H
LINE6  DB 0AAH, 37H,0B8H, 2EH, 2DH,0DCH,0DBH,0AAH, 58H, 59H, 2FH,39H
LINE7  DB  00H, 45H, 53H, 00H, 27H, 44H, 4EH, 4DH, 26H, 42H, 5AH,43H
LINE8  DB -06H, 4AH, 0FH, 15H, -7H, 46H, -4H, 2BH, 00H, 16H, -5H,-8H
;----------------------------------------------------------------------------
;  03.02.88 - х-54,ъ-55,ж-56,э-57,ю-58,б-59,е-5A/  новые скан коды
         ORG    0E82DH
DB       8FH          ;Это ПОИСК
INCLUDE INT16N.ASM
;--------------------------------------------------------------
;
;                К Л А В И А Т У Р А
;
;___int 16_________________
;
;   Программа поддержки клавиатуры
;
;   Эта программа считывает в регистр
; AX код сканирования клавиши и код
; ASCII из буфера клавиатуры.
;
;   Программа выполняет три функции, код
; которых задается в регистре AH:
;
;    AH=0 - считать следующий символ
;            из буфера.При выходе код
;            сканирования в AH,код
;            ASCII в AL.
;
;   AH=1 - установить ZF, если код
;            ASCII прочитан:
;            ZF=0 - буфер заполнен,
;            ZF=1 - буфер пустой.
;         При выходе в AX помещено содержимое вершины буфера клавиатуры.
;
;   AH=2 - возврат текущего состояния в регистр AL
;          из постоянно распределенной области памяти с
;          адресом 00417H.
;
;   При выполнении программ клавиатуры используются флажки,
; которые устанавливаются в постоянно распределенной области
; памяти по адресам 00417H и 00418H и имеют значение:
;   00417H
;         0 - правое переключение регистра SHIFT;
;         1 - левое переключение регистра  SHIFT;
;         2 - УПР  (CTRL);
;         3 - ДОП  (ALT) ;
;         4 - ФСД  (ScrollLock) ;
;         5 - ЦИФ  (NumLock);
;         6 - ФПБ  (CapsLock) ;
;         7 - ВСТ  (Ins) ;
;   00418H
;         0 - состояние клавиши ЛАТ между нажатием и отжатием (не использ);
;         1 - ЛАТ (не использ);
;         2 - Р/Л (не использ);
;         3 - пауза (HOLD_STATE);
;         4 - ФСД;
;         5 - ЦИФ;
;         6 - ФПБ;
;         7 - ВСТ.
;
;   Флажки, соответствующие разрядам 4-7 постоянно распределенной
; области памяти с адресом 00417H, устанавливаются по нажатию
; клавиш ВСТ, ФПБ, ЦИФ, ФСД и сохраняют свои значения до сле-
; дующего нажатия соответствующей клавиши.
; Одноименные флажки, соответствующие разрядам 4-7 постоянно
; распределенной области памяти с адресом 00418H, и флажки
; ДОП, УПР, левое переключение регистра, правое переключение
; регистра, Р/Л устанавливаются по нажатию клавиш и сбрасываются
; по отжатию.
;
;--------------------------------------------------------------.
        ASSUME CS:CODE,DS:DATA
KEYBOARD_IO     PROC   FAR
        STI                   ;разрешение прерывний
        PUSH    DS
        PUSH    BX
        MOV     BX,DATA
        MOV     DS,BX         ;установка указателя на сегмент данных
	MOV	BX,BUFFER_HEAD;Указатель вершины буфера ввода INT9
        OR      AH,AH         ;AH=0
        JZ      K1            ;чтение символа ASCII
        DEC     AH            ;AH=1
        JZ      K2            ;опрос состояния буфера
        DEC     AH            ;AH=2
;        JNZ     KBRET
        MOV	AL,KB_FLAG    ;SHIFT_STATUS
KBRET:  POP     BX
        POP     DS
        IRET
;------ Чтение кода символа ASCII по ожиданию
K1:
	MOV	AH,1
	INT	16H	      ;Рекурсивный опрос клавиатуры
        JZ      K1            ;если нет готовности
        CALL    K4            ;наращивание указателя чтения буфера
        MOV     BUFFER_HEAD,BX ;запись нового значения указателя
	JMP	KBRET	      ;Выход
;-------ASCII STATUS
K2:
        CLI                   ;запрет прерываний
        CMP     BX,BUFFER_TAIL ;если указатели равны (ZF=1), то буфер пуст
        MOV     AX,[BX]
        STI                   ;разрешение прерываний
        POP     BX
        POP     DS
        RET     2             ;возврат без сохранения флагов
KEYBOARD_IO     ENDP
INCLUDE TBL_INT9.ASM
;-------------------------------------------------------------
;             Т А Б Л И Ц Ы   Д Л Я   I N T 9
;-------------------------------------------------------------
;      таблица соответствия русских символов скан-кодам
LR      LABEL    BYTE
        DB       'ЙЦУКЕНГШ'
        DB       'ЩЗФЫВАПР'
        DB       'ОЛДЯЧСМИ'
        DB       'ТЬХЪЖЭЮБ'
        DB       0f0h           ;
;--------------------------
;------- скан-коды управляющих клавиш
K6      LABEL   BYTE
        DB      RIGHT_KEY
        DB      LEFT_KEY
        DB      CTL_KEY
        DB      ALT_KEY
        DB      SCROLL_KEY
        DB      NUM_KEY
        DB      CAPS_KEY
        DB      INS_KEY
K6L     EQU     $-K6
;------- перекодировка для CTRL, скан-коды 00-??
K8      DB      01,55  ;границы интервала
        DB      27, -1,  0, -1, -1, -1, 30, -1
        DB      -1, -1, -1, 31, -1,127, -1, 17
        DB      23,  5, 18, 20, 25, 21,  9, 15
        DB      16, 27, 29, 10, -1,  1, 19,  4
        DB       6,  7,  8, 10, 11, 12, -1, -1
        DB      -1, -1, 28, 26, 24,  3, 22,  2
        DB      14, 13, -1, -1, -1, -1, 114+80H
;--------------------------
;------- перекодировка для CTRL, дополнительная клавиатура
;            ( скан-коды ??-?? )
K9      LABEL   BYTE
        DB      71,81 ;границы интервала
        DB      119+80H,-1,     -2,-1,115+80H,-1
        DB      116+80H,-1,117+80H,-1,118+80H
;-------- перекодировка для верхнего регистра, скан-коды 00-??  (без SHIFT)
K10     LABEL   BYTE
        DB      1,55
        DB      01BH,'1234567890-=',08H,09H
        DB      'qwertyuiop[]',0DH,-1,'asdfghjkl;',027H
        DB      60H,-1,5CH,'zxcvbnm,./',-1,'*'
;--------------------------
;-------- перекодировка для нижнего регистра, скан-коды 00-??   (c SHIFT)
K11     LABEL   BYTE
        DB      1,55  ;границы интервала
        DB      27,'!@#$',37,05EH,'&*()_+',08H,15+80H
        DB      'qwertyuiop',7BH,7DH,0DH,-1,'asdfghjkl:"'
        DB      07EH,-1,7CH,'zxcvbnm<>?',-1,114+80H
;--------------------------
;-------перекодировка символов дополнительной клавивтуры
;       (цифровой режим, скан-коды ??-??)
K14     LABEL   BYTE
        DB      71,83 ;границы интервала
        DB      '789-456+1230.'
;-------перекодировка символов дополнительной клавивтуры
;       (управление курсором, скан-коды ??-??)
K15     LABEL   BYTE
        DB      71,83  ;границы интервала
        DB      71+80H, 72+80H, 73+80H, '-',    75+80H,    -1, 77+80H
        DB      '+',     79+80H, 80+80H, 81+80H, 82+80H, 83+80H
;--------------------------
;------ таблица допустимых интервалов скан-кодов для ALT и RUS
KT_ALT  DB      2, 13  ; 1..+
KT_RUS0 DB     16, 25  ; Q..P
        DB     30, 38  ; A..L
        DB     44, 50  ; Z..M
KT_RUS  DB     84, 90  ; X..Б,Е с двумя точками с верху
         ORG    0E987H
INCLUDE INT9.ASM
;---------------------------------------------------------------
;
;              К Л А В И А Т У Р А       I N T 9
;
;---------------------------------------------------------------
;         Батьковский М.                    06.01.89
;---------------------------------------------------------------
;    Программа обработки прерывания клавиатуры
;
; Программа считывает код сканирования клавиши в регистр AL.
; Единичное состояние разряда 7 в коде сканирования означает,
; что клавиша отжата.
;   В результате выполнения программы в регистре AX формируется
; слово, старший байт которого (AH) содержит код сканирования,
; а младший (AL) - код ASCII. Эта информация помещается в буфер
; клавиатуры. После заполнения буфера подается звуковой сигнал.
; Модифицируются байты 0:417 и 0:418
;  Проверяются и отрабатываются ситуации:
;        - SHIFT + PrintScreen
;        - CTRL  + NumLock
;        - ALT   + CTRL + DEL
;-------------------------------------------------------------
;----------------------- I N T 9 -----------------------------------
KB_INT  PROC    FAR
        STI                   ;разрешить прерывания
        PUSH    AX
        PUSH    BX
        PUSH    CX
        PUSH    DX
        PUSH    SI
        PUSH    DI
        PUSH    DS
        PUSH    ES
        CLD                   ;направление вперед
;------ Установка регистров
        PUSH    CS
        POP     ES            ;ES=CS
        MOV     AX,DATA
        MOV     DS,AX         ;указатель на сегмент джанных
        IN      AL,KB_DATA    ;чтение скан_кода
        MOV     AH,AL         ; (AH) - скан-код
;        CALL    DISP_HEX     ;  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        AND     AL,7FH       ;сброс бита нажата-отжата
        MOV     SI,OFFSET ALT_INPUT ; указатель на накопитель кода символа
        MOV     DX,word ptr KB_FLAG    ; состояние управляющих клавиш:
                              ;           DL - KB_FLAG,  DH - KB_FLAG1
;------ Проверка на скан_код управляющей клавиши
K16:
        MOV     DI,OFFSET K6   ;таблица SHIFT KEY
        MOV     CX,K6L         ;длина таблицы
        REPNE   SCASB          ;поиск
	JNE	K25	       ;не упрравляющая клавиша
;------ Управляющая клавиша
K17:                           ;(CL) - количество сдвигов
        MOV     BH,80H
        SHR     BH,CL          ;(BH) - маска клавиши для KB_FLAG
        CMP     AH,AL          ;проверка на отжатие
        JNZ     K23            ;если клавиша отжата
;------ Управляющая клавиша нажата
        CMP     BH,SCROLL_SHIFT
        JAE     K18            ;если клавиша из множества
                               ; { Scroll,Num,Caps,Ins }
;------ Нажата клавиша из множества  { Alt,Ctl,ShiftLeft,ShiftRigth }
        OR      DL,BH           ;установка флагов в KB_FLAG
        JMP     SHORT K26       ;к выходу из прерывания
;------ Нажата клавиша из множества  { Scroll,Num,Caps,Ins }
K18:
        TEST    DL,CTL_SHIFT+ALT_SHIFT;
        JNZ     K25                ; обработка ка обычной клавиши
        CMP     AL,INS_KEY         ; проверка на код INS
        JNZ     K22
;------ Нажата клавиша INS
K19:    CALL    CALC_NUMKEY_SHIFT  ; определение статуса дополн. клавиатуры
        JZ      K22  ; дополнительная клавиатура в управляющем состоянии
        ; дополнительная клавиатура в цифровом состоянии
        MOV     AL,'0'             ; запись в буфер цифры '0'
        JMP     SHORT K23E
;------ Изменение KB_FLAG для клавиши из множества  { Scroll,Num,Caps,Ins }
K22:
        TEST    BH,DH              ; повторная генерация при одном нажатии?
        JNZ     K26                ; если генерация
        OR      DH,BH              ; установка бита - клавиша нажата
        XOR     DL,BH              ; инверсия режима
        CMP     AL,INS_KEY         ; проверка INSERT KEY
        JNE     K26                ; если нет
        JMP     KW0_BUF            ; запись в буфер кода клавиши INS
;------ Управляющая клавиша отжата
K23:
        CMP     BH,SCROLL_SHIFT
        JAE     K24
;------ Отжата клавиша из множества  { Alt,Ctl,ShiftLeft,ShiftRigth }
        NOT     BH                 ; инвертирование маски
        AND     DL,BH              ; cброс бита признака в KB_FLAG
        CMP     AH,ALT_KEY+80H     ; отжата клавиша ALT
        JNE     K26                ; к выходу из прерывния
;------ Отжата клавиша ALT, запись символа в буфер
;       ( символ был введен в цифровом виде )
        MOV     AL,[SI]
        SUB     AH,AH              ; скан_код=0
        MOV     [SI],AH            ; сброс кода-накопителя
        OR      AL,AL              ; код символа = 0 ?
        JE      K26                ; к выходу из прерывания
K23E:   JMP     KW_BUF             ; запись введеного кода символа в буфер
;------ Отжата клавиша из множества  { Scroll,Num,Caps,Ins }
K24:
        NOT     BH                 ; инвертирование маски
        AND     DH,BH              ; сброс бита-признака в KB_FLAG1
        JMP     SHORT K26          ; к выходу из прерывания
;------ СКАН-КОД ОБЫЧНОЙ КЛАВИШИ -----------------------------------------
K25:
        CMP     AH,AL             ; проверка бита нажатия/отжатия
        JNE     K26A               ; клавиша отжата
        TEST    DH,HOLD_STATE      ; проверка режима-пауза
        JZ      K28                ; режим пауза отсутствует
        ;режим_пауза
        CMP     AL,NUM_KEY
        JE      K26A               ; если режим пауза продолжается
        AND     DH,NOT HOLD_STATE  ; сброс режима пауза
;------ ВОЗВРАТ ИЗ ПРЕРЫВАНИЯ
K26:
        MOV     word ptr KB_FLAG,DX      ; сохранение флагов клавиш управления
K26A:
        MOV     SCAN_CODE_OLD,AH; запоминание скан-кода
        CLI                     ; запрет прерываний
        MOV     AL,EOI          ; команда - конец прерывания
        OUT     020H,AL         ; запись команды в контроллер прерываний
K27:
        POP     ES
        POP     DS
        POP     DI
        POP     SI
        POP     DX
        POP     CX
        POP     BX
        POP     AX
        IRET
;--------------------------------------------------------------
;           ПОЛУЧЕН СКАН-КОД ОБЫЧНОЙ КЛАВИШИ
;  ( перекодировка скан-кодов в альтернативную кодировку )
;--------------------------------------------------------------
K28:    ;проверка на дополнительный скан-код
        CMP      SCAN_CODE_OLD,0E0H
        JZ       K65AA        ; если дополнительный скан-код
       ;проверка состояния управляющих клавиш
       TEST    DL,ALT_SHIFT+CTL_SHIFT
       JNZ     K70             ; если одна или две клавиши нажаты
;--------------------------------------------------------------
;    проверка и обслуживание символов без ALT и CTRL
;--------------------------------------------------------------
K60:   CMP     RUSS,TRUE
       JNE     K61
;----- SERVICE RUSS  -  проверка и обслуживание русских символов
SERVICE_RUSS:
        MOV     BX,offset KT_RUS0
        CALL    CONTR_TABLE
        JNZ     K61                     ; если не русская буква
SR2:
        MOV     BX,offset LR
        XLAT    CS:LR            ; получение кода символа
        ;
        MOV     CL,DL
        AND     CL,LEFT_SHIFT+RIGHT_SHIFT+CAPS_STATE
        JZ      SR3                     ; клавиши управления не нажаты
        CMP     CL,CAPS_STATE+1
        JC      SR4                     ; нажата только одна из клавиш
                                        ; SHIFT1 или CAPS_STATE
SR3:    ; маленькие буквы
        CMP     AL,0F0h
        JNZ     SR0
        INC     AL
        JMP     short SR4
SR0:    ADD     AL,20H
        CMP     AL,0B0H
        JC      SR4
        ADD     AL,30H
SR4:
        JMP     KW_BUF                  ; к записи в буфер
;-----------------------------------------------------------------
;----- Проверка и обслуживание не русских букв
K61:
       CMP      AL,71         ; дополнительная клавиатура ?
       JAE      K65           ; да
;----- ОСНОВНАЯ КЛАВИАТУРА
       TEST     DL,LEFT_SHIFT+RIGHT_SHIFT
       JNZ      K62
       ; основная клавиатура, клавиша SHIFT не нажата
       MOV      BX, offset K10
       CALL     CONTR_CODE
       SUB      CL,CL
       JMP      CONTR_FK
       ; основная клавиатура, клавиша SHIFT нажата
K62:
K63:   ; проверка SHIFT + PrintScreen
        CMP     AL,55           ; PRINT SCREEN KEY
        JNE     K64
        ; распечатка содержимого экрана
        MOV     AL,EOI
        OUT     020H,AL
        INT     5H              ;
        JMP     K27             ;  возврат без упр. контроллером прерываний
K64:    MOV     BX,offset K11
        CALL     CONTR_CODE
        MOV     CL,84-59
        JMP      CONTR_FK
;------ ДОПОЛНИТЕЛЬНАЯ КЛАВИАТУРА
K65:   CALL    CALC_NUMKEY_SHIFT  ; определение статуса дополн. клавиатуры
       MOV     BX, offset K14     ; доп. клавиатура в цифровом состоянии
       JNZ     K65A
K65AA: MOV     BX, offset K15     ; доп. клавиатура в управляющем состоянии
K65A:  CALL    CONTR_CODE
       JMP     K26
;-----------------------------------------------------------------
;----- нажата ALT и/или CTL --------------------------------------
;-----------------------------------------------------------------
K70:    TEST    DL,ALT_SHIFT
        JZ      K80            ; если ALT не нажата (нажата CTRL)
;----- проверка на комбинацию ALT + CTL + DEL
        CMP     AL,DEL_KEY
        JNE     K71             ; нет сброса
        MOV     RESET_FLAG,1234H ; установка параметров для функции сброса
        JMP     RESET           ; переход на сброс
;--------------------------------------------------------------
;    проверка и обслуживание  символов  с ALT
;--------------------------------------------------------------
K71:    ; проверка на цифры дополнительной клавиатуры
        CMP     AL,71
        JB      K72
        CMP     AL,82
        JA      K72
        MOV     BX,offset  K14+2-71
        XLAT    CS:K14
        SUB     AL,'0'
        JC      K72
        ;накопление кода символа
        XCHG    [SI],AL
        MOV     AH,10
        MUL     AH
        ADD     [SI],AL
        JMP     K26             ; выход из прерывания
 K72:
        MOV     AL,AH
        MOV      byte ptr[SI],0        ; сброс накопленного кода
        MOV     BX,offset KT_ALT ;A..Z, 0..9, -, +
        CALL    CONTR_TABLE     ; проверка и перекодировка скан кодов
        CMP     CL,84
        JZ      K72A            ; если вне диапазона KT_ALT
        CMP     CL,2            ; проверка на скан-коды 0..9-+
        JNZ     K72AA
        ADD     AH,118          ; если в диапазоне  0..9-+
K72AA:  JMP     KW0_BUF
K72A:   MOV     CL,104-59       ; приращение для получения псевдо скан-кода
        JMP     CONTR_FK        ; проверка на функциональные клавиши
;--------------------------------------------------------------
;    проверка и обслуживание  символов  с CTRL
;--------------------------------------------------------------
K80:
        MOV     BX, offset K8   ; основная клавиатура + CTRL
        CALL    CONTR_CODE
        MOV     BX, offset K9  ; дополнительная кдавиатура + CTRL
        CALL    CONTR_CODE
;       проверка исполнительных клавиш
        CMP     AL,SCROLL_KEY   ; проверка клавиши "BREAK"
        JNE     K81             ; не "BREAK"
        ;"BREAK"
        ;очистка буфера ввода
        MOV     AX,BUFFER_HEAD
        MOV     BUFFER_TAIL,AX
        MOV     BIOS_BREAK,80H  ; признак BREAK от клавиатуры
        INT     1BH             ; запуск прерывания обработки BREAK
        SUB     AX,AX           ; пустой символ
        JMP     KW_BUF          ; к записи в буфер
K81:
        CMP     AL,NUM_KEY      ; проверка клавиши "PAUSE"
        JNE     K82             ; NO-PAUSE
        ;"PAUSE"
        OR      KB_FLAG_1,HOLD_STATE ; установить флаг "PAUSE"
        MOV     W_SCAN,FALSE   ; разрешение повторного входа в SCANINT
        MOV     AL,EOI
        OUT     020H,AL
        ;
;        CMP     CRT_MODE,7     ; IS THIS BLACK AND WHITE CARD
;        JE      K81A           ; YES,NOTHING TO DO
;        MOV     DX,03D8H       ; PORT FOR COLOR CARD
;        MOV     AL,CRT_MODE_SET        ; GET THE VALUE OF THE CURRENT MODE
;        OUT     DX,AL          ; SET THE CRT MODE,SO THAT CRT IS ON
K81A:   ; цикл ожидания окончания паузы
        TEST    KB_FLAG_1,HOLD_STATE
        JNZ     K81A
        JMP     K27            ; к выходу из прерывания
K82:
       ; проверка CTRL+PrintScreen
        CMP     AL,55
        JNE     K83
        MOV     AH,114     ; START/STOP PRINTING SWITCH
        JMP     KW0_BUF         ; к записи в буфер
 K83:
        MOV     CL,94-59        ; приращение для получения псевдо скан-кода
;-----------------------------------------------------------------------
;     КОНТРОЛЬ ФУНКЦИОНАЛЬНЫХ КЛАВИШ И ПРОБЕЛА
;      (CL) - приращение для получение псевдо скан_кода
CONTR_FK:
         ; проверка на пробел
         CMP     AL,57
         JNE     C_FK1
         MOV     AL,' '
         JMP     SHORT KW_BUF
C_FK1:   ; проверка на функциональные клавиши
         CMP     AL,59
         JB      K90A
         CMP     AL,68
         JA      K90A
         ADD     AH,CL
;----------------------------------------------------------------------
;------- ЗАПИСЬ В БУФЕР
KW0_BUF: SUB    AL,AL
KW_BUF:
;        CALL    DISP_AX     ;  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        ; занесение скан_кода (AH) и кода символа в буфер (AL)
        MOV     BX,BUFFER_TAIL ; GET THE END POINTER TO THE BUFFER
        MOV     SI,BX         ; SAVE THE VALUE
        CALL    K4            ; ADVANCE THE TAIL
        CMP     BX,BUFFER_HEAD ; HAS THE BUFFER WRAPPED AROUND
        JE      K90           ; BUFFER_FULL_BEEP
        MOV     [SI],AX        ; STORE THE VALUE
        MOV     BUFFER_TAIL,BX ; MOVE THE POINTER UP
        JMP     K90A           ; INTERRUPT RETURN
;------ BUFFER IS FULL,SOUND THE BEEPER
K90:                          ; BUFFER-FULL-BEEP
;        MOV     AL,EOI
;        OUT     20H,AL
        MOV     BX,0504H       ;
        CALL    BEEP
K90A:   JMP     K26           ; INTERRUPT_RETURN
KB_INT ENDP
;=========================================================================
;      определение статуса дополн. клавиатуры
;      выход:
;        Z=TRUE   -   управляющая клавиатура
;        Z=FALSE  -   цифровая клавиатура
 CALC_NUMKEY_SHIFT  PROC NEAR
       MOV     BL,DL
       AND     BL,NUM_SHIFT+LEFT_SHIFT+RIGHT_SHIFT
       JZ      CALC_END
       CMP     BL,NUM_SHIFT+1
       JB      CALC_END
       CMP     AL,AL    ;установка флага Z
CALC_END: RET
CALC_NUMKEY_SHIFT  ENDP
;=========================================================================
;      ПЕРЕКОДИРОВКА СИМВОЛОВ С ПРОВЕРКОЙ ГРУППЫ ДИАПАЗОНОВ
;      (BX) - указатель на структуру
;              <мин><макс><приращение>
;       Выход: флаг Z=0  - неудачный поиск
;              флаг Z=1  - удачный поиск, (AL)- порядковый номер
CONTR_TABLE PROC  NEAR
       PUSH    DX
       SUB     DL,DL       ; суммарный диапазон
CT0:   MOV     CX,CS:[BX]
       CMP     AL,CL
       JB      CTE
       CMP     AL,CH
       JBE     CT00
       ;код вне интервала
       SUB     CH,CL
       ADD     DL,CH         ;накопление суммарной длины диапазонов
       INC     DL
       ADD     BX,2
       CMP     CL,83
       JB      CT0
       JMP     SHORT CTE
       ;код внутри интервала
CT00:  SUB     AL,CL
       ADD     AL,DL
       CMP     AL,AL   ; установка флага Z
CTE:   POP     DX
       RET                   ;выход - удачный поиск
CONTR_TABLE ENDP
;=========================================================================
;      ПЕРЕКОДИРОВКА СИМВОЛОВ С ПРОВЕРКОЙ ДИАПАЗОНА
;      (BX) - указатель на структуру
;             <мин><макс><таблица>
;
CONTR_CODE PROC  NEAR
       MOV     CX,CS:[BX]
;       PUSH    AX          ;  !!!!!!!!!!!!!!!!!
;       MOV     AL,'='
;       CALL    DISP_CHAR
;       MOV     AX,CX
;       CALL    DISP_AX
;       POP     AX
       CMP     AL,CL
       JB      CC_END
       CMP     AL,CH
       JA      CC_END
       ; скан-код находится в допустимом диапазоне
       SUB     AL,CL ; определение смещения относительно минимального кода
       ADD     AL,2
       XLAT    CS:K10
       POP     CX    ; удаление из стека адреса возврата
       TEST    AL,80H; проверка формирования псевдо скан_кода
       JNZ     CC_C1; если особый код
       ; проверка на латинские буквы
       CMP     AL,'a'
       JB      CC_C0
       CMP     AL,'z'
       JA      CC_C0
       ; латинские буквы - анализ состояния упр. клавиш
       MOV     CL,DL
       AND     CL,LEFT_SHIFT+RIGHT_SHIFT+CAPS_STATE
       JZ      CC_C0                    ; клавиши управления не нажаты
       CMP     CL,CAPS_STATE+1
       JAE     CC_C0                     ; нажата только одна из клавиш
       SUB     AL,'a'-'A'
CC_C0: JMP     KW_BUF
CC_C1: ; проверка запрещенного скан_кода
       CMP     AL,0FFH
       JZ      K90A   ;запрещенный скан_код
       CMP     AL,0FEH
       JNZ     CC_C2;
       MOV     AH,132
       JMP     KW0_BUF
CC_C2: ; псевдо скан_код
       AND     AL,7FH
       MOV     AH,AL
       JMP     KW0_BUF
CC_END: RET
CONTR_CODE ENDP
;=======================================================================
;      ПРИРАЩЕНИЕ УКАЗАТЕЛЯ КОЛЬЦЕВОГО БУФЕРА ВВОДА
;      (BX) - указатель
K4      PROC    NEAR
        ADD     BX,2          ;переход к следующему слову
        CMP     BX,OFFSET KB_BUFFER_END ; конец буфера ?
        JNE     K5            ;конец буфера не достигнут
        MOV     BX,OFFSET KB_BUFFER ;в начало буфера (по кольцу)
K5:     RET
K4      ENDP
;=========================================================================
INCLUDE INT_TIME.ASM
;---------------------------------------------------------------------------
; Эта программа обрабатывет прерывания таймера 8253 по каналу 0. Входная
; частота 1.19318Мгц, делитель 65536, результат - 18.2 прерывания в секунду.
;
; Обработка прерывания содержит счетчик прерываний, который может
; использоваться для установки времени суток. Обработка прерывания также
; вычитает счетчик управления двигателем накопителем ГМД, и когда счетчик
; исчерпан, двигатель отключается и сбрасываются флажки. Обработка прерывания
; может воздействовать на программу пользователя через прерывание 1CH каждый
; такт таймера. Пользователь подготавливает программу и помещает ее адрес в
; таблицу векторов.
;--------------------------------------------------------------------------
TIMER_INT        PROC  FAR
        STI                          ;Разрешить прерывания
        PUSH    DS
        PUSH    AX
        PUSH    DX                   ;Сохранить состояние
        MOV     AX,DATA
        MOV     DS,AX                ;Установить адресацию
        INC     TIMER_LOW            ;Инкремент таймера
        JNZ     T4                   ;Переполнение?
        INC     TIMER_HIGH           ;Инкремент старшей части таймера
T4:                                  ;Переполнение
        CMP     TIMER_HIGH,018H      ;Проверка: равен счетчик 24 часам?
        JNZ     T5                   ;Управление дискеттой
        CMP     TIMER_LOW,0B0H
        JNZ     T5                   ;Управление дискетой
;
;------Таймер исчерпал 24 часа
;
        MOV     TIMER_HIGH,0
        MOV     TIMER_LOW,0
        MOV     TIMER_OFL,1
;
;------Опрос времени ожидания для дискеты
;
T5:                                  ;Управление дискетой
        DEC     CURSOR_COUNT
        JNZ     T6
        MOV     CURSOR_COUNT,CURSOR_TIME
        CMP     CURSOR_MODE,0         ;анализ на нулевой размер курсора
        JZ      T6
        CMP     CURSOR_MODE,2000H     ;15.01.90г
        JZ      T6                    ;15.01.90г
T51:    MOV     AX,8
        INT     10h
        NOP
T6:                                  ;Возврат из программы
        INT     1CH                ;Передача управления программе пользователя
        MOV     AL,EOI
        OUT     020H,AL              ;Конец прерывания для 8259
        POP     DX
        POP     AX
        POP     DS                   ;Восстановить состояние
        IRET                         ;Возврат из прерывания
TIMER_INT       ENDP
        ORG     0EC59H
INCLUDE INT13.ASM
;----------------------------------------------------------
;     ВВОД/ВЫВОД С ДИСКЕТЫ (INT 13H)
;----------------------------------------------------------
;DISKETTE_IO    PROC    NEAR
;         JMP     INT13_SERVICE
;DISKETTE_IO    ENDP
TEST_TABLIC     LABEL    WORD        ;Таблица координации аппаратуры
        DW      0,0,0,0              ;Адреса адаптеров RS232
        DW      0378H,0,0,0          ;Адреса принтеров
        DW      40ECH                ;Установить '4 устройства'
        DB      0                    ;Флаг инициализации
        DW      96                   ;Размер памяти в Кбайтах
        DW      40H                  ;Память канала ввода/вывода
        DB      0
        DB      0
        DB      0
        DW      1EH                  ;Указатель вершины буфера
        DW      1EH                  ;Указатель начала буфера
INCLUDE SCANINT2.ASM
;----------------------------------------------------------------------------
;  24.10.88   Батьковский  М.Б.
;----------------------------------------------------------------------------
;  29.10.88 - проверка повторного вхождения
;  14.02.89 - дополнительные скан_коды (начинаются на 0E0H:c8,cb,cd,d0)
;----------------------------------------------------------------------------
; --  таблица клавиш для ИНТЕК ( по новому  ГОСТу )
;             бит 7 - признак необходимости инвертирования SHIFT
;----------------------------------------------------------------------------
; ------------нет спецсимволов--- SHIFT1 ----SHIFT2-----позиция в матрице--
;                                                      ИНТЕК              ПОИСК
LN_KEY1 DB        80H+09H,           04H,   80H+29H    ; 1/12       1      4/7
        DB            34H,       80H+08H,   80H+33H    ; 4/1        2      2/9
        DB        80H+0CH,       80H+09H,   80H+34H    ; 4/2        3      2/10
        DB        80H+0AH,           0DH,       28H    ; 4/6        4  .   8/7
        DB        80H+28H,       80H+05H,   80H+1AH    ; 4/10       5      8/11
        DB            0CH,       80H+03H,   80H+03H    ; 5/4        6      8/1
        DB        80H+0BH,       80H+02H,   80H+08H    ; 5/5        7      8/5
        DB            35H,       80H+04H,   80H+07H    ; 5/9        8      8/12
        DB        80H+27H,       80H+06H,   80H+1BH    ; 5/11       9      4/9
        DB            33H,       80H+07H,       2BH    ; 5/12      10  .   4/10
        DB        80H+06H,       80H+0BH,       1AH    ; 8/1       11  .   1/11
        DB        80H+35H,       80H+0AH,   80H+2BH    ; 8/2       12      1/9
        DB            27H,           05H,       29H    ; 8/10      12  .   2/5
        DB            35H,           37H,       00     ; 8/11      14
        DB        80H+02H,       80H+0DH,       1BH    ; 8/12      15  .   2/1
;----------------------------------------------------------------------
;       опрос матрицы клавиатуры, формирование кода сканирования
;       и запись скан - кода в порт 60H
;-----------------------------------------------------------------------
SCANINT PROC	NEAR
        STI
	PUSH	AX
	PUSH	DS
	MOV	AX,DATA
	MOV	DS,AX
;------ проверка состояния клавиатуры в целом
	MOV	AL,0FFH	       ;выбор всех линий матрицы
	OUT	LINE_SEL,AL
	IN	AX,COL_READ	;чтение состояния колонок
        OR      AH,0F0H         ;установка едениц в 4-ре старших бита
        INC     AX              ;проверка на все еденицы (пусто)
        JNZ     SC1            ;если не пусто
;       новое состояние пусто  AX=0
        MOV     LAST,AX         ;не прверять на повторение
        CMP     AX,EMPTY        ;
        JNZ      SC1
SC0:    JMP      SC_RET1        ;если старое состояние "пусто"
SC1:
;--------   обработка клавиш, изменивших положение
        ;   AX - новое интегральное состояние клавиатуры
        ;        00     -    пусто
        ;        другое - не пусто
;------ проверка на повторное вхждение в прерывание
        CMP     W_SCAN,TRUE
        JZ      SC0
        MOV     W_SCAN,TRUE       ; установка признака "работа"
        PUSH    BX
        PUSH    CX
        PUSH    DX
        PUSH    DI
        PUSH    SI
        MOV     EMPTY,AX        ; запись нового состояния клавиатуры
        MOV     BX,offset KB_STAT ; адрес предидущего состояния клавиатуры
        MOV     DI,offset LINE1+KB_KEY-1   ; адрес анализируемой клавиши
        MOV     DL,KB_STAT_S          ; код для опроса линии
        ;------------------- начало цикла SC2 / SC2E
SC2:    MOV     AL,DL           ; установка линейного кода опроса линии
        OUT     LINE_SEL,AL     ; опрос линии
        IN      AX,COL_READ
        OR      AH,0F0H
        NOT     AX              ; перевод из инверсного кода
        CMP     AX,[BX]         ; сравнение нового состояния со старым
        JNZ     SC21            ; если состояния не совпали
        ;------ состояние линии изменилось
        SUB     DI,KB_L_KEY     ; переход к новой линии в табл скан кодов
        JMP     SC2E
        ;------ зафиксировано изменение состояние клавиши в линии
        ;------ определение клавиш изменивших состояние
        ;       проверка в цикле
SC21:
        MOV     SI,AX
        XOR     SI,[BX]         ; SI содержит единицы в отличающихся битах
        MOV     [BX],AX         ; запоминание текущего состояния линии
        MOV     CX,KB_STAT_C    ; номер начальной колонки в линейном коде
        ;       AX - новое состояние текущей линии
        ;       BX - адрес линии в массиве KB_STAT
        ;       CX - номер колонки
        ;       DL - номер линии
        ;       DI - адрес скан-кода проверяемой клавиши
        ;       SI - содержит еденицы в битах изменившихся клавиш
        ;------------------- начало цикла SC22 / SC22E
SC22:
        TEST    SI,CX            ; выделение колонки
        JZ      SC22E            ; если колонки не отличаются
        ;------- клавиши изменили свое сотояние
        TEST    [BX],CX
        JZ      SC222           ; новое состояние "пусто"?
        ;-------- новая клавиша нажата
        MOV     LAST,DI         ; номер нажатой клавиши
        MOV     TIME,FIRST_TIME ; новая уставка времени ожидания
        CALL    SEND_CODE       ; отработка  нажатой клавиш
        JMP     SC22E
        ;-------  новая клавиша отжата
SC222:  CMP     DI,LAST
        JNZ     SC2221          ; если отжата не повторяющаяся клавиша
        MOV     LAST,0          ; сброс клавиши повторения
SC2221: MOV     AL,CS:[DI]      ; получение скан кода клавиши
        CMP     AL,SHIFT2_KEY+80H
        JNZ     NO_SH2
        ;SHIFT2
        NOT     SHIFT2
        NOT     RUSS
NO_SH2:
        MOV     AH,80H          ; признак отжатой клавиши
        CALL    C_OUT60         ; вывод в 60 порт + INT9
        ;----------------- конец цикла SC22/ SC22E
SC22E:
        DEC     DI               ; адрес нового скан-кода
        SHR     CX,1             ; переход к следующей колонке
        JNC     SC22
SC2E:   ADD     BX,2            ; переход к следующей линии
        SHR     DL,1            ; модификация линейного кода
                                ;(счетчик цикла)
        JNC     SC2
        ;-----------------------------------конец цикла SC2/ SC2E
;------проверка отсутствия новой нажатой клавиши
        MOV     DI,LAST
        OR      DI,DI
        JZ      SC_RET
;------проверка длительного нажатия клавиш
        MOV     BX, offset TIME
        DEC     byte ptr [BX]   ; проверка окончания интервала тповторения
        JNZ     SC_RET
        MOV     [BX],byte ptr SECOND_TIME ; повторная установка интервала
        CALL    SEND_CODE      ; формирование скан-кода
SC_RET:
        MOV     W_SCAN,FALSE   ; сьрос признака работа
        POP     SI
        POP     DI
        POP     DX
        POP     CX
        POP     BX
SC_RET1:
        CLI
        MOV     AL,20H         ; контроллер прерываний
        OUT     20H,AL
        POP     DS
        POP     AX
        IRET
SCANINT ENDP
;-------------------------------------------------
;       формирование кода нажатой сканирования
;-------------------------------------------------
;       DI - адрес скан-кода клавиши
;-------------------------------------------------
SEND_CODE      PROC	NEAR
        MOV     AL,CS:[DI]     ; первичный скан-код
	CMP	AL,62		;SCODE - F4
	JNZ	NO_FBEEP
	NOT	FBEEP
NO_FBEEP:
;------ проверка на особые клавиши ( по новому ГОСТу )
        CMP     AL,255-16
        JNC     SEND1          ; если особая клавиша
;------ проверка на часто длительно нажатые клавиши
;       AND     AL,7FH
;       TEST    byte ptr CS:[DI],80H
        CMP     AL,80H         ; повека на особые клавиши
        JB      SEND1          ; если обычная клавиша
        CMP     AL,48H+80H     ; повека диапазона клавиш 0C8..0D0
        JB      SEND01
        CMP     AL,50H+80H
        JBE     SEND1
SEND01: CMP     TIME,SECOND_TIME
        JZ      SEND2
SEND1:
        CMP     FBEEP,TRUE
	JNZ	SEND1A             ; если звук подавлен
;-------- звуковой сигнал по нажатию клавиши
        PUSH    BX
        MOV     BX,0101H
        CALL    BEEP
        POP     BX
;---------------------
SEND1A:
        ; проверка нажатия клавиши RUS
        CMP	AL,RUS_KEY+80H
        JZ      YES_RUS                 ; инверсия режима РУС/ЛАТ
        CMP     AL,SHIFT2_KEY+80H
        JNZ     NO_SHIFT2
        ;SHIFT2
        NOT     SHIFT2
YES_RUS:NOT     RUSS
        RET
NO_SHIFT2:
SEND2:
        XOR     AH,AH                ; признак нажатия клавиши
        CALL    C_OUT60              ; вывод в 60 порт + INT9
SEND_E:
	RET
SEND_CODE ENDP
;-------------------------------------------------------------------
;         вывод в порт 60 и вызов INT9
;             AL - код сканирования (первичный) клавиши
;                  255-250  - ссылка на другую таблицу
;             AH - 00  - клавиша нажата
;                  80H - клавиша отжата
;-------------------------------------------------------------------
C_OUT60 PROC NEAR
;------ проверка на особые клавиши ( по новому ГОСТу )
        CMP     AL,255-16
        JNC     C_OUT1
;------ проверка на клавиши отличные от клавиатуры IBM
        CMP      AL,RUS_KEY+80H
        JNC      NO_INT9
;------ проверка на дополнительные скан_коды       ; 14.02.89
        CMP      AL,48H+80H
        JC       C_OUT60A
        PUSH     AX         ; дополнительные скан_коды
        MOV      AL,0E0H
        CALL     C_INT9
        POP      AX
;------ обычные скан коды
C_OUT60A:
        AND     AL,7FH
        OR      AL,AH
        CALL    C_INT9;
NO_INT9:
        RET
;------ особые клавиши ( по новому ГОСТу )
C_OUT1: PUSH    DI
        PUSH    SI
        PUSH    BX
        MOV     BX,AX
        XOR     AH,AH
        NOT     AL         ; AX - номер строки в таблице LN_KEY1
        MOV     SI,AX
;------ проверка на нажатие отжатие
        TEST    BH,80H
        JZ      C_OUT1A     ; если нажата
;------- клавиша  отжата
        MOV     AL,MEM_KEY[SI]  ; код сканирования нажатой клавиши
        OR      AL,BH           ; добавление признака " отжато"
        CALL    C_INT9
        JMP     C_OUT32
;------- клавиша нажата
C_OUT1A:
        MOV     DI,AX
        ADD     DI,AX
        ADD     DI,AX      ; DI - смещение  в таблице LN_KEY1
        MOV     AH,LEFT_KEY+80H ; состояние SHIFT1
        TEST    KB_FLAG,3H  ; проверка  клавиш SHIFT1
        JNZ     C_OUT2
        CMP     SHIFT2,FALSE  ; проверка  клавиш SHIFT1
        JZ      C_OUT3      ; клавиши SHIFT1 и SHIFT2 не нажаты
        ; клавиша SHIFT2 нажата
        INC     DI
        INC     DI
        JMP     C_OUT3
C_OUT2: ; клавиша SHIFT1 нажата
        AND     AH,7FH
        INC     DI
;------- вывод модифицированного скан-кода
C_OUT3:
        MOV     BL,CS:LN_KEY1[DI]
        TEST    BL,80H         ; проверка необходимости смены SHIFT1
        JZ      C_OUT31
        ;  переключение SHIFT1
        MOV     AL,AH
        XOR     AL,80H          ; Инвертирование старшего бита
        CALL    C_INT9          ; выдача обратного кода для SHIFT1
C_OUT31:; скан код нажатой клавиши
        MOV     AL,BL
        AND     AL,7FH
        MOV     MEM_KEY[SI],AL ; запоминание скан-кода нажатой клавиши
        CALL    C_INT9
        ;  восстановление SHIFT1
        TEST    BL,80H
        JZ      C_OUT32
        MOV     AL,AH
        CALL    C_INT9          ;  восстановление состояния SHIFT
C_OUT32:POP      BX
        POP      SI
        POP      DI
        RET
C_OUT60 ENDP
;--------------------------------------------------------------
C_INT9  PROC NEAR
;       AX - код сканирования
;       CALL   DISP_AX     ; !!!!!!!!
        OUT    LINE_SEL,AL
        INT    KEY_INT
        RET
C_INT9  ENDP
;---------------------------------------------------------------
INCLUDE NMISER.ASM
;------------------------------------------------------------------------
;                                                                       ;
;     *******          Программа обслуживания NMI            *******    ;
;                                                                       ;
;------------------------------------------------------------------------
NMI_SERVICE:
        CLD
        PUSH    ES
        PUSH    DS
        PUSH    DX
        PUSH    CX
        PUSH    BX
        PUSH    SI
        PUSH    DI
        PUSH    AX
        MOV     AX,DSEGMENT
        MOV     DS,AX
        MOV     AX,START_BUFFER   ;Адрес начала буфера
        MOV     ES,AX
        IN      AX,TRAP_A
        MOV     BX,AX
        TEST    AH,40h
        JNZ     IO_ROUTINES
MWTC_ROUTINE:                     ;Подпрограмма обслуживания ВИДЕО
                                  ; (запись текста)
        CLI                       ;Запрет прерываний
        MOV     DI,BX
        AND     DI,3FFEh          ;Выбор части адреса
        MOV     DX,ES:[DI]        ;Чтение символа/атрибута
        SAR     DI,1
        MOV     AX,DI
        MOV     CL,AH
        SAR     CL,1
        SAR     CL,1
        TEST    CRT_MODE,2        ;80x25 ?
        JZ      MW4               ;Нет, 40x25
        SAR     CL,1              ;CL = PageNo
        MOV     CH,80             ;CH = 80
        AND     AH,7
MW2:
        DIV     CH
        XCHG    AH,AL
        PUSH    AX
        CBW
        SUB     DI,AX
        SAL     DI,1
        SAL     DI,1
        ADD     DI,AX
        POP     AX
        CMP     CL,ACTIVE_PAGE    ;Активная страница?
        JNE     AX_NMI
        XOR     CH,CH
        MOV     SI,CX
        SAL     SI,1
        CMP     AX,[SI+OFFSET CURSOR_POSN]
        MOV     BX,EXTRA_BUFFER
        MOV     ES,BX
        PUSHF
        JNE     MW3
        CALL    REMOVE_CURSOR
MW3:
        PUSH    AX
        MOV     AX,DX
        MOV     BL,AH
        XOR     AH,AH
        MOV     CL,1
        TEST    CRT_MODE,2        ;\80x25 ?
        JNZ     MW31              ;\ДА
        and     di,0fffh          ;\
        JMP     MW32              ;\
MW31:   AND     DI,1FFFH          ;\
MW32:   CALL    S1B
        POP     AX
        POPF
AX_NMI:
        POP     AX
NMI_RET:
        JMP     VIDEO_RETURN      ;Переход на возврат из ВИДЕО
MW4:
        MOV     CH,40
        AND     AH,3
        JMP     MW2
IO_ROUTINES:                      ;Дешифрация остальных NMI
                                  ;  (обращение к портам ВИДЕО)
        TEST    AH,80h
        JNZ     IOWC_ROUTINE
IORC_ROUTINE:
        POP     AX
        MOV     AL,0FFh
        JMP     VIDEO_RETURN
IOWC_ROUTINE:
        IN      AL,TRAP_D
        MOV     SI,AX
        CMP     BL,0D4h ;         ;Порт 3D4 ?
        JE      PORT_3D4
        CMP     BL,0D5h           ;Порт 3D5 ?
        JE      PORT_3D5
        CMP     BL,0D8h           ;Порт 3D8 ?
        JE      PORT_3D8
        CMP     BL,0D9h           ;Порт 3D9 ?
        JNE     AX_NMI
PORT_3D9:
        XCHG    AL,AH             ;Сохранить первоначальные данные
        IN      AL,SCR_MODE       ;ввести байт текущего режима
        AND     AX,37C8H          ;Маска D7,D6 и D3
                                  ;Выбор D4,D5 и D2..D0
        OR      AL,AH             ;Составить новый байт
        OUT     SCR_MODE,AL       ;Задать новый режим экрана
        JMP     AX_NMI
PORT_3D4:                         ;Запись в порт 3D4 (число 6845)
        MOV     REG_6845,AL       ;Сохранить это в памяти
        JMP     AX_NMI            ;Все сделано
PORT_3D5:
        MOV     CL,REG_6845       ;Восстановить число
        CMP     CL,11
        JNZ     REG10
        MOV     BYTE PTR CURSOR_MODE,AL
REG10:  CMP     CL,10
        JNZ     REG14
        MOV     BYTE PTR CURSOR_MODE+1,AL
REG14:
        CMP     CL,15             ;Регистр=15?
        JE      REG_15
        CMP     CL,14             ;Регистр=14?
        JNE     AX_NMI            ;Если регистр не 14 и не 15, ничего не делать
        MOV     CURSOR_POS_H,AL   ;Сохранить верхнюю позицию курсора
        JMP     AX_NMI            ;Все сделано
REG_15:                           ;Регистр 15
        MOV     CURSOR_POS_L,AL   ;Сохранить нижнюю позицию курсора
        MOV     AH,CURSOR_POS_H
        TEST    CRT_MODE,2
        JZ      R_15_2
        MOV     CL,80
R_15_1:
        and     ax,07ffh
        DIV     CL
        XCHG    AL,AH
        MOV     DX,AX
        POP     AX
        MOV     BH,ACTIVE_PAGE
        JMP     SET_CPOS
R_15_2:
        MOV     CL,40
        JMP     R_15_1
PORT_3D8:                         ;Порт 3D8 (порт режима)
        AND     AL,1Fh            ;***
        JE      P_D8_RET
        TEST    AL,8
        JNZ     P_D8_RET
        TEST    AL,12h               ;Графика?
        JNZ     P_D8_3               ;Да
        XOR     AH,AH
        TEST    AL,1                 ; 80X25 ?
        JZ      P_D8_1               ;Нет
        MOV     AH,2
P_D8_1:
        TEST    AL,4                 ;Цветной?
        JNZ     P_D8_2               ;Нет
        INC     AH
P_D8_2:
        XCHG    AL,AH
        XOR     AH,AH
        CMP     AL,CRT_MODE
        JE      P_D8_RET          ;Вызов обработки функций ВИДЕО
        INT     10h
P_D8_RET:
        JMP     AX_NMI
P_D8_3:
        MOV     AH,6
        TEST    AL,10h                ; 640X200 ?
        JNZ     P_D8_2                ; Да
        DEC     AH
        TEST    AL,4                  ;Цветной?
        JNZ     P_D8_2                ;Нет
        DEC     AH
        JMP     P_D8_2
INCLUDE INT15_B.ASM
;--------------------------------------------------------------------------
WRITE_BYTE	PROC	NEAR
; ЗАПИСЬ БАЙТА НА КАССЕТУ
; ББАЙТ ДЛЯ ЗАПИСИ ПЕРЕДАЕТСЯ В РЕГИСТРЕ AL.
;---------------------------------------------------------------------------
	PUSH	CX			;СОХРАНИТЬ CX,AX
	PUSH	AX
	MOV	CH,AL			;CH <--- ЗАПИСЫВАЕМЫЙ БАЙТ
					;(СТАРШИЙ БИТ ПИШЕТСЯ ПЕРВЫМ)
	MOV	CL,8			;ДЛЯ 8 БИТ ДАННЫХ В БАЙТЕ.
					;ПРИ ЧТЕНИИ ДВА ПЕРЕПАДА СИГНАЛА
W27:					;ОПРЕДЕЛЯЮТ ОДИН БИТ
	RCL	CH,1			;CY <--- СТАРШИЙ БИТ
	PUSHF				;СОНРАНИТЬ ФЛАГИ
					;ДЛЯ ЗАПИСИ БИТ ПЕРЕДАЕТСЯ В CY
	CALL	WRITE_BIT		;ЗАПИСАТЬ БИТ ДАННЫХ
	POPF				;ВОССТАНОВИТЬ CY ДЛЯ ВЫЧИСЛЕНИЯ CRC
	CALL	CRC_GEN	                ;ВЫЧИСЛИТЬ CRC ДЛЯ ЗАПИСЫВАЕМОГО БИТА
	DEC	CL			;DEC СЧЕТЧИК БИТ
	JNZ	W27			;ПОВТОРИТЬ, ЕСЛИ НЕ ВСЕ БИТЫ ЗАПИСАНЫ
	POP	AX			;ВОССТАНОВИТЬ AX,CX
	POP	CX
	RET				;ЗАКОНЧИТЬ ЗАПИСЬ БАЙТА
WRITE_BYTE	ENDP
;--------------------------------------------------------------------------
WRITE_BIT       PROC    NEAR
; ЦЕЛЬ:
;
; ЗАПИСАТЬ БИТ ДАННЫХ НА КАССЕТУ
; ЗАПИСЫВАЕМЫЙ БИТ ПЕРЕДАЕТСЯ В CY
; Т.Е. ЕСЛИ CY=1, ЗАПИСЫВАЕТСЯ БИТ "1",
;      ЕСЛИ CY=0, ЗАПИСЫВАЕТСЯ БИТ "0"
;
; ПРИМЕЧАНИЕ: БИТ ЗАПИСЫВАЕТСЯ ДУМЯ ПЕРЕПАДАМИ СИГНАЛА(1 ПЕРИОД)
;       БИТ "1" ИМЕЕТ ДЛИТЕЛЬНОСТЬ ПОЛУПЕРИОДА 500 МИКРОСЕКУНД
;        ( ПЕРИОД - 1000 МИКРОСЕКУНД )
;
;       БИТ "0" ИМЕЕТ ДЛИТЕЛЬНОСТЬ ПОЛУПЕРИОДА 250 МИКРОСЕКУНД
;        ( ПЕРИОД - 500 МИКРОСЕКУНД )
;
;--------------------------------------------------------------------------
                                        ;ПРЕДПОЛОЖИМ, ЧТО '1'
        MOV     AX,1184                 ;ЗАДАТЬ ПЕРИОД "1"
        JC      W28                     ;ПЕРЕЙТИ, ЕСЛИ ЗАПИСЫВАЕМИЙ БИТ "1"
        MOV     AX,592                  ;ИНАЧЕ УСТАНОВИТЬ ПЕРИОД "0"
W28:
        PUSH    AX                      ;СОХРАНИТЬ AX
W29:
        IN      AL,PORT_C               ;ЧИТАТЬ ВЫХОД КАНАЛА 2 ТАЙМЕРА
        AND     AL,020H
        JZ      W29                     ;ЖДАТЬ ПОЯВЛЕНИЕ ВЫСОКОГО УРОВНЯ
W30:
        IN      AL,PORT_C               ;ТЕПЕРЬ ЖДАТЬ ПОКА ТАЙМЕР ПЕРЕКЛЮЧИТСЯ
					;ОБРАТНО В НИЗКИЙ УРОВЕНЬ
        AND     AL,020H
        JNZ     W30
                                        ;ПЕРЕЗАГРУЗИТЬ КАНАЛ 2 ТАЙМЕРА
                                        ;ДЛЯ ПОЛУЧЕНИЯ ПЕРИОДА СЛЕДУЮЩЕГО БИТА
        POP     AX                      ;ВОССТАНОВИИТЬ КОЭФФИЦИЕНТ ДЕЛЕНИЯ
W31:                                    ;ПРОГРАММИРОВАНИЕ ТАЙМЕРА
        OUT     042H,AL                 ;ЗАПИСАТЬ МЛАДШИЙ БАЙТ В КАНАЛ 2
        MOV     AL,AH
        OUT     042H,AL                 ;ЗАПИСАТЬ СТАРШИЙ БАЙТ В КАНАЛ 2
        RET
WRITE_BIT       ENDP
;------------------------------------------------------------------------
CRC_GEN PROC    NEAR
; ГЕНЕРИРУЕТ CRC ДЛЯ ЗАПИСЫВАЕМОГО БИТА
;
; CRC ИСПОЛЬЗУЕТСЯ ДЛЯ ОБНАРУЖЕНИЯ ОШИБОК ЧТЕНИЯ
;
; В CY ПЕРЕДАЕТСЯ БИТ НА КОТОРЫЙ ГЕНЕРИРУЕТСЯ CRC
;
; МОДИФИЦИРУЕТ AX И ФЛАГИ
;
;-------------------------------------------------------------------------
        MOV     AX,CRC_REG
                                        ;ПОСЛЕДУЮЩИЕ ИНСТРУКЦИИ
                                        ;УСТАНАВЛИВАЮТ ФЛАГ ФЛАГ ПЕРЕПОЛНЕНИЯ,
                                        ;ЕСЛИ CY И СТАРШИЙ БИТ CRC НЕ РАВНЫ
        RCR     AX,1
        RCL     AX,1
        CLC                             ;ОБНУЛИТЬ CY
        JNO     W32                     ;ПЕРЕЙТИ, ЕСЛИ ПЕРЕПОНЕНИЕ
                                        ;ЕСЛИ БИТ ДАННЫХ XOR С 15 РАЗРЯДОМ
                                        ;CRC РЕГИСТРА = 1,
        XOR     AX,0810H                ;ТО ВЫПОЛНИТЬ XOR CRC РЕГИСТРА С
                                        ;0810H
        STC                             ;УСТАНОВИТЬ CY
W32:
        RCL     AX,1                    ;СДВИНУТЬ CY (БИТ ДАННЫХ)
                                        ;В CRC РЕГИСТР
        MOV     CRC_REG,AX              ;СОХРАНИТЬ CRC
        RET                             ;ЗАКОНЧИТЬ
CRC_GEN ENDP
INCLUDE RWCAS.ASM     ;INT15 - РАБОТА С ФАЙЛАМИ
;------------------------------------------------06-04-89----------
;  ПРОЦЕДУРА ОСУЩЕСТВЛЯЕТ ЧТЕНИЕ ФАЙЛА С КАССЕТЫ
;------------------------------------------------------------------
;
;     1.3. Заголовок файла
;     Заголовок  файла  на магнитной ленте имеет следующий формат
;(смещения даются в байтах в  шестнадцатеричной  системе  счисле-
;ния):
; 0   Содержит значение 0A5h, признак заголовка файла.
;
;1-8  Имя файла. Длина имени файла от 1 до 8 символов. Кроме сим-
;     волов, перечисленных в описании языка как допустимые в име-
;     ни файла символы, кассетный Бейсик в имени файла  допускает
;     также и русские буквы.
;
; 9   Тип файла.  Определяет тип содержащейся в файле информации,
;     способ ее представления в файле, команду, с помощью которых
;     информация была записана в файл. Тип файла кодируется  сле-
;     дующими значениями:
;
;     00 - файл, содержащий Бейсик-программу в символьном  форма-
;          те,  записанный на магнитную ленту с помощью оператора
;          SAVE, описанного в подпункте 3.51  данного  документа,
;          или  файл  данных,  записанный Бейсик-программой с по-
;          мощью операторов PRINT# и WRITE#, описанных в подпунк-
;          тах 3.43 и 3.59 данного документа. Из Бэйсик-программы
;          такой файл открывается и закрывается с помощью  опера-
;          торов  OPEN и CLOSE, описанных в подпунктах 3.37 и 3.4
;          данного документа. В случае  использования  кассетного
;          Бейсика  оператор  OPEN (см.п.3.37) записывает на маг-
;          нитную ленту заголовок файла. Функция оператора  CLOSE
;          (см.п.3.4)  заключается в дописывании в файл полностью
;          незаполненного буфера файла после завершения  операций
;          записи  в  файл.  Операторы PRINT# (см.п.3.43), WRITE#
;          (см.п.3.59) непосредственно записывают выводимые  дан-
;          ные в 256-байтный буфер файла. Когда этот буфер запол-
;          няется полностью, он целиком переписывается на магнит-
;          ную ленту и освобождается для приема новых данных.
;     01  - файл с содержимым области оперативной памяти; записы-
;          вается с помощью оператора BSAVE (см.п.3.51).
;     40 - файл, содержащий Бейсик-программу в символьном  форма-
;          те. Записывается на магнитную ленту с помощью операто-
;          ров SAVE (см.п.3.51) с опцией А и директивы LIST, опи-
;          саной в подпунктах 3.27, 5.7.
;     80  -  файл,  содержащий Бейсик-программу в сжатом формате.
;          Записывается на магнитную ленту  с  помощью  оператора
;          SAVE (см.п.3.51) без опции.
;     A0 - файл, содержащий Бейсик-программу в защищенном формате.
;          Записывается на магнитную ленту с помощью операторов
;          SAVE (см.п.3.51) с опцией P.
;
;A-B  Длина  записанной  в файл информации.
;C-D  Значение сегмента адреса в  оперативной  памяти  информации,
;     которая была переписана в файл.
;E-F  Значение  смещения  адреса в оперативной памяти информации,
;     которая была переписана в файл.
;10   Содержит значение 00, признак конца заголовка файла.
;
;     Примечание. Длина записанной в  файл  информации,  значения
;сегмента  и  смещения адреса (поля заголовка A-F) запоминаются в
;заголовке только для файлов типов 01, 80 и А0.
FILE_READ  PROC    NEAR
rc2:
          MOV     BP,SP
          MOV     AX,SS:[BP+2]
          MOV     DS,AX          ;(DS:BX) - ИМЯ ФАЙЛА
          PUSH    BX
RC3:      mov     bx,0
          mov     cx,12
          mov     ah,2
          int     15h        ;загрузка заголовка
          JC      FREND      ;БЫЛА ОШИБКА
          mov     di,0       ;СРАВНЕНИЕ ЗАГОЛОВКА
          cmp     byte ptr es:[di],0a5h
          jnz     rc3
          INC     DI
          POP     BX
          mov     si,0
rc6:      mov     al,byte ptr es:[di]
          CMP     DS:[BX+SI],AL
          jnz     rc2         ;заголовок не совпал
          inc     di
          inc     si
          cmp     si,8
          jnz     rc6
          LEA	  si,fn       ;"ФАЙЛ НАЙДЕН"
	  mov	  cx,LFN
	  call	  P_MSG
          mov     di,10
          mov     cx,es:[di]
          mov     bx,0
          mov     ah,2
          int     15h         ;загрузить файл
	  ret
FREND:
	  pop     bx
          RET
FILE_READ  ENDP
;----------------------------------------------06-04-89------------
;   ПРОЦЕДУРА ОСУЩЕСТВЛЯЕТ ЗАПИСЬ ФАЙЛА НА КАССЕТУ
;------------------------------------------------------------------
FILE_WRITE   PROC     NEAR
          MOV     BP,SP
          MOV     AX,SS:[BP+2]
          MOV     DS,AX          ;(DS:BX) - ИМЯ ФАЙЛА
       PUSH  ES
       PUSH  DS
       POP   ES
       MOV   CX,17
       MOV   AH,3
       push  bx
       INT   15H
       pop   bx
       MOV   CX,DS:[BX+10]
       MOV   BX,0
       POP   ES
       MOV   AH,3
       INT   15H
       PUSH  DS
       RET
FILE_WRITE   ENDP
INCLUDE STP2.ASM
AN_STR  PROC    NEAR
        PUSH    AX
        PUSH    DS
        MOV     AX,DATA
        MOV     DS,AX
        MOV     AL,T_CURSOR
        INC     K_CICL
        ADD     AL,K_CICL
        MOV     AH,80
        TEST    CRT_MODE,2
        JNZ     AN0
        MOV     AH,40
AN0:
        CMP     AL,AH
        JNZ     AN180
        MOV     K_CICL,0
        MOV     T_CURSOR,0
        ADD     DI,80*3
AN180:
        POP     DS
        POP     AX
        RET
AN_STR  ENDP
;AN_STR40  PROC    NEAR
;        PUSH    AX
;        MOV     AL,T_CURSOR
;        INC     K_CICL
;        ADD     AL,K_CICL
;        CMP     AL,40
;        JNZ     AN140
;        MOV     K_CICL,0
;        MOV     T_CURSOR,0
;        ADD     DI,80*4
;
;AN140:
;        POP     AX
;        RET
;AN_STR40  ENDP
        ORG    0F065H
INCLUDE INT10_A.ASM
;----INT 10---------------------------------------------------
;VIDED_IO
;       Эта программа обеспечивает интерфейс видеорежимов.
;       Следующие функции реализованы:
;       (AH)=0 Установка режима (AL) Содержит значение режима.
;               (AL)=0 40*25 Черно/белый (BW)
;               (AL)=1 40*25 Цветной
;               (AL)=2 80*25 Черно /белый
;               (AL)=3 80*25 Цветной
;               Графические режимы
;               (АL)=4 320*200 Цветной
;               (AL)=5 320*200 Черно/белый
;               (AL)=6 640*200 Черно/белый
;               CRT MODE=7 80*25 Черно/белый (режим CRT)
;               ***NOTE BW MODES OPERATE SAME AS COLOR MODES,BUT COLOR
;               BURST IS NOT ENABLED
;       (AH)=1 Установка типа курсора
;               (CH)= Биты 4-0= строка начала курсора
;                      ** Аппаратно всегда вызываются мерцания
;                      ** Биты 5 и 6 вызывают неравномерное мерцание
;                         или исчезновение курсора
;               (CL)= Биты 4-0= строка исчезновения курсора
;       (AH)=2 Установка позиции курсора
;               (DH,DL)= Строка, колонка (0,0) Левый верхний угол
;               (BH)= Номер страници (0 Для графического режима)
;       (AH)=3 Чтение позиции курсора
;               (BH)= Номер страници (0 Для графического режима)
;               На выходе (DH,DL)= Строка, колонка текущей позиции курсора
;                         (CH,CL)= Текущий режим курсора
;       (AH)=4 Чтение позиции светового пера
;              (в БМ ЭВМ нереализовано,световое перо отсутсвует)
;               (AH)=0-- LIGHT REN SWITCH NOT DOWN/NOT TRIGGERED
;               (AH)=1-- VALID LIGHT REN VALUE IN REGISTERS
;                      (DH,DL)= ROW,COLUMN OF CHARACTER LP POSN
;                      (CH)= RASTER LINE(0-199)
;                      (BX)=PIXEL COLUMN(0-319,639)
;       (AH)=5 Выбор активной страницы (только для текстовых режимов)
;               (AL)= Значение новой страницы (0-7 для режимов 0 или 1,
;                      0-3 для режимов 2 или 3)
;       (AH)=6 Прокрутка активной страницы вверх
;               (AL)= Число строк проктрутки (освобождающиеся строки
;                     внизу окна заполняются пробелами)
;                     AL=0 Очистка всего окна
;               (CH,CL)= Строка, колонка верхнего левого угла окна
;               (DH,DL)= Строка, колонка правого нижнего угла окна
;               (BH)= Атрибут для строк заполнения окна
;       (AH)=7 Прокрутка активной страницы вниз
;               (AL) = Число строкпрокрутки (освобождающиеся строки
;                      вверху окна заполняются пробелами)
;                      AL = 0 Очистка всего окна (пробелами)
;               (CH,CL)= Строка, колонка верхнего левого угла окна
;               (DH,DL)= Строка, колонка нижнего правого угла окна
;               (BH)= атрибут для строк заполнения
;
;       Режим обработки символов
;
;       (AH)=8 Чтение атрибута/символа втекущей позиции курсора
;               (BH)= Номер страницы (только для текстового режима)
;               На выходе:
;               (AL)= Прочитанный символ
;               (AH)= Атрибут прочитанного символа (только для
;                     текстового режима)
;        (AH)=9 Запись атрибута/символа в текущую позицию курсора
;               (BH)= Номер страницы (только для текстовых режимов)
;               (CX)= Счетчик символов (повторений) для записи
;               (AL)= Символ для записи
;               (BL)= Атрибут символа (текст) или цвет (графика)
;
;       (AH)=10 Запись только символа в текущую позицию курсора
;               (BH)= Номер страницы (только для текстовых режимов)
;               (CX)= Счетчик символов (повторений) для записи
;               (AL)= Символ для записи
;       Для записи/чтения символов в графическом режиме знаки
;               формируются в знакогенераторе, который находится в ПЗУ
;               (только первые 128 знаков). Для считывания/записи вторых
;               128 знаков пользователь должен через прерывание 1FH
;               (ячейка 0007С) инициализировать указатель на 1К таблицу,
;               содержащую коды вторых 128 знаков.
;
;       При записи символов в графических режимах счетчик СХ будет дейст-
;               вовать только для текущей строки. Переход в следующую
;               строку будет некорректным.
;
;
;       Режимы обработки графики
;       (AH)=11 Установка цветовой палитры
;               (BH)= Цветовая палитра (0-127)
;               (BL)= Управление цветом (для текущей цветовой
;                  палитры, только для графики 320*200
;                      ВН=0 Выбор цвета фона, BL (0-15)
;                      BH=1 Выбор палитры:
;                           BL=0 - зеленый (1), красный (2), желтый (3)
;                           BL=1 - циан (1), мажента (2), белый (3)
;
;
;       (AH)=12 Запись точки
;               (DX)= Номер строки
;               (CX)= Номер колонки
;               (AL)= Значение цвета
;                      Если бит 7 AL=1, тогда значение цвета образуется
;                      операцией ХOR заданного значения и текущего
;       (AH)=13 Чтение точки
;               (DX)= Номер строки
;               (CX)= Номер колонки
;               (AL)= Возвращается прочитанная точка
;
;Вывод в режиме телетайпа кода ASCIL
;
;       (AH)=14 Запись в режиме телетайпа
;               (AL)= Символ для записи
;               (BL)= Цвет знакоместа в графическом режиме
;               (BH)= Номер страницы в тектовом режиме
;               Замечание: размер экрана определяется предварительно
;                          заданным режимом
;       (AH)=15 Текущий видеорежим
;               возвращает текущее состояние
;               (AL)= Текущий установленный режим
;               (AH)= Номер колонки символа на экране
;               (BH)= Текущая активная страница
;
;       CS,SS,DS,ES,BX,CX,DX Cохраняются программой,
;       остальные портятся
;--------------------------------------------------------
        ASSUME CS:CODE,DS:DATA,ES:VIDEO_RAM
M1      LABEL   WORD   ; Таблица программ ВИДЕО ввод/вывод
        DW      OFFSET SET_MODE         ; установка режима
        DW      OFFSET SET_CTYPE        ; установка размера курсора
        DW      OFFSET SET_CPOS         ; установка текущей позиции курсора
        DW      OFFSET READ_CURSOR      ; чтение текущей позиции курсора
        DW      OFFSET READ_LPEN        ; чтение текущей позиции светового пера
        DW      OFFSET ACT_DISP_PAGE    ; установка активной страницы видео
        DW      OFFSET SCROLL_UP        ; перемещение блока вверх по экрану
        DW      OFFSET SCROLL_DOWN      ; перемещение блока вниз по экрану
        DW      OFFSET READ_AC_CURRENT  ; чтение символа и атрибута в позиции курсора
        DW      OFFSET WRITE_AC_CURRENT ; запись символа и атрибута в позицию курсора
        DW      OFFSET WRITE_C_CURRENT  ; запись только символа в текущую позицию курсор
        DW      OFFSET SET_COLOR        ; установка цветовой палитры
        DW      OFFSET WRITE_DOT        ; запись точки (пикселя)
        DW      OFFSET READ_DOT         ; чтение точки (пикселя)
        DW      OFFSET WRITE_TTY        ; дисплей в режиме телетайпа
        DW      OFFSET VIDEO_STATE      ; состояние ВИДЕО
M1L     EQU     $-M1
VIDEO_IO        PROC   NEAR
        STI                   ; разрешить прерывания
        CLD                   ; указатель направления - вперед
        PUSH    ES
        PUSH    DS            ; сохранение регистров
        PUSH    DX
        PUSH    CX
        PUSH    BX
        PUSH    SI
        PUSH    DI
        PUSH    AX            ; сохранить АХ
        MOV     AL,AH         ; сохранить старший байт в AL
        XOR     AH,AH         ; очистить АН
        SAL     AX,1          ; умножить на 2 для просмотра таблицы
        MOV     SI,AX         ; поместить в SI для ветвления
        CMP     AX,M1L        ; проверка АХ на <= 15 (граница кода)
        JB      M2            ; переход по допустимому значению
        POP     AX            ; вернуть параметр
        JMP     VIDEO_RETURN  ; выход, АХ неверно
M2:     MOV     AX,DATA
        MOV     DS,AX
        MOV     AX,START_BUFFER   ; сегмент для цветного адаптера
        MOV     ES,AX         ; установить начало области памяти ВИДЕО
        POP     AX            ; восстановить значение
        MOV     AH,CRT_MODE          ; получить текущий режим в АХ
        JMP     WORD PTR CS:[SI+OFFSET M1]
VIDEO_IO        ENDP
;--------------------------------------------------------
;SET_MODE
;       Эта программа инициализирует параметры
;       выбора режима. Экран очищается.
;Вход
;       (AL)= содержит заданный режим (0-7)
;Выходных данных нет
;
;-------------------------------------------------------
;-------- COLUMNS
; Tаблицы параметров выбранных режимов
VIDEO_PARMS     LABEL        BYTE
M8      LABEL   BYTE
        DB      CHAR_40_MODE, CHAR_40_MODE, CHAR_80_MODE, CHAR_80_MODE
        DB      MED_RES_MODE, MED_RES_MODE, HIGH_RES_MODE, HIGH_RES_MODE
M9      LABEL   WORD    ; таблица регистрации размеров
        DW      2048    ; 40x25
        DW      4096    ; 80x25
        DW      16384   ; графика
        DW      16384   ;
SET_MODE        PROC   NEAR
        PUSH    AX           ; сохранить регистр AX
        CMP     AL, 8        ; проверка границы параметра
        JB      MM3          ; переход, если <
CURSOR_BLINK:
        CMP     CURSOR_ON,0FH   ; проверка флага установки курсора
        JZ      MMM15
;        TEST    CURSOR_ON,0FFH
;        JNZ     CUR1
;        TEST    CURSOR_MODE,0FFH
;        JZ      MMM15
CUR1:   MOV     AX,EXTRA_BUFFER ; конец сегмента видео-буфера (16К)
        MOV     ES,AX
        CALL    M21
        NOT     CURSOR_ON
        POP     AX           ; востановить регистр AX
MMM15:  JMP     VIDEO_RETURN  ; Возврат из ВИДЕО
MM3:
        CLI
        MOV     AH,AL
        IN      AL,TRAP_A     ; запретить прерывания
        MOV     AL,AH         ; сброс тиггера HMI (ловушка)
        MOV     SI,AX         ; сохранить режим в AL
        MOV     CRT_MODE,AL   ; сохранить режим и SL
        MOV     BX, OFFSET M8
        XLAT    CS:M8
        OUT     SCR_MODE,AL   ; ветвление
        MOV     ADDR_6845,REG3D4  ; установить режим
;
;-------Разрешение/запрет цвета (вит D7)
;
        CMP     AH,3
        JNZ     ED1
        MOV     AL,40H       ; Цветной
        JMP     ED3
ED1:    CMP     AH,2
        JNZ     ED2
        MOV     AL,40H
        JMP     ED3
ED2:    MOV     AL,80H       ; Черно/белый
ED3:    OUT     P6A,AL
;
;-------Заполнение и очистка области регенрации
;
        XOR DI,DI             ; Установить режим для регенирации
        MOV  CRT_START,DI     ; Начальный адрес
        MOV     CX,8192       ; Число слов в буфере регенирации
        CMP     AH,4          ; Проверка на графику
        JAE     M12           ; Не графические режимы
        CALL    NMI_DISABLE   ; Запрет NMI на время очистки
        MOV     AX,0720H      ; Символ заполнения для текстовых режимов
        PUSH    CX
        REP     STOSW         ; Очистка буфера для текстовых режимов
        POP     CX
        CALL    NMI_ENABLE    ; Разрешить NMI
M12:                          ; Очистка буфера регенирации
        XOR     AX,AX         ; Заполнение для графических режимов
        REP     STOSW         ; Очистка области регенирации
        MOV     ACTIVE_PAGE,AL         ; Установить активную страницу 0
;
;------Разрешение ВИДЕО
;
        MOV     CURSOR_MODE,607H       ; Установить текущий режим курсора
        MOV     CRT_MODE_SET,29H       ; Сохранить значение
        MOV     AL, 80
        MOV     BX,SI
;
;------Определить число колонок для любого видео
;      и число, используемое для TTY интерфейса
;
        TEST    BL,2
        JNE     M13
        SAR     AX,1
M13:
        MOV     CRT_COLS,AX          ; Числоколонок на экране (40 или 80)
;
;-------Установить позицию курсора (очистить курсор для графического режима)
;
        AND     SI,06H        ; Смещение индекса по таблице размеров
        MOV     CX,CS:[SI+OFFSET M9]   ; Размер для очистки
        MOV     CRT_LEN,CX    ; Сохранить размер (не используется для ч/б)
        MOV     CX,8          ; Очистить все позиции курсора
        MOV     DI,OFFSET CURSOR_POSN
        PUSH    DS            ; Установить сегмент
        POP     ES            ; Адресация для 1К байта таблицы
        XOR     AX,AX
        REP     STOSW         ; Заполнить пулями
        MOV     CURSOR_ON,AL  ; Указать, что курсор не установлен
;
;------Установка регистра сканирования------
;
        MOV     AL,3DH        ; Значение 3DN для всех режимов, кроме 640*200
        CMP     BL,6          ; Режим 640*200 Ч/Б
        JNZ     M14           ; Если нет, то возврат
        MOV     AL,3FH        ; Если да, то установить 3FH
M14:                          ; Выдать скоректированое значение в порт 3D9
        MOV     CRT_PALLETTE,AL ; Сохранить значение для будушего использования
;
;------Инициализация вектора NMI
;
        XOR     AX,AX
        MOV     ES,AX
        MOV     AX,OFFSET NMI_SERVICE
        MOV     DI,8
        STOSW
        PUSH    CS
        POP     AX
        STOSW
        POP     AX         ;востановление регистра AX
;
;------Нормальный возврат из всех ВИДЕО-возвратов
;
VIDEO_RETURN:
        POP     DI
        POP     SI
        POP     BX
M15:                          ; Возврат ВИДЕО
        POP     CX
        POP     DX
        POP     DS
        POP     ES            ; Восстановление регистров
        IRET                  ; все сделано, возврат
SET_MODE        ENDP
;-------------------------------------------------------------------------
; SET_CTYPE
;       Эта программа устанавливает размер курсора
; Вход
;       (CX)-Содержит размер курсора CH-верхняя граница CL-нижняя граница
;---------------------------------------------------------------------------
SET_CTYPE       PROC   NEAR
        MOV     CURSOR_MODE,CX       ; Сохранить в области данных
        JMP     VIDEO_RETURN
SET_CTYPE       ENDP
;---------------------------------------------------------------------------
; SET_CPOS
;       Эта пограмма устанавливает текущую позицию курсора
;       По заданным X-Y коофицентам
; Вход
;       DX-строка, колонка нового положения
;       BH-страница экрана для курсора
;--------------------------------------------------------------------------
SET_CPOS        PROC   NEAR
        PUSH    AX           ; сохранить регистр AX
        CMP     DH,25
        JNB     MM171
        MOV     CL,BH                ; Страница
        XOR     CH,CH                ; Установить счетчик цикла
        SAL     CX,1                 ; Смещение слова
        MOV     SI,CX                ; Используем индексный регистр
        CMP     ACTIVE_PAGE,BH       ; Активная страница
        JNE     MM17
                                     ; На возврат
M17:
        CMP     CRT_MODE,4           ; Графический режим
        JAE     MM17                 ; Да, переход
        MOV     AX,EXTRA_BUFFER
        MOV     ES,AX
        MOV     AX,DATA
        MOV     DS,AX
;        PUSHF                        ; Сохранить флаги
        CLI                          ; Запретить прерывания
        CMP     CURSOR_ON,0FFh        ; Если курсор сброшен инчего не делать
        JNE     M125                   ; Переход, если установлен
        CALL    M21                   ; Инвертировать курсор
M125:   MOV     CURSOR_ON,00          ; Сбросить флаг курсора
;        POPF                         ; Восстановить флаги
        mov     cursor_count,2
MM17:
        MOV     [SI+OFFSET CURSOR_POSN],DX     ; Сохранить указатель
        STI                                    ; Возврат
MM171:
        POP     AX         ;востановление регистра AX
        JMP     VIDEO_RETURN
SET_CPOS        ENDP
;
;-----Запретить/разрешить мерцание курсора
;
BLINK_DISABLE  PROC    NEAR
        CLI
        PUSH   AX
        MOV    AX,DATA
        MOV    DS,AX
        MOV    CURSOR_ON,0Fh         ; Запретить мерцание курсора
        POP    AX
        RET
BLINK_DISABLE  ENDP
BLINK_ENABLE  PROC    NEAR
        CLI
        PUSH   AX
        MOV    AX,DATA
        MOV    DS,AX
        MOV    CURSOR_ON,0           ; Разрешить мерцание курсора
        POP     AX
        RET
BLINK_ENABLE  ENDP
;
;-----Получить позицию курсора, AX содержит стр/колонку
;
REMOVE_CURSOR  PROC    NEAR          ;AX содержат строку/колонку для курсора
        PUSH   AX
        MOV    AX,DATA
        MOV    DS,AX
;        PUSHF                        ; Сохранить флаги
        CLI                          ; Запретить прерывания
        CMP    CURSOR_ON,0FFh        ; Если курсор сброшен инчего не делать
        JNE    M25                   ; Переход, если установлен
        CALL   M21                   ; Инвертировать курсор
M25:    MOV    CURSOR_ON,00          ; Сбросить флаг курсора
;        POPF                         ; Восстановить флаги
        POP    AX
        RET
REMOVE_CURSOR  ENDP
M21:    ; Инвертировать курсор на экране
        PUSH   SI                    ; сохранить SI
        CALL   S26                   ; Вычислить адрес курсора
        ADD    AX,050H               ;
        MOV    SI,AX                 ; Заслать адрес курсора в SI
        TEST   CRT_MODE,2            ; Режим 80x25 ?
        JNZ    M24
        SHL    SI,1                  ; Для 40x25, умножим адрес на 2
        ADD    SI,050H
        NOT    ES: BYTE PTR [SI]     ; инвертировать 4 байта курсора
        INC    SI
        NOT    ES: BYTE PTR [SI]
        ADD    SI,2000H
        NOT    ES: BYTE PTR [SI]
        DEC    SI
M21A:   NOT    ES: BYTE PTR [SI]
        POP    SI                    ; Востановить SI
        RET
M24:    ADD    SI,0A0H
        NOT    ES: BYTE PTR [SI]     ; Для режима 80x25,
        AND    ES: BYTE PTR [SI],07FH  ;\
        ADD    SI,2000H              ; инвертируем 2 байта курсора
        OR     ES: BYTE PTR [SI],80H  ;\
        JMP    M21A
;-------------------------------------------------------------------------
; READ_CURSOR
; Прочесть текущее положение курсора
;        та программа читает текущее значение положения курсора
;       форматирует и возвращает вызывающей программе
; Вход:
;       BH-Номер страницы для курсора
; Выход:
;       DX-Строка/колонка текущей позиции курсора
;       CX-Текущий режим курсора
;--------------------------------------------------------------------------
READ_CURSOR     PROC   NEAR
        MOV     BL,BH
        XOR     BH,BH
        SAL     BX,1                 ; Смещение слова
        MOV     DX,[BX+OFFSET CURSOR_POSN]  ; Позиция курсора для страницы ВН
        MOV     CX,CURSOR_MODE
        POP     DI
        POP     SI
        POP     BX
        POP     DS                   ; CX и DX не востараиливаем
        POP     DS
        POP     DS
        POP     ES
        IRET
READ_CURSOR     ENDP
;-------------------------------------------------------------------------
; ACT_DISP_PAGE
;       Эта программа устанавливает активную страницу ВИДЕО,
;       используя заполнение видеобуфера для управления ВИДЕО
; Вход
;       AL-Hомер новой страницы
; Выход
;       Контроллер сбрасывается для установки новой страницы
;--------------------------------------------------------------------------
ACT_DISP_PAGE   PROC   NEAR
        PUSH    AX
        TEST    CRT_MODE,4       ; Графика 320Х200
        JNZ     A_D_RET
        MOV     BP,ES            ; Сохранить величину 0B800h
        MOV     BX,EXTRA_BUFFER
        MOV     ES,BX
        CALL    REMOVE_CURSOR    ; Убрать курсор с экрана
        MOV     ACTIVE_PAGE,AL   ; Установить новую страницу
;
;-------Вычислить новый начальный адрес видеобуфера
;
        CBW                      ; Преобразовать байт в слово
        MUL     CRT_LEN          ; Умножить на размер экрана
        MOV     CRT_START,AX     ; Начальный адрес страницы
;
;-------Установить указатели
;
        MOV     SI,AX            ; Указатель источника (изображения)
        XOR     DI,DI            ; Указатель приемника
;
;-------Визировать новую страницу
;
        MOV     CL,25            ; Для 25 строк
BEG:
        MOV     CH,BYTE PTR [CRT_COLS] ;Для 40 или 80 колонок
        PUSH    DS               ; Сохранить сегмент данных
COL:
        MOV     DS,BP            ; Установить 0B800h в DS
        LODSW                    ; Чтение символа/атрибута
        MOV     BL,AH            ; Сконировать атрибут
        XOR     AH,AH
        POP     DS               ; Востановить сегмент данных
        PUSH    DS               ; Снова сохранить DATA
        PUSH    CX               ; Сохранить счетчик
        PUSH    SI               ; Сохранить указатели
        PUSH    DI
        MOV     CX,1             ; Только для 1 символа
        CALL    S1B              ; Нарисовать изображение
        POP     DI
        INC     DI
        POP     SI               ; Востановить указатели
        POP     CX               ; Востановить счетчик
        DEC     CH               ; следующая колонка
        JNZ     COL
        ADD     DI,120           ; Установить указатель на следующую строку
        POP     DS               ; Востановить сегмент данных
        TEST    CRT_MODE,2       ; 40X25 ?
        JZ      A_D_NEXT         ; Да,
        ADD     DI,120           ; Прибавить
A_D_NEXT:
        LOOP    BEG              ; На следующую строку
A_D_RET:
        POP     AX
        JMP     VIDEO_RETURN
ACT_DISP_PAGE   ENDP
;-------------------------------------------------------------------------
;SET COLOR
;       Эта программа устанавливает цветную политру для режимов
;       среднего разрешения
;Вход
;       (BH) HAS COLOR ID
;                  BH=0-Цвет фона устанавливается
;                       Для цвета 0 по мл. 5 битам BL (0-31),
;                  BH=1-Выбор политры на основе
;                       мл. бита BL:
;                             0=Зеленый, красный, желтый для цветов 1,2,3
;                             1=Голубой, циан, фиолетовый для цветов 1,2,3
;       (BL) HAS THE COLOR VALUE TO BE USED
; Выход
;       Установка цветовой палитры
;---------------------------------------------------------------------------
SET_COLOR       PROC   NEAR
        PUSH    AX
        MOV     AH,CRT_PALLETTE      ; Значение текущей политры
        IN      AL,SCR_MODE          ; Режим экрана
        OR      BH,BH                ; Цвет 0 (ВН=0)
        JNZ     M20                  ; Переход на цвет 1 (ВН=1)
;
;------Обработка цвета 0-установка цвета фона
;
        MOV     BH,BL
        AND     AX,0E0C8H            ; Получить текущие мл. 5 битов
        AND     BX,01F37H            ; Старшие 3 бита входного знчения
        OR      AX,BX                ; Получить значение в режиме
M19:                                 ; Вывод политры
        MOV     CRT_PALLETTE,AH      ; Сохранить значение цвета
        OUT     SCR_MODE,AL
        POP     AX
        JMP     VIDEO_RETURN
;
;------Обработка цвета 1-установка требуемой политры
;
M20:
        AND     AX,0EFEFH            ; Сбросить бит выбора политры
        SHR     BL,1                 ; Проверить младший бит BL
        JNC     M19                  ; Уже сделано
        OR      AX,1010H             ; Установить бит выбора палитры
        JMP     M19
SET_COLOR       ENDP
;--------------------------------------------------------------------------
;VIDEO STATE
; Программа возвращает текущее состаяние ВИДЕО в AX
; AH = Количество колонок
; AL = Текущий режим ВИДЕО
; BH = Номер текущей активной страницы
;----------------------------------------------------------------------------
VIDEO_STATE     PROC   NEAR
        MOV     AH,BYTE PTR CRT_COLS ; Получить число колонок
        MOV     AL,CRT_MODE          ; Текущий режим
        MOV     BH,ACTIVE_PAGE       ; Получить текущую активную странцу
        POP     DI                   ; Востановить режим
        POP     SI
        POP     CX
        JMP     M15                  ; Возврат к вызывающей программе
VIDEO_STATE     ENDP
;----------------------------------------------------------------------------
; POSITION
;       Эта программа вычисляет адрес буфера
;       регенирации символов в текстовом режиме
;Вход
;       AX = Строка, колонка позиции
;Выход
;       AX = Смещение позиции символа в буфере регенерации
;----------------------------------------------------------------------------
POSITION        PROC   NEAR
        PUSH    BX                   ; Сохранить регистр
        MOV     BX,AX
        MOV     AL,AH                ; строку в AL
        MUL     BYTE PTR CRT_COLS    ; Определить число байт для строки
        XOR     BH,BH
        ADD     AX,BX                ; Добавить значение колонки
        SAL     AX,1                 ;* 2 для байтов атрибутов
        POP     BX
        RET
POSITION        ENDP
NMI_DISABLE PROC NEAR
        PUSH    AX
        IN      AL,SCR_MODE
        OR      AL,8                 ; установить бит разрешения NMI
        OUT     SCR_MODE,AL
        POP     AX
        RET
NMI_DISABLE ENDP
NMI_ENABLE PROC NEAR
        PUSH    AX
        IN      AL,SCR_MODE
        AND     AL,0F7H              ; Сбросить бит разрешения NMI
        OUT     SCR_MODE,AL
        POP     AX
        RET
NMI_ENABLE ENDP
;------------------------------------------------------------------------------
;SCROLL UP
;       Эта программа перемещает блок символов
;       вверх по экрану (прокрутка)
;Вход
;       (AH)= Текуший режим
;       (AL)= Количество сдвигаеьых строк
;       (CX)= Строка/колонка-кординаты левого угла окна
;       (DX)= Строка/колонка-кординаты нижнего правого угла окна
;       (BH)= Атрибуты символа пробела (для освобождаемых строк)
;       (DS)= Сегмент данных
;       (ES)= Сегмент буфера регенирации
;Выход
;       NONE-Модифицырованый буфер регенирации
;------------------------------------------------------------------------------
        ASSUME  CS:CODE,DS:DATA,ES:DATA
SCROLL_UP       PROC   NEAR
        MOV     BL,AL                ; Сохранить счетчик строк
        CMP     AH,4                 ; Проверка на графический режим
        JC      N1                   ; Обрабатывается отдельно
        JMP     GRAPHICS_UP          ; На графические режимы
N1:                                  ; Продолжить текст
        PUSH    AX
        PUSH    BX
        PUSH    CX
        PUSH    DX
        PUSH    DS
        CALL    NMI_DISABLE          ; Разрешить NMI
        PUSH    BX                   ; Сохранить атребут заполнения
        MOV     AX,CX                ; Верхний левый угол окна
        CALL    SCROLL_POSITION      ; Установить для прокрутки
        JZ      N7                   ; Поле пробела (заполнения)
        ADD     SI,AX                ; С адреса (начало)
        MOV     AH,DH                ; Число строк в окне
        SUB     AH,BL                ; Число передвигаемых строк (блок)
N2:                                  ; Цикл по строкам
        CALL    N10                  ; Сдвинуть одну строку
        ADD     SI,BP
        ADD     DI,BP                ; Указатель на следующую строку в блоке
        DEC     AH                   ; Счетчик строк сдвига
        JNZ     N2                   ; Цикл по строкам
N3:                                  ; Вход очистки
        POP     AX                   ; Востановление атрибута в AH
        MOV     AL,' '               ; Заполнение пробелами
N4:                                  ; Цикл очистки
        CALL    N11
        ADD     DI,BP                ; Указатель на следующую строку
        DEC     BL                   ; Счетчик строк прокрутки
        JNZ     N4                   ; Цикл очистки
N5:                                  ; Конец прокрутки
        POP     DS
N6:                                  ; Возврат из ВИДЕО
        CALL    NMI_ENABLE           ; Возвращение NMI
        POP     DX
        POP     CX
        POP     BX
        MOV     AX,EXTRA_BUFFER
        MOV     ES,AX
        POP     AX
        MOV     BH,0                 ; Поле заполнения
        PUSH    AX
        CALL    REMOVE_CURSOR        ; Переместить курсор
        CALL    BLINK_DISABLE        ; Запретить мерцание
        CALL    UP_GRAPHICS
SCROLL_RET:
        CALL    BLINK_ENABLE         ; Разрешить мерцание
        POP     AX
        JMP     VIDEO_RETURN         ; Возврат из ВИДЕО
N7:                                  ; Поле заполнения
        MOV     BL,DH                ; Получить счетчик строк
        JMP     N3                   ; На очистку этой области
SCROLL_UP       ENDP
;------Общая часть обработки заданной прокрутки
SCROLL_POSITION PROC NEAR
N9:     CALL    POSITION             ; Преобразовать указатель области регенирации
        ADD     AX,CRT_START         ; Смещение активной страницы
        MOV     DI,AX                ; Прокрутка до адреса (конец)
        MOV     SI,AX                ; Прокрутка с адреса (начало)
        SUB     DX,CX                ; DX=строка/колонка в блоке
        INC     DH
        INC     DL                   ; Инкремент до 0
        XOR     CH,CH                ; Очистить старший байт счетчика
        MOV     BP,CRT_COLS          ; Получить число колонок экрана
        ADD     BP,BP                ; Удвоить для байта атрибута
        MOV     AL,BL                ; Получить счетчик строк
        MUL     BYTE PTR CRT_COLS    ; определить смещение начального адреса
        ADD     AX,AX                ; Удвоить для байта атрибута
        PUSH    ES                   ; Установить адресацию буфера регенирации
        POP     DS                   ; Для обоих указателей
        CMP     BL,0                 ; 0-Конец прокрутки области заполнения
        RET                          ; Возврат с установленными флагами
SCROLL_POSITION ENDP
;-----Сдвинуть строку (прокрутка)
N10     PROC    NEAR
        MOV     CL,DL                ; Получить число колонок для сдвига
        PUSH    SI
        PUSH    DI                   ; Сохранить начальные адреса
        REP     MOVSW                ; Сдвинуть строку на экране
        POP     DI
        POP     SI                   ; Востановить адреса
        RET
N10     ENDP
;-----Очистить строку (прокрутка)
N11     PROC    NEAR
        MOV     CL,DL                ; Получить число колонок для прокрутки
        PUSH    DI
        REP     STOSW                ; Засылка символа заполнения
        POP     DI
        RET
N11     ENDP
;------------------------------------------------------------------------
;SCROLL_DOWN
;       Эта программа перемещает символ с указаного блока
;       вниз по экрану (прокрутка) заполняя верхние (освободившиеся)
;       строки заданным символом
;Вход
;       (AH) = Текущий режим
;       (AL) = Количество строк прокрутки
;       (CX) = Верхний левый угол окна
;       (DX) = Нижний правый угол окна
;       (BH) = Символ заполнения
;       (DS) = Сегмент данных
;       (ES) = Сегмент буфера регенирации
;Выход
;       Модифицированное содержимое экрана
;---------------------------------------------------------------------------
SCROLL_DOWN     PROC   NEAR
        STD                          ; Направление для прокрутки вниз
        MOV     BL,AL                ; Счетчик строк в BL
        CMP     AH,4                 ; Проверка на графику
        JC      N12
        JMP     GRAPHICS_DOWN        ; На графические режимы
N12:                                 ; Продолжить (текст)
        PUSH    AX
        PUSH    BX
        PUSH    CX
        PUSH    DX
        PUSH    DS
        CALL    NMI_DISABLE          ; Запретить NMI
        PUSH    BX                   ; Сохранить атрибут в BH
        MOV     AX,DX                ; Нижний правый угол окна
        CALL    SCROLL_POSITION      ; Получить область регенерации (параметры прокрутки
        JZ      N16
        SUB     SI,AX                ; Адрес начала
        MOV     AH,DH                ; Получить общее число строк
        SUB     AH,BL                ; Счетчик сдвигов прокрутки
N13:
        CALL    N10                  ; Сдвинуть одну строку (прокрутка)
        SUB     SI,BP
        SUB     DI,BP
        DEC     AH
        JNZ     N13
N14:
        POP     AX                   ; Восстановить атрибут  в АН
        MOV     AL,' '
N15:
        CALL    N11                  ; Очистить одну строку (прокрутка)
        SUB     DI,BP                ; На следующую строку
        DEC     BL
        JNZ     N15
                                     ; Возврат из ВИДЕО
        POP     DS
        CALL    NMI_ENABLE           ; Разрешить NMI
        POP     DX
        POP     CX
        POP     BX
        MOV     AX,EXTRA_BUFFER      ; Адрес буфера регенерации
        MOV     ES,AX
        POP     AX
        MOV     BH,0
        PUSH    AX
        CALL    REMOVE_CURSOR
        CALL    BLINK_DISABLE
        CALL    DOWN_GRAPHICS
        JMP     SCROLL_RET
N16:
        MOV     BL,DH
        JMP     N14
SCROLL_DOWN     ENDP
;---------------------------------------------------------------------------
;READ_AC_CURRENT
;       Эта программа считывает символ и атрибут в текущей позиции курсора
;Вход
;       (AH) = Текущий режим
;       (BH) = Номер страницы (только для текстовых режимов)
;       (DS) = Сегмент данных
;       (ES) = Сегмент буфера регенирации
;Выход
;       (AL) = Прочитанный символ
;       (AH) = Прочитанный атрибут
;----------------------------------------------------------------------------
        ASSUME  CS:CODE,DS:DATA,ES:DATA
READ_AC_CURRENT PROC    NEAR
        CMP     AH,4                 ; Это графика ?
        JC      P1
        JMP     GRAPHICS_READ        ; На чтение в графических режимах
P1:                                  ; Продолжить (текст)
        CALL    FIND_POSITION        ; Определить позицию курсора для страницы
        MOV     SI,BX                ; Установить адресацию в SI
        PUSH    ES                   ; Установить: cегмент данных = экстра-сегмент
        POP     DS                   ; Получить символ/атрибут
        LODSW                        ; Возврат
        JMP     VIDEO_RETURN
READ_AC_CURRENT ENDP
FIND_POSITION   PROC   NEAR
        MOV     CL,BH                ; Определение позиции курсора для страницы
        XOR     CH,CH                ; Номер текущей страницы в cх
        MOV     SI,CX                ; Передать в SI как индекс, умноженный
        SAL     SI,1                 ; на 2 (слово смещения)
        MOV     AX,[SI+ OFFSET CURSOR_POSN]    ; Получить строку/колонку для этой страни
        XOR     BX,BX                ; Начальный адрес = 0
        JCXZ    P5                   ; Страница найдена
P4:                                  ; Цикл по страницам
        ADD     BX,CRT_LEN           ; Длина буфера
        LOOP    P4
P5:                                  ; Страница найдена
        CALL    POSITION             ; Определить ячейку в области регенерации
        ADD     BX,AX                ; Прибавить к началу области
        RET
FIND_POSITION   ENDP
;---------------------------------------------------------------------------
;WRITE_AC_CURRENT
;       Эта программа записывает символ и атрибут в текущую позицию курсора
;Вход:
;       (AH) = Текущий режим
;       (BH) = Номер страницы
;       (CX) = Счетчик (количество повторений символа)
;       (AL) = Символ для записи
;       (BL) = Aтрибут символа для записи (или цвет для графики)
;       (DS) = Сегмент данных
;       (ES) = Сегмент области (буфера) регенерации
;---------------------------------------------------------------------------
WRITE_AC_CURRENT        PROC  NEAR
        CMP     AH,4                 ; Графика ?
        JC      P6
        JMP     GRAPHICS_WRITE       ; На графические режимы
P6:                                  ; продолжение (текст)
        PUSH    AX
        PUSH    BX
        PUSH    CX
        PUSH    DS
        CALL    NMI_DISABLE          ; Запретить NMI
        MOV     AH,BL                ; Получить атрибут в AH
        PUSH    AX                   ; Сохранить атрибут/символ
        PUSH    CX                   ; Счетчик записи
        CALL    FIND_POSITION        ; Определить позицию курсора для страницы
        MOV     DI,BX                ; Адрес в DI
        POP     CX                   ; Восстановить счетчик
        POP     AX                   ; Символ/атрибут
        REP     STOSW                ; Записать символ/атрибут столько раз,
                                     ; сколько требуется (сх)
        CALL    NMI_ENABLE           ; Разрешить NMI
        POP     DS
        POP     CX
        POP     BX
        MOV     AX,EXTRA_BUFFER      ; Пересылка в буфер регенерации заданной страницы
        MOV     ES,AX
        POP     AX
        CMP     ACTIVE_PAGE,BH
        JE      P7A
        JMP     VIDEO_RETURN
P7A:
        PUSH    AX
        CALL    REMOVE_CURSOR
        CALL    WRITE_GRAPHICS
        JMP     SCROLL_RET
WRITE_AC_CURRENT        ENDP
;----------------------------------------------------------------------------
;WRITE_C_CURRENT
;       Эта программа записывает символ в текущую позицию курсора,
;       атрибут не изменяется. В графике BL содержит атрибут цвета.
;Вход:
;       (AH) = Текущий режим
;       (BH) = Номер страницы
;       (CX) = Счетчик (количество повторений символа)
;       (AL) = Символ для записи
;       (DS) = Сегмент данных
;       (ES) = Сегмент области (буфера) регенерации
;OUTPUT
;       NONE
;-----------------------------------------------------------------------------
WRITE_C_CURRENT PROC    NEAR
        CMP     AH,4                 ; Графика ?
        JC      P10
        JMP     GRAPHICS_WRITE       ; На графические режимы
P10:
        PUSH    AX
        MOV     AH,BH                ; Сохранить номер страницы
        CALL    NMI_DISABLE          ; Запретить NMI
        PUSH    AX                   ; Сохранить в стеке
        PUSH    CX                   ; счетчик записи
        CALL    FIND_POSITION        ; Определить позицию курсора для страницы
        MOV     DI,BX                ; Адрес в DI
        POP     CX                   ; Cчетчик записи
        POP     AX                   ; BL = символ для записи
P11:                                 ; цикл записи
        STOSB                        ; Записать символ
        CMP     ACTIVE_PAGE,AH
        JNE     PP11
        MOV     BL,ES:[DI]
        PUSH    ES
        PUSH    DS
        PUSH    CX
        PUSH    DI
        PUSH    AX
        MOV     DX,EXTRA_BUFFER
        MOV     ES,DX
        MOV     CX,1
        CALL    REMOVE_CURSOR
        CALL    WRITE_GRAPHICS
        POP     AX
        POP     DI
        POP     CX
        POP     DS
        POP     ES
pp11:
        INC     DI                   ; Пропустить атрибут
        LOOP    P11                  ; Цикл записи символа по счетчику
        CALL    NMI_ENABLE
        POP     AX
        JMP     VIDEO_RETURN
WRITE_C_CURRENT ENDP
INCLUDE INT10_BN.ASM
;----------------------------------------------------------------------------
; READ DOT  --  WRITE DOT
;Эта программа ссчитывает/записывает точку (пиксель) в указанной ячейке
;Вход:
;  DX -номер элементарной строки (0-199)
;  CX -номкр элементарной колонки (0-639)
;  AL - точка для вывода (1,2 или 4 бита в зависимости от режима записи точки,
;       выровнены по правому краю). Если бит 7=1, то необходимо выполнить
;       операцию XOR над AL и текущим значением точки.
;  DS - сегмент данных
;  ES - сегмент (области) буфера регенерации
;Выход:
;  AL - значение точки, выровненное по правому краю
;----------------------------------------------------------------------------
        ASSUME CS:CODE,DS:DATA,ES:DATA
READ_DOT        PROC   NEAR   ;Чтение точки
        CALL    R3            ;Определить позицию байта точки
        MOV     AL,ES:[SI]    ;Получить байт
        AND     AL,AH         ;Маска на другие биты в байте
        SHL     AL,CL         ;Выровнять значение
        MOV     CL,DH         ;Получить число битов
        ROL     AL,CL         ;Выровнять по правому краю результат
        JMP     VIDEO_RETURN  ;Возврат из ВИДЕО
READ_DOT        ENDP
WRITE_DOT       PROC   NEAR   ;Запись точки
        PUSH    AX            ;Сoхранить значение точки
        PUSH    AX            ;Дважды
        CALL    R3            ;Определить позицию байта точки
        SHR     AL,CL         ;Сдвиг для установки битов при выходе
        AND     AL,AH         ;Сбросить остальные биты
        MOV     CL,ES:[SI]    ;Получить текущий байт
        POP     BX            ;Восстановить флаг для XOR (бит 7)
        TEST    BL,80H        ;Установлен?
        JNZ     R2            ;Да, операция XOR для точки
        NOT     AH            ;Установить маску для передачи указанных битов,
                              ; или новое значение этих битов
        AND     CL,AH
        OR      AL,CL
R1:
        MOV     ES:[SI],AL    ;Записать байт в память
        POP     AX
        JMP     VIDEO_RETURN  ;Возврат из ВИДЕО
R2:                           ;XOR_DOT
        XOR     AL,CL         ;XOR для точки
        JMP     R1            ;Конец записи точки
WRITE_DOT       ENDP
;--------------------------------------------------------------------------
;Эта программа определяет относительный адрес байта (внутри буфера
;регенерации), по которому должна быть считана/записана точка с заданными
;координатами в графических режимах
;Вход:
; DX - номер элементарной строки (0-199)
; CX - номер колонки (0-639)
;Выход:
; SI - смещение байта точки в буфере
; AH - маска для выделения битов точки
; CL - количество сдвигов битов маски в AH
; DH - число бит значения точки
;-----------------------------------------------------------------------------
R3      PROC    NEAR
        PUSH    BX                   ;Сохранить регистры
        PUSH    AX
;
;------Определение 1-го байта заданной строки умножением на 40.
;      Младший бит строки определяет четно/нечетную 80-байтовую строку
;
        MOV     AL,40
        PUSH    DX                   ;Сохранить значение строки
        AND     DL,0FEH              ;Сброс бита чет/нечет
        MUL     DL                   ;AX содержит адрес 1-го байта указанной
                                     ;строки
        POP     DX                   ;Восстановить значение
        TEST    DL,1                 ;Проверить на чет/нечет
        JZ      R4                   ;Переход, если строка четная
        ADD     AX,2000H             ;Смещение для нахождения нечетных строк
R4:                                  ;Четная строка
        MOV     SI,AX                ;Передать указатель в SI
        POP     AX                   ;Восстановить значение
        MOV     DX,CX                ;Значение колонки в DX
;
;-------Определение параметров графических режимов для непосредственного
;       воздействия
;Установить регистры в соответствии с режимом:
;  CH - маска для младшей части адреса колонки (3/2 для высокого/среднего
;       разрешения)
;  CL - количество битов адреса в значении колонки (3/2 для в/с )
;  BL - маска выбора битов из указанного байта (80H/C0H для в/с )
;  BH - количество бит, определяющее точку(1/2 для в/с)
        MOV     BX,2C0H
        MOV     CX,302H              ;Установка параметров для режима среднего
                                     ; разрешения
        CMP     CRT_MODE,6
        JC      R5                   ;Обработка для среднего разрешения
        MOV     BX,180H
        MOV     CX,703H              ;Установить параметры для режима высокого
                                     ; разрешения
;
;------Определение смещения бита в байте по маске колонки
R5:
        AND     CH,DL
;
;------Определение смещения байта по этому биту в колонке
;
        SHR     DX,CL                ;Сдвиг для коррекции
        ADD     SI,DX                ;Инкремент указателя
        MOV     DH,BH                ;Получить количество битов в DH
;
;------Умножить BH (значащие биты в байте) на CH (смещение бита)
;
        SUB     CL,CL                ;Очистить
R6:
        ROR     AL,1                 ;Выравнивание значения в AL
                                     ;(Для записи)
        ADD     CL,CH                ;Прибавить значение смещения бита
        DEC     BH                   ;Счетчик цикла
        JNZ     R6                   ;На выход, CL содержит счетчик сдвигов
                                     ;Для обрабатываемых битов
        MOV     AH,BL                ;Получить маску в AH
        SHR     AH,CL                ;Сдвинуть маску для коррекции
        POP     BX                   ;Восстановить регистр
        RET                          ;Возврат с установленными параметрами
R3      ENDP
;----------------------------------------------------------------------------
;SCROLL UP
;  Эта программа перемещает блок информации вверх по экрану (для графики)
;Вход:
; CH,CL -левый верхний угол окна прокрутки,
; DH,DL -нижний правый угол окна прокрутки,
; BH -   код заполнителя для освобождающихся строк
; AL -   количество строк прокрутки (AL=0 означает очистку всего окна)
; DS -   сегмент данных
; ES -   сегмент буфера регенерации
;----------------------------------------------------------------------------
GRAPHICS_UP     PROC   NEAR
        CALL    UP_GRAPHICS
        JMP     VIDEO_RETURN
UP_GRAPHICS:
        MOV     BL,AL                ;Число строк в BL
        MOV     AX,CX                ;Позиция левого верхнего угла в AX
;------Использовать программу для позиционирования
;      Адрес возвращается умноженный на 2 для коррекции значения
        CALL    GRAPH_POSN
        MOV     DI,AX                ;Сохранить результат как адрес приемника
;
;------Определение размера окна
;
        SUB     DX,CX
        ADD     DX,101H              ;Скорректированное значение
        SAL     DH,1                 ;Умножить на 4, так-как имеем 8
                                     ; точек/символ по вертикали
        SAL     DH,1
;
;-------Определить режим
;
        test    CRT_MODE,2           ;Среднее разрешение?
        JNZ     R7                   ;Определить адрес источка для высокого
                                     ; разрешения
;
;------Прокрутка вверх (среднее разрешение)
;
        SAL     DL,1                 ;Число колонок * 2, т.к.
                                     ;  имеем 2 байта/символ
        SAL     DI,1                 ;Смещение * 2, т.к. имеем 2 байта /символ
;
;------Определить адрес источника в буфере
;
R7:                                  ;Найти источник
        PUSH    ES                   ;Получить сегменты обоих указателей
                                     ;  буфера регенерации
        POP     DS
        SUB     CH,CH                ;Очистить старший байт счетчика
        SAL     BL,1                 ;Умножить число строк на 4
        SAL     BL,1
        JZ      R11                  ;Если 0, то полная очистка окна
        MOV     AL,BL                ;Получить число строк в AL
        MOV     AH,80                ;80 на строку
        MUL     AH                   ;Определить смещение источника
        MOV     SI,DI                ;Установить источник
        ADD     SI,AX                ;Прибавить смещение к нему
        MOV     AH,DH                ;Число строк в блоке
        SUB     AH,BL                ;Определить число сдвигов
;
;------Цикл, перемещающий одну строку за один проход
;      (и четные и нечетные поля)
R8:                                  ;Цикл по строке
        CALL    R17                  ;Передвинуть одну строку
        SUB     SI,2000H-80          ;Указатель на следующую строку
        SUB     DI,2000H-80
        DEC     AH                   ;Число строк прокрутки
        JNZ     R8                   ;Продолжать, пока все пепреместятся
;
;------Заполнение освобожденных строк
R9:                                  ;Вход очистки
        MOV     AL,BH                ;Атрибут заполнения
R10:
        CALL    R18                  ;Очистка строки
        SUB     DI,2000H-80          ;Указатель на следующую строку
        DEC     BL                   ;Число строк для заполнения
        JNZ     R10                  ;Цикл очистки
        RET                 ;Все сделано

R11:                                 ;Элемент заполнения
        MOV     BL,DH                ;Установить счетчик заполнения
                                     ;  для всего окна
        JMP     R9                   ;На очистку окна
GRAPHICS_UP     ENDP

;-----------------------------------------------------------------------------
;SCROLL DOWN
;  Эа программа перемещает блок информации вниз по экрану (для графики)
;Вход:
;  CH,CL - верхний левый угол окна прокрутки
;  DH,DL - нижний правый угол окна прокрутки
;  BH -    код запаолнителя для освобождающихся строк
;  AL -    количество строк прокрутки (AL=0 означает очистку всего окна)
;  DS -    сегмент данных
;  ES -    сегмент буфера регенерации
;-----------------------------------------------------------------------------

GRAPHICS_DOWN   PROC   NEAR
        CALL    DOWN_GRAPHICS
        JMP     VIDEO_RETURN

DOWN_GRAPHICS:
        STD                          ;Установить направление
        MOV     BL,AL                ;Счетчик строк в BL
        MOV     AX,DX                ;Нижний правый угол окна в AX
;
;------Использовать подпрограмму для позиционирования.
;      Адрес возвращается умноженным на 2 для коррекции значения
;
        CALL    GRAPH_POSN
        MOV     DI,AX                ;Сохранить результат как адрес приемника
;
;------Определение размера окна
;
        SUB     DX,CX
        ADD     DX,101H              ;Скорректированное значение
        SAL     DH,1                 ;Умножить число строк на 4, т.к. имеем
                                     ; 8 точек на символ по вертикали
        SAL     DH,1
;
;------Определение режима
;
        TEST    CRT_MODE,2           ;Среднее разрешение?
        JNZ     R12                  ;Определить адрес источника для высокого
                                     ; разрешения
;
;------Проурутка вниз (среднее разрешение)
;
        SAL     DL,1                 ;Число колонок * 2, т.к. имеем 2
                                     ; байта/символ

        SAL     DI,1                 ;Смещение *2 т.к. имеем 2 байта/символ
        INC     DI                   ;Указатель на последний байт
;
;------Определение адреса источника в буфере
R12:                                 ;Адрес источника прокрутки
        PUSH    ES                   ;Оба сегмента буфера регенерации
        POP     DS
        SUB     CH,CH                ;Очистить старший байт счетчика
        ADD     DI,240               ;Указатель последней строки пикселей
        SAL     BL,1                 ;Умножить число строк на 4
        SAL     BL,1
        JZ      R16                  ;Если 0, то очистить все окно
        MOV     AL,BL                ;Число строк в AL
        MOV     AH,80                ;80 байт на строку
        MUL     AH                   ;Определить смещение источника
        MOV     SI,DI                ;Установить источник
        SUB     SI,AX                ;Вычесть смещение
        MOV     AH,DH                ;Число строк в окне
        SUB     AH,BL                ;Определить число сдвигов
;
;------Цикл, премещающий одну строку за один раз (четные и нечетные поля
;       одновременно)
R13:                                 ;Цикл по строке
        CALL    R17                  ;Сдвинуть одну строку
        SUB     SI,2000H+80          ;Перейти к следующей строке
        SUB     DI,2000H+80
        DEC     AH                   ;Число строк для прокрутки
        JNZ     R13                  ;Прдолжать, пока все переместятся
;
;------Заполнение освобожденных строк
R14:                                 ;Вход очистки
        MOV     AL,BH                ;Атрибут заполнения
R15:                                 ;Вход очистки
        CALL    R18                  ;Очистить строку
        SUB     DI,2000H+80          ;Указатель на следующую строку
        DEC     BL                   ;Число строк для заполнения
        JNZ     R15                  ;Цикл очистки
        CLD                          ;Сбросить флаг направления
        RET              ;Все сделано

R16:                                 ;Элемент заполнения
        MOV     BL,DH                ;Установить счетчик заполнения
                                     ; для всего окна
        JMP     R14                  ;На очистку окна

GRAPHICS_DOWN   ENDP

;------Программа перемещения одной строки информации

R17     PROC    NEAR
        MOV     CL,DL                ;Число байт в строке
        PUSH    SI
        PUSH    DI                   ;Сохранить указатели
        REP     MOVSB                ;Вернуть счетчик
        POP     DI
        POP     SI
        ADD     SI,2000H
        ADD     DI,2000H             ;Указатель нечетного поля
        PUSH    SI
        PUSH    DI                   ;Сохранить указатели
        MOV     CL,DL                ;Вернуть счетчик
        REP     MOVSB                ;Сдвинуть нечетное поле
        POP     DI
        POP     SI                   ;Вернуть указатели
        RET                          ;Возврат
R17     ENDP
;
;------Очистка одной строки
;
R18     PROC    NEAR
        MOV     CL,DL                ;Число байт в поле
        PUSH    DI                   ;Сохранить указатель
        REP     STOSB                ;Заслать заполнитель
        POP     DI                   ;Вернуть указатель
        ADD     DI,2000H             ;Указатель нечетного поля
        PUSH    DI
        MOV     CL,DL
        REP     STOSB                ;Заполнить нечетное поле
        POP     DI
        RET                          ;Возврат
R18     ENDP
;---------------------------------------------------------------------------
;GRAPHICS WRITE
;Эта программа записывает символ в ASCII в текущую позицию на экране
; (графические режимы)
;Вход:
; AL - символ для записи,
; BL - атрибут цвета, который должен использоваться в качестве цвета символа.
;       Если бит 7=1, то выполняется операция XOR над текущим байтом буфера
;       регенерации и заданным,
; CX - число символов для записи,
; DS - сегмент данных,
; ES - сегмент буфера регенерации
;
;GRAPHICS READ
;  Эта программа считывает символ в ASCII в текущей позиции экрана
;  преобразованием точек экрана с помощью генератора символов в код
;  (графические режимы)
;Вход:
; Нет  (0 - определяет цвет фона)
;Выход:
; AL - прочитанный символ (0, если  не найден)
;
;Для обеих программ матрицы символов (8*8 точек) хранятся в ПЗУ.
; Вторая половина кодов (128...255) - матрицы хранятся в ОЗУ. Доступ через
; парерывание INT 1FH (7CH) - указатель на таблицу.
;------------------------------------------------------------------------
        ASSUME CS:CODE,DS:DATA,ES:DATA
GRAPHICS_WRITE  PROC   NEAR
        CALL    WRITE_GRAPHICS
        JMP     VIDEO_RETURN

WRITE_GRAPHICS:
        MOV     AH,0
        PUSH    AX                   ;Сохранить код символа
;
;-------Определение позиции в буфере регенерации для засылки кодов точек
;
        CALL    S26                  ;Определить ячейку в буфере регенерации
S1A:    MOV     DI,AX                ;Указатель буфера - в DI
;
;------ Определить область для извлечения кодов точек
;
        POP     AX                   ;Восстановить код
S1B:
        CMP     AL,80H               ;Вторая половина кодов (128-255)?
        JAE     S1                   ;Да
;
;------ Матрица (изображение) есть в первой половине, содержится в ПЗУ
;
        MOV     SI,OFFSET CRT_CHAR_GEN      ;Смещение матрицы
        PUSH    CS                          ;Сохранить сегмент в стеке
        JMP     SHORT S2                    ;Определить режим
;
;------ Матрицы второй половины кодов (русские) хранятся в пользовательском ОЗУ
;
S1:                                  ;Символы расширенного набора
        SUB     AL,80H               ;Очистить источник для второй половины
        PUSH    DS                   ;Сохранить указатель данных
        SUB     SI,SI
        MOV     DS,SI                ;Установить вектор адресации
        ASSUME  DS:ABS0
        LDS     SI,EXT_PTR           ;Получить смещение таблицы
        MOV     DX,DS                ;Получить сегмент таблицы
        ASSUME  DS:DATA
        POP     DS                   ;Восстановить сегмент данных
        PUSH    DX                   ;Сохранить сегмент таблицы
;
;------ Определение графического режима операции
;
S2:
        SAL     AX,1                 ;Умножить значение кода на 8
        SAL     AX,1
        SAL     AX,1
        ADD     SI,AX                ;SI- смещение требуемого кода в таблице
        MOV     AL,CRT_MODE
        POP     DS            ;Восстановить указатель сегмента таблицы
        TEST    AL,2       ;Режим 2?
        JNZ     S201                  ;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        JMP     S7
S201:    TEST    AL,4      ;Режим 4?
        JNZ     S3
;
;------ Текстовый режим высокого разрешения
;
SS3:

        PUSH    DI            ;Сохранить указатель буфера регенерации
        PUSH    SI            ;Сохранить указатель кода
SSS:
        MOV     DH,4          ;Количество циклов
SS4:
        LODSB                 ;Получить байт по указателю в AL
        TEST    BL,78H        ;ПРИСУТСТВУЕТ интенсивность или реверс
        JNZ     SS6           ;ВЫДАТЬ СИМВОЛ В цвете
        STOSB                 ;Засылка в буфер регенерации
        LODSB
SS5:

        MOV     ES:[DI+2000H-1],AL     ;Заслать во вторую половину
        ADD     DI,79         ;Передать следующую строку в буфер регенерации
        DEC     DH            ;Выполнить цикл
        JNZ     SS4

        POP     SI
        POP     DI            ;Восстановить указатель буфера регенерации
        INC     DI            ;Указатель на позицию следующего символа

        CALL    AN_STR

        CMP     DI,8000-80*3

        JNB     S5_S2


        LOOP    SS3    ;Цикл записи символа

S5_S2:
        RET
SS6:
        OR      AL,80H        ;УСТАНОВИТЬ БИТ ЦВЕТА
        STOSB                 ;ЗАПИСАТЬ БАЙТ
        LODSB                 ;ВЗЯТЬ СЛЕДУЮЩИЙ БАЙТ
        OR      AL,80H        ;УСТАНОВИТЬ БИТ ЦВЕТА
        JMP     SS5            ;Вернуться
;
;------ Графический режим высокого разрешения
;
S3:
        PUSH    DI            ;Сохранить указатель буфера регенерации
        PUSH    SI            ;Сохранить указатель кода
        MOV     DH,4          ;Число циклов
S4:
        LODSB                 ;Получить байт
        TEST    BL,080H       ;Проверка, должна ли использоваться операция XOR
        JNZ      S6           ; при засылке символа в буфер регенерации
        STOSB                 ; Нет. Заслать в буфер регенерации
        LODSB
S5:

S51:    MOV     ES:[DI+2000H-1],AL     ;Заслать во вторую половину
        ADD     DI,79         ;Передать следующую строку в буфер регенерации
        DEC     DH            ;Выполнить цикл
        JNZ     S4
        POP     SI
        POP     DI            ;Восстановить указатель буфера регенерации
        INC     DI            ;Указатель на позицию следующего символа



        LOOP    S3            ;Цикл записи символа
        RET
S6:
        XOR     AL,ES:[DI]    ;Операция XOR с текущим значением
        STOSB                 ;Заслать код точки
        LODSB                 ;Повторить для нечетного поля
        XOR     AL,ES:[DI+2000H-1]     ;
        JMP     S5            ;Вернуться
;
;------ Запись в режиме среднего разрешения
;
S7:
;        CLI
        MOV     DL,BL         ;Сохранить старший бит цвета
        SAL     DI,1          ;Умножить смещение на 2, т.к. имеем
                              ;  2 байта на символ
        CALL    S19           ;Расширить BL до слова
S8:


        PUSH    DI            ;Сохранить указатель буфера регенерации
        PUSH    SI            ;Сохранить указатель кода
        MOV     DH,4          ;Число циклов
S9:
        LODSB                 ;Получить код точки
        CALL    S21           ;Дублировать все биты
        AND     AX,BX         ;Преобразовать их в цвет фона (0)
        TEST    DL,80H        ;Есть операция XOR
        JZ      S10           ;Нет, заслать такой, какой есть
        XOR     AH,ES:[DI]    ;Выполнить XOR с одной половиной
        XOR     AL,ES:[DI+1]  ; И с другой половиной
S10:                          ;
        MOV     ES:[DI],AH    ;Заслать первый байт
        MOV     ES:[DI+1],AL  ;Заслать второй байт
        LODSB                 ;Получить код точки
        CALL    S21
        AND     AX,BX         ;Преобразовать цвет
        TEST    DL,80H        ;Снова: есть операция XOR?
        JZ      S11           ;Нет, запомнить значения
        XOR     AH,ES:[DI+2000H]       ;Операция XOR с первой половиной
        XOR     AL,ES:[DI+2000H+1]     ;И со второй половиной
S11:                          ;
        MOV     ES:[DI+2000H],AH
        MOV     ES:[DI+2000H+1],AL     ;Заслать во вторую часть буфера
        ADD     DI,80         ;Указатель на следующую ячейку
        DEC     DH
        JNZ     S9     ;Повторить
        POP     SI            ;Восстановить указатель цикла
        POP     DI            ;Восстановить указатель буфера регенерации
        INC     DI            ;Указатель на позицию следующего символа
        INC     DI


        CALL    AN_STR
        CMP     DI,8000-80*3
        JNB     S5_S21


        LOOP    S8            ;Цикл записи
S5_S21:
;        STI
        RET
GRAPHICS_WRITE  ENDP
;-----------------------------------
; Чтение в графических режимах
;-----------------------------------
GRAPHICS_READ   PROC   NEAR
        CALL    S26           ;Возвращает смещение в буфере регенерации
        MOV     SI,AX         ;Сохранить в SI
        SUB     SP,8          ;Распределить область для хранения кода
                              ; считанной точки
        MOV     BP,SP         ;Указатель для хранения области
;
;------ Определение графических режимов
;
        TEST    CRT_MODE,2
        PUSH    ES
        POP     DS
        JZ      S13
;
;------ Чтение в режиме высокого разрешения
;------ Получить значения из буфера регенерации и преобразовать в код точки
;
        MOV     DH,4          ;Число проходов цикла
S12:
        MOV     AL,[SI]        ;Получить первый байт
        MOV     [BP],AL        ;В область сохранения
        INC     BP             ;Следующая ячейка
        MOV     AL,[SI+2000H]  ;Получить байт из младшей области буфера
                               ; регенерации
        MOV     [BP],AL        ;Выровнять и сохранить
        INC     BP
        ADD     SI,80         ;Указатель в буфере регенерации
        DEC     DH            ;Цикл
        JNZ     S12           ;Выполнить еще раз
        JMP SHORT S15         ;Переход к сохраненным кодам точек
;
;------ Чтение в режиме среднего разрешения
;
S13:
        SAL     SI,1          ;Смещение *2, т.к. имеем 2 байта на символ
        MOV     DH,4          ;Число проходов цикла
S14:
        CALL    S23           ;Взять пару байтов из буфера регенерации
        ADD     SI,2000H      ;Переход к младшей части буфера регенерации
        CALL    S23           ;Взять пару для сохранения
        SUB     SI,2000H-80   ;Вернуть указатель на старшую часть буфера
        DEC     DH
        JNZ     S14           ;Выполнить 8 раз
;
;------ Сохранить обдасть, содержащую символ, упорядочить
;
S15:                          ;Найти символ
        MOV     DI,OFFSET CRT_CHAR_GEN      ;Смещение матрицы
        PUSH    CS
        POP     ES
        SUB     BP,8          ;Выровнять указатель на начало области
                              ; сохранения
        MOV     SI,BP
        CLD                   ;Установить направление
        MOV     AL,0          ;Текущий отмеченный код точки
S16:
        PUSH    SS            ;Установить адресацию стека
        POP     DS            ;Для сравниваемой строки
        MOV     DX,128        ;Число повторов проверки
S17:
        PUSH    SI            ;Сохранить указатель области сохранения
        PUSH    DI            ;Сохранить указатель кода
        MOV     CX,8          ;Число байтов для сравнения
        REPE    CMPSB         ;Сравнить 8 байтов
        POP     DI            ;Восстановить указатели
        POP     SI
        JZ      S18           ;Если 0, пара найдена
        INC     AL            ;Нет пары, на следующий
        ADD     DI,8          ;Следующий код точки
        DEC     DX            ;Цикл
        JNZ     S17           ;Выполнить по всем
;
;------ Символ не совпал, возможно используется во второй половине
;
        CMP     AL,0          ;Если AL<>0, то проверена только первая половина
        JE      S18           ;Если AL=0, то проверены обе
        SUB     AX,AX
        MOV     DS,AX         ;Установить адресацию вектора
        ASSUME  DS:ABS0
        LES     DI,EXT_PTR    ;Получить указатель
        MOV     AX,ES         ;Проверить, существует ли указатель
        OR      AX,DI         ;Если все 0, то не существует
        JZ      S18           ;Нет смысла просматривать
        MOV     AL,128        ;Начало для второй половины
        JMP     S16           ;Вернуться и попытаться для нее
        ASSUME  DS:DATA
;
;------ Координаты символа найдены (AL=0, если не найдены)
S18:
;
        ADD     SP,8          ;Очистка стека, все что сохраняли
        JMP     VIDEO_RETURN  ;Все сделано
GRAPHICS_READ   ENDP
;--------------------------------------------------------------------
;EXSPAND_MED_COLOR
; Эта программа распространяет младшие 2 бита регистра BL (цвет символа),
; заполняя регистр BX (2*8) - для преобразования символа в цветовую матрицу
; точек
;Вход:
; BL - атрибут цвета (младшие 2 бита)
;Выход:
; BX - цвет точек (8 копий 2-х битов цвета)
;------------------------------------------------------------------------
S19     PROC    NEAR

        PUSH    BX            ;**********************
        MOV     BH,BL
        TEST    BL,0F0H
        JNZ     S190
        POP     BX
        JMP     S191

S190:   AND     BH,03H
        CMP     BL,BH
        POP     BX
        PUSH    CX
        MOV     CL,4
        SHR     BL,CL
        JNZ     S1901
        INC     BL
S1901: POP     CX

S191:   AND     BL,3          ;Выделить биты цвета
        MOV     AL,BL         ;Скопировать в AL
        PUSH    CX            ;Сохранить регистр
        MOV     CX,3          ;Количество выполнений
S20:
        SAL     AL,1
        SAL     AL,1          ;Сдвиг влево на 2
        OR      BL,AL         ;Другая версия цвета в BL
        LOOP    S20           ;Заполнить весь BL
        MOV     BH,BL         ;Заполнить верхнюю часть BX
        POP     CX            ;Восстановить регистр
        RET                   ;Все сделано
S19     ENDP
;------------------------------------------------------------------------
; EXPAND_BYTE
;  Эта программа берет байт в AL и удваивает все биты, превращая 8 бит в 16 бит
;  Результат возвращается в AX.
;-------------------------------------------------------------------------
S21     PROC    NEAR
        PUSH    DX            ;Сохранить регистры
        PUSH    CX
        PUSH    BX

        TEST    DL,0F0H       ;*******************************
        JZ      S211
        NOT     AL            ;********************************

S211:   MOV     DX,0          ;Регистр результата
        MOV     CX,1          ;Регистр маски
S22:
        MOV     BX,AX         ;База на шаг
        AND     BX,CX         ;Использовать маску для выделения бита
        OR      DX,BX         ;Поместить в регистр результата
        SHL     AX,1
        SHL     CX,1          ;Сдвинуть базу и маску на 1
        MOV     BX,AX         ;База на шаг
        AND     BX,CX         ;Выделить тот же бит
        OR      DX,BX         ;Поместить в результат
        SHL     CX,1          ;Сдвинуть теперь только маску
        JNC     S22           ;Использовать бит маски, если не конец
        MOV     AX,DX         ;Результат в регистр параметра
        POP     BX
        POP     CX            ;Восстановить регистры
        POP     DX
        RET                   ;Все сделано
S21     ENDP


INCLUDE INT10_C.ASM   ;INT10 - часть 3
;---------------------------------------------------------------------------
; MED_READ_BYTE
;  Эта программа берет 2 байта из буфера регенерации, сличает с текущим цветом
;  (передним) и помещает соответствующий 1/0 бит образца в текущую позицию
;  области сохранения.
; Вход:
;  SI,DS - указатель области буфера регенерации
;     BX - расширенный цвет символа (передний цвет)
;     BP - указатель области сохранения
; Выход:
;     BP перемещен за область сохранения
;--------------------------------------------------------------------------
S23     PROC    NEAR
        MOV     AH,[SI]       ;Получить первый байт
        MOV     AL,[SI+1]     ;Получить второй байт
        MOV     CX,0C000H     ;2 бита маски для проверки входов
        MOV     DL,0          ;Регистр результата
S24:
        TEST    AX,CX         ;Это поле фона (атрибут)?
        CLC                   ;Очистить перенос, надеясь что да
        JZ      S25           ;Если 0, это фон
        STC                   ;Нет, установить перенос
S25:    RCL     DL,1          ;Задвинуть бит в результат
        SHR     CX,1
        SHR     CX,1          ;Сдвинуть маску вправо на 2 бита
        JNC     S24           ;Выполнять это снова, пока маска существует
        MOV     [BP],DL       ;Запомнить результат в области сохранения
        INC     BP            ;Привести в соответствие указатель
        RET                   ;Все сделано
S23     ENDP


;---------------------------------------------------------------------------
; V4_POSITION
;  Эта программа преобразует позицию курсора, содержащуюся в ячейке памяти
;  в смещение в области буфера регенерации, выделяя байт на символ.
;  Для графики среднего разрешения число должно быть удвоено.
; Вход - ячейка CURSOR_POSN
;
; Выход - AX содержит смещение в буфере регенерации
;--------------------------------------------------------------------------
S26     PROC    NEAR
        PUSH    SI
        MOV     AL,ACTIVE_PAGE
        XOR     AH,AH
        SAL     AX,1
        MOV     SI,AX
        MOV     AX,DS:[SI+OFFSET CURSOR_POSN] ;Получить позицию курсора для
                                              ; активной сраницы
        MOV     T_CURSOR,AL
        MOV     K_CICL,0

        POP     SI
GRAPH_POSN      LABEL  NEAR
        PUSH    BX                   ;Сохранить регистр
        MOV     BX,AX                ;Сохранить копию текущего курсора
        MOV     AL,AH                ;Получить строку в AL
        MUL     BYTE PTR CRT_COLS    ;Умножить на байт/колонку
        SHL     AX,1                 ;Умножить на 4, т.к. требуется
        SHL     AX,1                 ; 4 байта на строку
        SUB     BH,BH                ;Выделить значение колонки
        ADD     AX,BX                ;Определить смещение
        POP     BX                   ;Восстановить указатель
        RET                          ;Все сделано
S26     ENDP


        ORG     0F841H

INCLUDE INT12.ASM

;---INT 12--------------------------------------------------------------
; MEMORY_SIZE_DETERMINE
;       Эта программа определяет размер памяти в системе посредством анализа
;       переключателей на плате.
; Вход:
;       Размер памяти устанавливается во время диагностики по включении
;       питания, используя биты 0-3 портов G0 и G2.
; Выход:
;       (AX) - размер памяти в Кбайтах
;--------------------------------------------------------------------------
        ASSUME  CS:CODE,DS:DATA
MEMORY_SIZE_DETERMINE   PROC  FAR
        STI                          ;Разрешить прерывания
        PUSH    DS                   ;Сохранить регистр сегмента
        MOV     AX,DATA              ;Установить адресацию
        MOV     DS,AX
        MOV     AX,MEMORY_SIZE       ;Получить значение размера памяти
        POP     DS                   ;Восстановить сегмент
        IRET                         ;Возврат из прерывания
MEMORY_SIZE_DETERMINE   ENDP

INCLUDE INT11.ASM

;---INT 11------------------------------------------------------------------
; EQUIPMENT DETERMINATION
;       Эта программма определяет, какие штатные устройства подсоединены к
;       системе.
; Вход:
;       Переменная EQUIP_FLAG устанавливается во время диагностики по включении
;       питания, используя следующие выходы оборудования:
;       Порт 60 -  младший байт переменной,
;       Порт 3FA - регистр прерывания ввода/вывода 8250 (биты 7-3 всегда 0),
;       Порт 378 - выходной порт принтера (8255), может быть прочитан и записан
; Выход:
;       (AX) устанавливает биты для указания значения ввода/вывода:
;       Биты 15,14 - число печатающих устройств,
;       Бит 13 - не используется,
;       Бит 12 - игровой ввод/вывод подключен,
;       Биты 11,10,9 - номер подключенного адаптера RS232,
;       Бит 8 - не используется,
;       Биты 7,6 - число накопителей ГМД,
;                 (00-1,01-2,10-3,11-4 при бите 0=1)
;       Биты 5,4 - начальный видео-режим:
;                      00 - не испльзуется
;                      01 - 40*25 ч/б, использующий цветной адаптер
;                      10 - 80*25 ч/б, использующий цветной адаптер
;                      11 - 80*25 ч/б, использующий ч/б адаптер
;       Биты 3,2 - размер памятим микросхемы (00-16K,01-32K,10-48K,11-64K),
;       Бит 1 - не используется,
;       Бит 0 - загрузка с дискеты (бит указывает, что в системе есть
;               устройство ГМД),
;       Другие регистры не используются
;---------------------------------------------------------------------------
        ASSUME  CS:CODE,DS:DATA
EQUIPMENT       PROC   FAR
        STI                   ;Разрешить прерывания
        PUSH    DS            ;Сохранить сегментный регистр
        MOV     AX,DATA       ;Установить адресацию
        MOV     DS,AX
        MOV     AX,EQUIP_FLAG ;Получить текущее состояние
        POP     DS            ;Восстановить сегмент
        IRET                  ;Возврат к программе
EQUIPMENT       ENDP

INCLUDE INT15_A.ASM
;---INT 15-----------------------------------------------14-02-89--------------
; CASSETTE I/O
;       (AH) = 0 ВКЛЮЧИТЬ ДВИГАТЕЛЬ (в данной версии 0 и 1 ф-ции
;       (AH) = 1 ВЫКЛЮЧИТЬ ДВИГАТЕЛЬ   отсутствуют)
;       (AH) = 2 ЧИТ. 1 ИЛИ БОЛЬШЕ 256-БАЙТНЫХ БЛОКОВ С КАССЕТЫ
;               (ES,BX) = АДРЕС БУФЕРА ДАННЫХ
;               (CX) = КОЛИЧЕСТВО БАЙТ ДЛЯ ЧТЕНИЯ
;               НА ВЫХОДЕ:
;               (ES,BX) = АДРЕС ПОСЛЕДНЕГО СЧИТ. БАЙТА + 1
;               (DX) = КОЛИЧЕСТВО СЧИТАННЫХ БАЙТ
;               (CY) = 0 ЕСЛИ НЕТ ОШИБОК ПРИ ЧТЕНИИ
;                    = 1 ОБНАРУЖЕНА ОШИБКА ЧТЕНИЯ
;               (AH) = ВОЗВРАЩАЕМЫЙ КОД ОШИБКИ, ЕСЛИ (CY)=1
;                       =01 ОШИБКА CRC КОНТРОЛЯ
;                       =02 ПОТЕРЯ ДАННЫХ
;                       =04 ТАЙМАУТ ПРИ ПОИСКЕ ФАЙЛА
;       (AH) = 3 ПИСАТЬ 1 ИЛИ БОЛЬШЕ 256-БАЙТНЫХ БЛОКА НА КАССЕТУ
;               (ES,BX) = АДРЕС ЬУФЕРА ДАННЫХ
;               (CX) = КОЛИЧЕСТВО БАЙТ ДЛЯ ЗАПИСИ
;               НА ВЫХОДЕ:
;               (EX,BX) = АДРЕС ПОСЛЕДНЕГО ЗАПИСАННОГО БАЙТА + 1
;               (CX) = 0
;       (AH) = 4 ЧТЕНИЕ ФАЙЛА С КАССЕТЫ
;              DS:[BX] - АДРЕС СИМВОЛЬНОЙ СТРОКИ, СОДЕРЖАЩЕЙ ИМЯ ФАЙЛА
;              (ES) - АДРЕС БУФЕРА ДАННЫХ
;              НА ВЫХОДЕ:
;              (AH) - ВОЗВРАЩАЕМЫЙ КОД ОШИБКИ, ЕСЛИ (CY) = 1
;                       =01 ОШИБКА CRC КОНТРОЛЯ
;                       =02 ПОТЕРЯ ДАННЫХ
;                       =04 ТАЙМАУТ ПРИ ПОИСКЕ ФАЙЛА
;       (AH) = 5 ЗАПИСЬ ФАЙЛА НА КАССЕТУ
;              DS:[BX] - АДРЕС СИМВОЛЬНОЙ СТРОКИ, СОДЕРЖАЩЕЙ ИМЯ ФАЙЛА
;              (ES) - АДРЕС БУФЕРА ДАННЫХ
;              НА ВЫХОДЕ:
;              (CY) = 1 - ОШИБКА ЧТЕНИЯ
;       (AH) = ДРУГОЕ ЗНАЧЕНИЕ - (CY)=1 - НЕСУЩЕСТВУЮЩАЯ ОПЕРАЦИЯ,
;              ВОЗВРАЩАЕТ (AH) = 80 - ПРИЗНАК НЕСУЩЕСТВУЮЩЕЙ ОПЕРАЦИИ.
;---------------------------------------------------------------------------
;
CASSETTE_IO     PROC        FAR
        CLI                     ;ЗАПРЕТИТЬ ПРЕРЫВАНИЯ
        PUSH    DS
        PUSH    AX
      MOV     AX,DATA
      MOV     DS,AX
        POP     AX
        CALL    W1              ;ВЫЗВАТЬ ДИСПЕТЧЕР ФУНКЦИЙ
        POP     DS
        STI                     ;РАЗРЕШИТЬ ПРЕРЫВАНИЯ
        RET     2               ;ВОЗВРАТ
CASSETTE_IO     ENDP
W1      PROC NEAR
;-----------------------------------------------------------14-02-89--------
; ЦЕЛЬ:
;  ВЫЗОВ ФУНКЦИИ СОГЛАСНО СОДЕРЖИМОМУ РЕГИСТРА AH
;
;  AH           ФУНКЦИЯ
;-----------------------------------------------------------------------------
;  0            ВКЛ. ДВИГАТЕЛЬ
;  1            ВЫКЛ. ДВИГАТЕЛЬ
;  2            ЧТЕНИЕ БЛОКА
;  3            ЗАПИСЬ БЛОКА
;  4            ЧТЕНИЕ ФАЙЛА
;  5            ЗАПИСЬ ФАЙЛА
;------------------------------------------------------------------------------

        OR      AH,AH
        JNZ     WK1
        RET
WK1:    DEC     AH
        JNZ     WK2
        RET
WK2:    DEC     AH                      ;ЧТЕНИЕ?
        JZ      READ_BLOCK              ;ДА
        DEC     AH                      ;ЗАПИСЬ?
        JNZ     W2                      ;НЕТ
        JMP     WRITE_BLOCK             ;ДА, ЗАПИСЬ

W2:
        DEC     AH
        JNZ     W201
        JMP     FILE_READ               ;ЧТЕНИЕ ФАЙЛА
W201:   DEC     AH
        JNZ     W202
        JMP     FILE_WRITE              ;ЗАПИСЬ ФАЙЛА
W202:
                                        ;НЕСУЩЕСТВУЮЩАЯ ФУНКЦИЯ
        MOV     AH,080H                 ;УСТАНОВИТЬ КОД ВОЗВРАТА
        STC                             ;УСТАНОВИТЬ ФЛАГ ОШИБКИ
        RET
W1      ENDP

READ_BLOCK      PROC    NEAR
;-----------------------------------------------------------------------------
; ЦЕЛЬ:
;   ЧИТАТЬ 1 ИЛИ БОЛЬШЕ 256-БАЙТНЫХ БЛОКОВ С КАССЕТЫ
;
; ВХОДНЫЕ ПАРАМЕТРЫ:
;   ES СЕГМЕНТ БУФЕРА ДЛЯ ПРИЕМА ДАННЫХ
;   BX УКАЗАТЕЛЬ НАЧАЛА БУФЕРА
;   CX УКАЗЫВАЕТ КОЛИЧЕСТВО БАЙТ КОТОРЫЕ НЕОБХОДИМО ПРОЧЕСТЬ
; ВЫХОДНЫЕ ПАРАМЕТРЫ:
;   BX УКАЗЫВАЕТ АДРЕС БАЙТА СЛЕДУЮЩЕГО ЗА ПОСЛЕДНИМ СЧИТАННЫМ
;   CX ВЫЧИТАЮЩИЙ СЧЕТИК СЧИТЫВАЕМЫХ БАЙТ
;   DX СЧЕТЧИК ПРОЧИТАННЫХ БАЙТ
;
; ФЛАГ ПЕРЕНОСА РАВЕН НУЛЮ, ЕСЛИ НЕТ ОШИБОК
; И УСТАНАВЛИВАЕТСЯ ПРИ ОБНАРУЖЕНИИ ОШИБКИ
;----------------------------------------------------------------------------
        PUSH    BX                      ;СОХРАНИТЬ BX
        PUSH    CX                      ;СОХРАНИТЬ CX
        PUSH    SI                      ;СОХРАНИТЬ SI
        MOV     SI,7                    ;ЧИСЛО ПОПЫТОК ПОИСКА ЗАГОЛОВКА
W4:                                     ;ПОИСК ЗАГОЛОВКА
        IN      AL,PORT_C               ;СЧИТАТЬ ПОРТ ОБМЕНА С КАССЕТН.
        AND     AL,010H ;ВЫДЕЛИТЬ СИГНАЛЬНЫЙ РАЗРЯД
        MOV     LAST_VAL,AL             ;СОХРАНИТЬ ЗНАЧЕНИЕ УРОВНЯ СИГНАЛА
        MOV     DX,16250                ;ЧИСЛО ЦИКЛОВ ДЛЯ ОЖИДАНИЯ ПЕРЕПАДА
W5:                                     ;УРОВНЯ СИГНАЛА
        CALL    BREAK_TEST              ;ПРЕРВАТЬ СЧИТЫВАНИЕ?
        JNZ     W6                      ;НЕТ
        JMP     W17                     ;ПРЕРВАТЬ ЧТЕНИЕ

W6:     DEC     DX
        JNZ     W7                      ;ПЕРЕХОД, ЕСЛИ НАЧАЛО ЗАГОЛОВКА
        JMP     W17                     ;ПЕРЕХОД, ЕСЛИ ЗАГОЛОВОК НЕ НАЙДЕН

W7:     CALL    READ_HALF_BIT           ;ИГНОРИРОВАТЬ ПЕРВЫЙ ИМПУЛЬС
        JCXZ    W5                      ;ПЕРЕЙТИ ЕСЛИ НЕ БЫЛО ПЕРЕПАДА СИГН.
        IN      AL,021H ;ПРОЧИТАТЬ РЕГ. МАСКИ ПРЕРЫВАНИЙ
        OR      AL,1                    ;ЗАПРЕТИТЬ ПРЕРЫВАНИЯ ОТ ТАЙМЕРА
        OUT     021H,AL
;
        CALL    READ_HALF_BIT           ;ПОЛУЧИТЬ ДЛИТЕЛЬНОСТЬ П/ПЕРИОДА
        JCXZ    W4                      ;ТАЙМАУТ
        MOV     DX,BX                   ;СОХРАНИТЬ ПОЛУЧ. ДЛИТ.
      CALL    READ_HALF_BIT           ;ПОЛУЧИТЬ ДЛИТ. 2-ГО П/ПЕРИОДА
      JCXZ    W4                      ;ТАЙМАУТ
      ADD     BX,DX                   ;ПОЛУЧИТЬ ДЛИТ. ПЕРИОДА

;  -----------   ЦИКЛ ДЛЯ РАСПОЗНАВАНИЯ ЗАГОЛОВКА

      MOV     CX,100H  ;СЧЕТЧИК БАЙТОВ ДЛЯ ИДЕНТИФИКАЦИИ
W8:
      CALL    BREAK_TEST              ;ПРЕРВАТЬ?
        JNZ     W117                    ;НЕТ
        JMP     W17                     ;ДА
W117:   XCHG    DX,BX                   ;СОХРАНИТЬ ДЛИТ. ПРЕДЫДУЩ. ПЕРИОДА
        PUSH    CX
; ----------------------------  ПОЛУЧИТЬ ДЛИТЕЛЬНОСТЬ НОВОГО ПЕРИОДА
      CALL    READ_HALF_BIT           ;ПОЛУЧИТЬ ДЛИТЕЛЬНОСТЬ П/ПЕРИОДА
        OR      CX,CX
        POP     CX
        JZ      W4
        PUSH    CX
      PUSH    BX                      ;СОХРАНИТЬ ПОЛУЧ.ДЛИТ. П/ПЕРИОДА
        CALL    READ_HALF_BIT           ;ПОЛУЧИТЬ НОВУЮ ДЛИТ.
        OR      CX,CX
      POP     AX                      ;В AX ВОССТАНОВИТЬ ПРЕДЫДУЩ. ДЛИТ.
        POP     CX
        JZ      W4
      ADD     BX,AX                   ;BX <--- ДЛИТ. НОВОГО ПЕРИОДА
      SUB     DX,BX                   ;СРАВНИТЬ ДЛИТ. НОВОГО И ПРЕДЫДУЩ.ПЕР.
      JNC     W801                    ;ЕСЛИ РАЗНИЦА ОТРИЦАТЕЛЬНА,
      NEG     DX                      ;ПОЛУЧИТЬ АБСОЛЮТНОЕ ЗНАЧЕНИЕ
W801: CMP     DX,0C0H ;ПРОВЕРИТЬ НА ДОПУСТИМУЮ РАЗНИЦУ
                                      ;ПРЕДЫДУЩИЙ И НОВЫЙ ПЕРИОД
      JNC     W4                      ;РАЗНИЦА БОЛЬШЕ ДОПУСТИМОЙ

      LOOP    W8                      ;ПОВТОРИТЬ, ЕСЛИ ПРОАНАЛИЗИРВАНО
                                      ;МЕНЬШЕ 256 (100H) ПЕРИОДОВ

;--- ЕСЛИ НАЧАЛО ЗАГОЛОВКА ОПОЗНАНО, ВЫЧИСЛИТЬ СРЕДНЮЮ ДЛИТЕЛЬНОСТЬ
;    ПЕРИОДА БИТОВ "1" И МИНИМАЛЬНО-ДОПУСТИМУЮ ДЛИТ. "1"

        XCHG    DX,BX
        MOV     CX,0FFH ;УСТАНОВИТЬ СЧЕТЧИК
        XOR     AX,AX                   ;ОБНУЛИТЬ СУММАТОР ОТКЛОНЕНИЙ
W88:    PUSH    CX                      ;СОХРАНИТЬ СЧЕТЧИК
        PUSH    AX                      ;СОХРАНИТЬ СУММУ ОТКЛОНЕНИЙ
        CALL    READ_HALF_BIT           ;ПОЛУЧИТЬ ДЛИТЕЛЬНОСТЬ ПОЛУПЕРИОДА
        PUSH    BX                      ;СОХРАНИТЬ ПОЛУЧ. ДЛИТ.
        CALL    READ_HALF_BIT           ;ПОЛУЧИТЬ ДЛИТ. 2-ГО ПОЛУПЕРИОДА
        POP     AX                      ;ВОССТАНОВИТЬ ПРЕДЫДУЩУЮ ДЛИТ.
        ADD     BX,AX                   ;ПОЛУЧИТЬ ДЛИТЕЛЬНОСТЬ ПЕРИОДА
        POP     AX                      ;ВОССТАНОВИТЬ СУММУ ОТКЛОНЕНИЙ
        SUB     BX,DX                   ;ПОЛУЧИТЬ НОВОЕ ОТКЛОНЕНИЕ
        ADD     AX,BX                   ;ПРИБАВИТЬ К СУММЕ
        POP     CX                      ;ВОССТАНОВИТЬ СЧЕТЧИК
        LOOP    W88
;
        MOV     CL,8
        SAR     AX,CL                   ;ПОЛУЧИТЬ СРЕДНЕЕ ОТКЛОНЕНИЕ
        ADD     DX,AX                   ;DX <--- СРЕДНЕЕ ЗНАЧ. ПЕРИОДА "1" P1
        MOV     BX,DX
        SAR     BX,1                    ;BX <--- P1/2
        MOV     DX,BX
        SAR     BX,1                    ;BX <--- P1/4
        ADD     DX,BX                   ;DX <--- 0.75*P1 - MIN ДОП. ЗНАЧ. ПЕР
        MOV     LOWLIM,DX               ;СОХР. MIN ДОП. ЗНАЧ. ПЕРИОДА "1"
        MOV     DX,BX
        SAR     BX,1                    ;BX <--- P1/8
        ADD     DX,BX                   ;DX <--- 3/8 * P1 - MIN ДОП. ЗНАЧЕНИЕ
                                        ;ПОЛУПЕРИОДА "1" ДЛЯ ПОИСКА СТАРТ-БИТА
;
;                               ПОИСК "0" - СТАРТ-БИТА
W89:
        CALL    BREAK_TEST              ;ПРЕРВАТЬ ЧТЕНИЕ
        JZ      W17                     ;ДА
        CALL    READ_HALF_BIT           ;ПОЛУЧИТЬ ДЛИТ. ПОЛУПЕРИОДА СИГНАЛА
        CMP     DX,BX                   ;"0" ИЛИ "1"?
        JC      W89                     ;ЕСЛИ "1" - ПОВТОРИТЬ
;
;   СТАРТ-БИТ НАЙДЕН. ПРОВЕРКА СИНХРОСИМВОЛА:
        CALL    READ_HALF_BIT           ;ПРОПУСТИТЬ 2-Й ПОЛУПЕРИОД СТАРТ-БИТА
        CALL    READ_BYTE               ;ПРОЧИТАТЬ СИНХРОБАЙТ
        CMP     AL,16H                  ;ПРОВЕРИТЬ СИНХРО-СИМВОЛ
        JNE     W16                     ;ПЕРЕХОД, ЕСЛИ ПЛОХОЙ ЗАГОЛОВОК

;------ЗАГОЛОВОК ПРОЧИТАН УСПЕШНО. ЧТЕНИЕ БЛОКОВ ДАННЫХ
        POP     SI                      ;ВОССТАНОВИТЬ РЕГИСТРЫ
        POP     CX
        POP     BX

;-------------------------------------------------------------------------
; ЧИТАТЬ 1 ИЛИ БОЛЬШЕ 256-БАЙТНЫХ БЛОКОВ ДАННЫХ С КАССЕТЫ
;
;НА ВХОДЕ:
; ES - СЕГМЕНТ ДЛЯ БУФЕРА В ПАМЯТИ ДЛЯ ПРИЕМА СЧИТАННЫХ БАЙТ
; BX - УКАЗАТЕЛЬ АДРЕСА В БУФЕРЕ
; CX - СОДЕРЖИТ КОЛИЧЕСТВО БАЙТ КОТОРЫЕ НЕОБХОДИМО ПРОЧИТАТЬ
;НА ВЫХОДЕ:
; BX - УКАЗЫВАЕТ АДРЕС БАЙА В БУФЕРЕ, СЛЕДУЮЩЕГО ЗА ПОСЛЕДНИМ ПРЧИТАННЫМ
; CX - ВЫЧИТАЮЩИЙ СЕТЧИК СЧИТЫВАЕМЫХ БАЙТ
; DX - СОДЕРЖИТ КОЛИЧЕСТВО ПРОЧИТАННЫХ БАЙТ
;---------------------------------------------------------------------------
        PUSH    CX                      ;СОРАНИТЬ СЧЕТЧИК БАЙТ
W10:                                    ;ТОЧКА ВХОДА ДЛЯ ВОЗВРАТА
                                        ;ПО ПРОЧТЕНИЮ 256-БАЙТНОГО БЛОКА
        MOV     CRC_REG,0FFFFH          ;ИНИЦИАЛИЗИРОВАТЬ CRC-РЕГИСТР
        MOV     DX,256                  ;DX <--- РАЗМЕР БЛОКА ДАННЫХ
W11:                                    ;ЧИТАТЬ БЛОК
        CALL    BREAK_TEST              ;ПРЕРВАТЬ ЧТЕНИЕ?
        JZ      W13                     ;ДА
        CALL    READ_BYTE               ;СЧИТАТЬ БАЙТ
        JC      W13                     ;ЕСЛИ ОШИБКА - CY=1
        JCXZ    W12                     ;ЕСЛИ ПРОЧИТАНЫ ВСЕ БАЙТЫ (CX),
                                        ;ДОЧИТАТЬ БЛОК, НО В БУФЕРЕ
                                        ;НЕ СОХРАНЯТЬ
        MOV     ES:[BX],AL              ;СОХРАНИТЬ БАЙТ В БУФЕРЕ
        INC     BX                      ;УВЕЛИЧИТЬ АДРЕС БУФЕРА
        DEC     CX                      ;УМЕНЬШИТЬ СЧЕТЧИК БАЙТ
W12:                    ;ЗАВЕРШЕНИЕ ЦИКЛА ЧТЕНИЯ 256-БАЙТНОГО БЛОКА ДАННЫХ
        DEC     DX                      ;УМЕНЬШИТЬ СЧЕТЧИК БАЙТ В БЛОКЕ
        JG      W11                     ;ВОЗВРАТ НА ЧТЕНИЕ, ЕСЛИ < 256
        CALL    READ_BYTE               ;ТЕПЕРЬ ЧИТАЕМ ДВА БАЙТА CRC
        CALL    READ_BYTE
        SUB     AH,AH                   ;ОБНУЛЯЕМ AH
        CMP     CRC_REG,1D0FH           ;CRC ПРАВИЛЬНО?
        JNE     W14                     ;ПЕРЕЙТИ, ЕСЛИ ОШИБКА
        JCXZ    W15                     ;ЕСЛИ СЧЕТЧИК БАЙТ=0, Т.Е.
                                        ;ПРОЧИТАНЫ ВСЕ ДАННЫЕ,
                                        ;ЗАВЕРШИТЬ ЧТЕНИЕ
        JMP     W10                     ;ЕСЛИ НЕТ - ЧИТАТЬ СЛЕДУЮЩИЙ БЛОК
                                ;ОБРАБОТКА ОШИБОК ЧТЕНИЯ
W13:                                    ;ПОТЕРЯНЫ ДАННЫЕ
        MOV     AH,01H                  ;УСТАНОВИТЬ КОД ВОЗВРАТА AH=02 -
                                        ;"ПОТЕРЯНЫ ДАННЫЕ"
W14:                                    ;ОШИБКА CRC-КОНТРОЛЯ
        INC     AH                      ;УСТАНОВИТЬ КОД ВОЗВРАТА AH=01 -
                                        ;"ОШИБКА CRC-КОНТРОЛЯ"
W15:                                    ;ЗАВЕРШЕНИЕ ЧТЕНИЯ
        POP     DX                      ;ВЫЧИСЛИТЬ ЧИСЛО РЕАЛЬНО
        SUB     DX,CX                   ;ПРОЧИТАННЫХ БАЙТ
                                        ;ДЛЯ ВОЗВРАТА В РЕГ. DX
        PUSH    AX                      ;СОХРАНИТЬ AX (КОД ВОЗВРАТА)
        TEST    AH,03H                  ;ЕСТЬ ОШИБКИ?
        JNZ     W18                     ;ВЫХОД ПО ОШИБКЕ
        CALL    READ_BYTE               ;ПРОЧИТАТЬ КОНЕЦ
        JMP     SHORT W18               ;ВЫПОЛНИТЬ ВЫКЛЮЧЕНИЕ ДВИГАТЕЛЯ
W16:                                    ;ПЛОХОЙ ЗАГОЛОВОК
        DEC     SI                      ;ПРОВЕРИТЬ ЧИСЛО ПОПЫТОК ПОВТОРА
                                        ;РАСПОЗНАТЬ ЗАГОЛОВОК
        JZ      W17                     ;ЧИСЛО ПОПЫТОК БОЛЬШЕ ДОПУСТИМОГО
        JMP     W4                      ;ПОПЫТАТЬСЯ ЕЩЕ РАЗ
W17:                                    ;НЕ НАЙДЕНЫ ДАННЫЕ
;-------НЕ НАЙДЕНЫ ДАННЫЕ НА КАССЕТЕ,Т.Е. ТАЙМАУТ ПРИ ЧТЕНИИ

        POP     SI                      ;ВОССТАНОВИТЬ РЕГИСТРЫ
        POP     CX
        POP     BX
        SUB     DX,DX                   ;НУЛЬ БАЙТОВ ПРОЧИТАНО
        MOV     AH,04H                  ;ОШИБКА "ТАЙМАУТ ПРИ ЧТЕНИИ"
        PUSH    AX
W18:
        IN      AL,021H         ;ПЕРЕРАЗРЕШИТЬ ПРЕРЫВАНИЯ
        AND     AL,0FFH-1
        OUT     021H,AL
        POP     AX                      ;ВОССТАНОВИТЬ КОД ВОЗВРАТА
        CMP     AH,01H                  ;УСТАНОВИТЬ CY=1 ПРИ ОШИБКЕ (AH>0)
        CMC
        RET                             ;ЗАКОНЧИТЬ
READ_BLOCK      ENDP
;---------------------------------------------------------------------------
READ_BYTE       PROC NEAR
; ЦЕЛЬ:
;  ПРОЧИТАТЬ БАЙТ С КАССЕТЫ
;  НА ВЫХОДЕ РЕГИСТР AL СОДЕРЖИТ ПРОИТАННЫЙ БАЙТ ДАННЫХ
;---------------------------------------------------------------------------
        PUSH    BX                      ;СОХРАНИТЬ РЕГИСТРЫ BX,CX
        PUSH    CX
        MOV     CL,8H                   ;УСТАНОВИТЬ СЧЕТЧИК БИТ РАВНЫМ 8
W19:                                    ;ЧИТАТЬ БАЙТ
        PUSH    CX                      ;СОХРАНИТЬ СЧЕТЧИК БИТ

;----------------------------------------------------------------------------
;  ЧИТАТЬ БИТ ДАННЫХ С КАССЕТЫ
;----------------------------------------------------------------------------
        CALL    READ_HALF_BIT           ;ПРОЧИТАТЬ ОДИН ПОЛУПЕРИОД
        JCXZ    W21                     ;ЕСЛИ CX=0 - ИМПУЛЬС-ТАЙМАУТ
                                        ;НЕТ ЗАДЕГО ФРОНТА ИМПУЛЬСА
        PUSH    BX                      ;СОХРАНИТЬ ДЛИТЕЛЬНОСТЬ
                                        ;ПОЛУПЕРИОДА (IN BX)
        CALL    READ_HALF_BIT           ;ПРОЧИТАТЬ ВТОРОЙ ПОЛУПЕРИОД
        POP     AX                      ;ВОССТАНОВИТЬ ДЛИТ. ПРЕДЫДУЩ. ИМП.
        JCXZ    W21                     ;ЕСЛИ CX=0 - ИМПУЛЬС-ТАЙМАУТ
        ADD     BX,AX                   ;ВЫЧИСЛИТЬ ДЛИНУ ПЕРИОДА
        CMP     BX,LOWLIM               ;ПРОВЕРИТЬ "0" ИЛИ "1"
        CMC                             ;CY=1, ЕСЛИ ЕДИНИЧНЫЙ БИТ
        LAHF                            ;СОХРАНИТЬ ФЛАГ ПЕРЕНОСА В AH
        POP     CX                      ;ВОССТАНОВИТЬ СЧЕТЧИК БИТ
                                        ;ДЛЯ СПРАВКИ:
                                        ;СТАРШИЙ БИТ ЧИТАЕТСЯ ПЕРВЫМ
                                        ;РЕГ. CH СДВИГАЕТСЯ ВЛЕВО И
                                        ;ПЕРЕНОС ЗАНОСИТСЯ В МЛАДШИЙ БИТ
                                        ;РЕГИСТРА CH.
                                        ;ПОСЛЕ СЧИТЫВАНИЯ ВСЕХ 8 БИТ
                                        ;СТАРШИЙ БИТ СЧИТЫВАЕМОГО БАЙТА
                                        ;ОКАЖЕТСЯ В СТАРШЕМ БИТЕ РЕГ. CH
        RCL     CH,1                    ;СДВИГАЕМ РЕГ. CH ВЛЕВО ДЛЯ ЗАНЕСЕНИЯ
                                        ;ПЕРЕНОСА В МЛАДШИЙ БИТ РЕГ. CH
        SAHF                            ;ВОССТАНАВЛИВАЕМ CY ДЛЯ ВЫЧИСЛЕНИЯ CRC
        CALL    CRC_GEN         ;ГЕНЕРИРУЕМ CRC ДЛЯ СЧИТАННОГО БИТА
        DEC     CL                      ;УМЕНЬШАЕМ СЧЕТЧИК БИТ
                                        ;ПОВТОРЯЕМ ЧТЕНИЕ БИТА ПОКА НЕ ПРОЧИ-
        JNZ     W19                     ;ТАЕМ ВСЕ 8.
        MOV     AL,CH                   ;AL <--- ПРОЧИТАННЫЙ БАЙТ
        CLC
W20:                                    ;ЗАВЕРШИТЬ ЧТЕНИЕ БАЙТА
        POP     CX                      ;ВОССТАНОВИТЬ РЕГ. CX,BX
        POP     BX
        RET                             ;ЗАКОНЧИТЬ
W21:                                    ;ПОТЕРЯ ДАННЫХ
        POP     CX                      ;ВОССТАНОВИТЬ CX
        STC                             ;УСТАНОВИТЬ ФЛАГ ОШИБКИ
        JMP     W20                     ;ЗАВЕРШИТЬ ЧТЕНИЕ
READ_BYTE       ENDP

;--------------------------------------------------------------------------
WRITE_BLOCK     PROC    NEAR
;
; ЗАПИСЬ 1 ИЛИ БОЛЬШЕ 256-БАЙТНЫХ БЛОКОВ НА КАССЕТУ.
;       В ПОСЛЕДНЕМ БЛОКЕ ДАННЫЕ ДОПОЛНЯЮТСЯ ПОСЛЕДНИМ БАЙТОМ ДО ДЛИНЫ 256.
;
; ВХОДНЫЕ ПАРАМЕТРЫ:
;  BX - УКАЗАТЕЛЬ АДРЕСА БУФЕРА ДАННЫХ
;  CX - КОЛИЧЕСТВО БАЙТ ДЛЯ ЗАПИСИ
;
; НА ВЫХОДЕ:
;  BX УКАЗЫВАЕТ АДРЕС БАЙТА, КОТОРЫЙ СЛЕДУЕТ ЗА ПОСЛЕДНИМ ЗАПИСАННЫМ
;  CX РАВЕН НУЛЮ
;---------------------------------------------------------------------------
        PUSH    BX
        PUSH    CX
        IN      AL,PORT_B               ;ВЫКЛЮЧИТЬ ГРОМКОГОВОРИТЕЛЬ
        AND     AL,NOT 02H
        OR      AL,01H                  ;РАЗРЕШИТЬ СЧЕТ 2 КАНАЛА ТАЙМЕРА
        OUT     PORT_B,AL
        MOV     AL,0B6H          ;КАНАЛ 2 ТАЙМЕРА В РЕЖИМ 3
        OUT     TIM_CTL,AL
        MOV     AX,1184  ;КОЭФ. ДЕЛЕНИЯ ДЛЯ ЧАСТОТЫ "1"
        CALL    W31                     ;ЗАГРУЗИТЬ ТАЙМЕР
        MOV     CX,0800H                ;СЧЕТЧИК ВИТОВ ДЛЯ ЗАГОЛОВКА
W23:                                    ;ЗАПИСАТЬ ЗАГОЛОВОК
        STC                             ;ЗАПИСАТЬ БИТ "1"
        CALL    WRITE_BIT               ;
        LOOP    W23                     ;ЗАПИСАН ВЕСЬ ЗАГОЛОВОК?
        CLC                             ;ЗАПИСАТЬ СИНРО-БИТ (0)
        CALL    WRITE_BIT
        POP     CX                      ;ВОССТАНОВИТЬ CX,BX
        POP     BX
        MOV     AL,16H                  ;ЗАПИСАТЬ СИНХРО-СИМВОЛ
        CALL    WRITE_BYTE              ;

;-------------------------------------------------------------------------
; ЗАПИСАТЬ 1 ИЛИ БОЛЬШЕ 256-БИТНЫХ БЛОКОВ НА КАССЕТУ.
;
; ВХОДНЫЕ ПАРАМЕТРЫ:
;  BX - УКАЗАТЕЛЬ АДРЕСА БУФЕРА ДАННЫХ
;  CX - КОЛИЧЕСТВО БАЙТ ДЛЯ ЗАПИСИ
;
; НА ВЫХОДЕ:
;  BX УКАЗЫВАЕТ АДРЕС БАЙТА, КОТОРЫЙ СЛЕДУЕТ ЗА ПОСЛЕДНИМ ЗАПИСАННЫМ
;  CX РАВЕН НУЛЮ
;
;---------------------------------------------------------------------------
WR_BLOCK:
        MOV     CRC_REG,0FFFFH          ;ИНИЦИАЛИЗИРОВАТЬ CRC-РЕГИСТР
        MOV     DX,256                  ;СЧЕТЧИК БАЙТ В БЛОКЕ
W24:                                    ;WR-BLK
        MOV     AL,ES:[BX]              ;ПРОЧИТАТЬ БАЙТ ИЗ ПАМЯТИ
        CALL    WRITE_BYTE              ;ЗАПИСАТЬ ЕГО НА КАССЕТУ
        JCXZ    W25                     ;ЕСЛИ CX=0,НЕ ИЗМЕНЯТЬ СЧЕТЧИК ИУКАЗАТ.
        INC     BX                      ;INC УКАЗАТЕЛЬ АДРЕСА БУФЕРА
        DEC     CX                      ;DEC СЧЕТЧИК ЗАПИСЫВЕМЫХ БАЙТ
W25:                                    ;SKIP-ADV
        DEC     DX                      ;DEC СЧЕТЧИК БАЙТ БЛОКА
        JG      W24                     ;ЗАПИСАНЫ ВСЕ 256 БАЙТ ДАННОГО БЛОКА?

;----------------------ЗАПИСАТЬ CRC-------------------------------------------
; ЗАПИСАТЬ ОБРАТНЫЙ КОД CRC-РЕГИСТРА НА КАССЕТУ.
; ПРИ СЧИТЫВАНИИ БЛОКА ПРОВЕРЯЕТСЯ СООТВЕТСТВИЕ ВЫЧИСЛЕННОГО И СЧИТАННОГО CRC
;
; МОДИФИЦИРУЕТ РЕГИСТР AX
;-----------------------------------------------------------------------------
        MOV     AX,CRC_REG              ;ЗАПИСАТЬ ОБРАТНЫЙ КОД CRC-РЕГИСТРА
                                        ;В ВИДЕ ДВУХ БАЙТОВ CRC НА КАССЕТУ
        NOT     AX                      ;ПОЛУЧИТЬ ОБРАТНЫЙ КОД
        PUSH    AX                      ;СОХРАНИТЬ ЕГО
        XCHG    AH,AL                   ;СТАРШИЙ БАЙТ ЗАПИСЫВАЕТСЯ ПЕРВЫМ
        CALL    WRITE_BYTE              ;ЗАПИСАТЬ ЕГО
        POP     AX                      ;ВОССТАНОВИТЬ МЛАДШИЙ БАЙТ
        CALL    WRITE_BYTE              ;ЗАПИСАТЬ ЕГО
        OR      CX,CX                   ;ВСЕ БАЙТЫ ЗАПИСАНЫ?
        JNZ     WR_BLOCK                ;ЕСЛИ НЕТ ПРОДОЛЖИТЬ
        PUSH    CX                      ;СОХРАНИТЬ CX
        MOV     CX,32                   ;ЗАПИСАТЬ КОНЕЦ ФАЙЛА
W26:                                    ;ЦИКЛ ЗАПИСИ КОНЦА ФАЙЛА
        STC
        CALL    WRITE_BIT
        LOOP    W26                     ;ПИСАТЬ ПОКА ИСЧЕРПАЕТСЯ СЧЕТЧИК
        POP     CX                      ;ВОССТАНОВИТЬ CX
      MOV     AL,0B0H         ;ВОССТАНОВИТЬ РЕЖИМ ТАЙМЕРА
        OUT     TIM_CTL,AL
        MOV     AX,1
        CALL    W31
        IN      AL,PORT_B
        AND     AL,NOT 01H
        OUT     PORT_B,AL
        SUB     AX,AX                   ;НЕТ ОШИБОК ЗАПИСИ
        RET                             ;ЗАКОНЧИТЬ
WRITE_BLOCK     ENDP





                ORG     0FA6EH

INCLUDE CRT_GEN.ASM
;---------------------------------------------------------------------------
; Генератор символов для графических режимов 320*200 и 640*200
;---------------------------------------------------------------------------
CRT_CHAR_GEN    LABEL  BYTE
        DB      000H,000H,000H,000H,000H,000H,000H,000H ; D 00

        DB      07EH,081H,0A5H,081H,0BDH,099H,081H,07EH ; D 01

        DB      07EH,0EFH,0DBH,0EFH,0C3H,0E7H,0EFH,07EH ; D 02

        DB      06CH,0EEH,0EEH,0EEH,07CH,038H,010H,000H ; D 03

        DB      010H,038H,07CH,0EEH,07CH,038H,010H,008H ; D 04

        DB      038H,07CH,038H,0EEH,0EEH,07CH,038H,07CH ; D 05

        DB      010H,010H,038H,07CH,0EEH,07CH,038H,07CH ; D 06

        DB      000H,000H,018H,03CH,03CH,018H,000H,000H ; D 07

        DB      0EFH,0EFH,0E7H,0C3H,0C3H,0E7H,0EFH,0EFH ; D 08

        DB      000H,03CH,066H,042H,042H,066H,03CH,000H ; D 09

        DB      0EFH,0C3H,099H,0BDH,0BDH,099H,0C3H,0EFH ; D 0A

        DB      00FH,007H,00FH,07DH,0CCH,0CCH,0CCH,078H ; D 0B

        DB      03CH,066H,066H,066H,03CH,018H,07EH,018H ; D 0C

        DB      03FH,033H,03FH,030H,030H,070H,0E0H,0E0H ; D 0D

        DB      07FH,063H,07FH,063H,063H,067H,0E6H,0C0H ; D 0E

        DB      099H,05AH,03CH,0E7H,0E7H,03CH,05AH,099H ; D 0F


        DB      080H,0E0H,0E8H,0EEH,0F8H,0E0H,080H,000H ; D 10

        DB      002H,00EH,03EH,0EEH,03EH,00EH,002H,000H ; D 11

        DB      018H,03CH,07EH,018H,018H,07EH,03CH,018H ; D 12

        DB      066H,066H,066H,066H,066H,000H,066H,000H ; D 13

        DB      07FH,0DBH,0DBH,07BH,01BH,01BH,01BH,000H ; D 14

        DB      03EH,063H,038H,06CH,06CH,038H,0CCH,078H ; D 15

        DB      000H,000H,000H,000H,07EH,07EH,07EH,000H ; D 16

        DB      018H,03CH,07EH,018H,07EH,03CH,018H,0EFH ; D 17

        DB      018H,03CH,07EH,018H,018H,018H,018H,000H ; D 18

        DB      018H,018H,018H,018H,07EH,03CH,018H,000H ; D 19

        DB      000H,018H,00CH,0EEH,00CH,018H,000H,000H ; D 1A

        DB      000H,030H,060H,0EEH,060H,030H,000H,000H ; D 1B

        DB      000H,000H,0C0H,0C0H,0C0H,0EEH,000H,000H ; D 1C

        DB      000H,024H,066H,0EFH,066H,024H,000H,000H ; D 1D

        DB      000H,018H,03CH,07EH,0EFH,0EFH,000H,000H ; D 1E

        DB      000H,0EFH,0EFH,07EH,03CH,018H,000H,000H ; D 1F


        DB      000H,000H,000H,000H,000H,000H,000H,000H ; SP D 20

        DB      018H,03CH,03CH,018H,018H,000H,018H,000H ; ! D 21

        DB      036H,036H,036H,000H,000H,000H,000H,000H ; " D 22

        DB      036H,036H,07FH,036H,07FH,036H,036H,000H ; # D 23

        DB      018H,03EH,060H,03CH,006H,07CH,018H,000H ; $ D 24

        DB      000H,063H,066H,00CH,018H,033H,063H,000H ; % D 25

        DB      01CH,036H,01CH,03BH,06EH,066H,03BH,000H ; & D 26

        DB      030H,030H,060H,000H,000H,000H,000H,000H ; ' D 27

        DB      00CH,018H,030H,030H,030H,018H,00CH,000H ; ( D 28

        DB      030H,018H,00CH,00CH,00CH,018H,030H,000H ; ) D 29

        DB      000H,033H,01EH,07FH,01EH,033H,000H,000H ; * D 2A

        DB      000H,018H,018H,07EH,018H,018H,000H,000H ; + D 2B

        DB      000H,000H,000H,000H,000H,018H,018H,030H ; , D 2C

        DB      000H,000H,000H,07EH,000H,000H,000H,000H ; - D 2D

        DB      000H,000H,000H,000H,000H,018H,018H,000H ; . D 2E

        DB      003H,006H,00CH,018H,030H,060H,040H,000H ; / D 2F

        DB      03EH,063H,067H,06FH,07BH,073H,03EH,000H ; 0 D 30

        DB      018H,038H,018H,018H,018H,018H,07EH,000H ; 1 D 31

        DB      03CH,066H,006H,01CH,030H,066H,07EH,000H ; 2 D 32

        DB      03CH,066H,006H,01CH,006H,066H,03CH,000H ; 3 D 33

        DB      00EH,01EH,036H,066H,07FH,006H,00FH,000H ; 4 D 34

        DB      07EH,060H,07CH,006H,006H,066H,03CH,000H ; 5 D 35

        DB      01CH,030H,060H,07CH,066H,066H,03CH,000H ; 6 D 36

        DB      07EH,066H,006H,00CH,018H,018H,018H,000H ; 7 D 37

        DB      03CH,066H,066H,03CH,066H,066H,03CH,000H ; 8 D 38

        DB      03CH,066H,066H,03EH,006H,00CH,038H,000H ; 9 D 39

        DB      000H,018H,018H,000H,000H,018H,018H,000H ; : D 3A

        DB      000H,018H,018H,000H,000H,018H,018H,030H ; ; D 3B

        DB      00CH,018H,030H,060H,030H,018H,00CH,000H ; < D 3C

        DB      000H,000H,07EH,000H,000H,07EH,000H,000H ; = D 3D

        DB      030H,018H,00CH,006H,00CH,018H,030H,000H ; > D 3E

        DB      03CH,066H,006H,00CH,018H,000H,018H,000H ; ? D 3F

        DB      03EH,063H,06FH,06FH,06FH,060H,03CH,000H ; & D 40

        DB      018H,03CH,066H,066H,07EH,066H,066H,000H ; A D 41

        DB      07EH,033H,033H,03EH,033H,033H,07EH,000H ; B D 42

        DB      01EH,033H,060H,060H,060H,033H,01EH,000H ; C D 43

        DB      07CH,036H,033H,033H,033H,036H,07CH,000H ; D D 44

        DB      07FH,031H,034H,03CH,034H,031H,07FH,000H ; E D 45

        DB      07FH,031H,034H,03CH,034H,030H,078H,000H ; F D 46

        DB      01EH,033H,060H,060H,067H,033H,01FH,000H ; G D 47

        DB      066H,066H,066H,07EH,066H,066H,066H,000H ; H D 48

        DB      03CH,018H,018H,018H,018H,018H,03CH,000H ; I D 49

        DB      00FH,006H,006H,006H,066H,066H,03CH,000H ; J D 4A

        DB      073H,033H,036H,03CH,036H,033H,073H,000H ; K D 4B

        DB      078H,030H,030H,030H,031H,033H,07FH,000H ; L D 4C

        DB      063H,077H,07FH,07FH,06BH,063H,063H,000H ; M D 4D

        DB      063H,073H,07BH,06FH,067H,063H,063H,000H ; N D 4E

        DB      01CH,036H,063H,063H,063H,036H,01CH,000H ; O D 4F

        DB      07EH,033H,033H,03EH,030H,030H,078H,000H ; P D 50

        DB      03CH,066H,066H,066H,06EH,03CH,00EH,000H ; Q D 51

        DB      07EH,033H,033H,03EH,036H,033H,073H,000H ; R D 52

        DB      03CH,066H,070H,038H,00EH,066H,03CH,000H ; S D 53

        DB      07EH,05AH,018H,018H,018H,018H,03CH,000H ; T D 54

        DB      066H,066H,066H,066H,066H,066H,07EH,000H ; U D 55

        DB      066H,066H,066H,066H,066H,03CH,018H,000H ; V D 56

        DB      063H,063H,063H,06BH,07FH,077H,063H,000H ; W D 57

        DB      063H,063H,036H,01CH,01CH,036H,063H,000H ; X D 58

        DB      066H,066H,066H,03CH,018H,018H,03CH,000H ; Y D 59

        DB      07FH,063H,046H,00CH,019H,033H,07FH,000H ; Z D 5A

        DB      03CH,030H,030H,030H,030H,030H,03CH,000H ; [ D 5B

        DB      060H,030H,018H,00CH,006H,003H,001H,000H ; BACKSLASH D 5C

        DB      03CH,00CH,00CH,00CH,00CH,00CH,03CH,000H ; ] D 5D

        DB      008H,01CH,036H,063H,000H,000H,000H,000H ; CIRCUMFLEX D 5E

        DB      000H,000H,000H,000H,000H,000H,000H,07FH ;   D 5F

        DB      018H,018H,00CH,000H,000H,000H,000H,000H ;   D 60

        DB      000H,000H,03CH,006H,03EH,066H,03BH,000H ; LOWER CASE A D 61

        DB      070H,030H,030H,03EH,033H,033H,06EH,000H ; L.C. B D 62

        DB      000H,000H,03CH,066H,060H,066H,03CH,000H ; L.C. C D 63

        DB      00EH,006H,006H,03EH,066H,066H,03BH,000H ; L.C. D D 64

        DB      000H,000H,03CH,066H,07EH,060H,03CH,000H ; L.C. E D 65

        DB      01CH,036H,030H,078H,030H,030H,078H,000H ; L.C. F D 66

        DB      000H,000H,03BH,066H,066H,03EH,006H,07CH ; L.C. G D 67

        DB      070H,030H,036H,03BH,033H,033H,073H,000H ; L.C. H D 68

        DB      018H,000H,038H,018H,018H,018H,03CH,000H ; L.C. I D 69

        DB      006H,000H,006H,006H,006H,066H,066H,03CH ; L.C. J D 6A

        DB      070H,030H,033H,036H,03CH,036H,073H,000H ; L.C. K D 6B

        DB      038H,018H,018H,018H,018H,018H,03CH,000H ; L.C. L D 6C

        DB      000H,000H,066H,07FH,07FH,06BH,063H,000H ; L.C. M D 6D

        DB      000H,000H,07CH,066H,066H,066H,066H,000H ; L.C. N D 6E

        DB      000H,000H,03CH,066H,066H,066H,03CH,000H ; L.C. O D 6F

        DB      000H,000H,06EH,033H,033H,03EH,030H,078H ; L.C. P D 70

        DB      000H,000H,03BH,066H,066H,03EH,006H,00FH ; L.C. Q D 71

        DB      000H,000H,06EH,03BH,033H,030H,078H,000H ; L.C. R D 72

        DB      000H,000H,03EH,060H,03CH,006H,07CH,000H ; L.C. S D 73

        DB      008H,018H,03EH,018H,018H,01AH,00CH,000H ; L.C. T D 74

        DB      000H,000H,066H,066H,066H,066H,03BH,000H ; L.C. U D 75

        DB      000H,000H,066H,066H,066H,03CH,018H,000H ; L.C. V D 76

        DB      000H,000H,063H,06BH,07FH,07FH,036H,000H ; L.C. W D 77

        DB      000H,000H,063H,036H,01CH,036H,063H,000H ; L.C. X D 78

        DB      000H,000H,066H,066H,066H,03EH,006H,07CH ; L.C. Y D 79

        DB      000H,000H,07EH,04CH,018H,032H,07EH,000H ; L.C. Z D 7A

        DB      00EH,018H,018H,070H,018H,018H,00EH,000H ;  D 7B

        DB      00CH,00CH,00CH,000H,00CH,00CH,00CH,000H ;  D 7C

        DB      070H,018H,018H,00EH,018H,018H,070H,000H ;  D 7D

        DB      03BH,06EH,000H,000H,000H,000H,000H,000H ;  D 7E

        DB      000H,008H,01CH,036H,063H,063H,07FH,000H ; DELTA D 7F


INCLUDE INT1A.ASM
;---INT 1A-----------------------------------------------------------------
; TIME_OF_DAY
;  Эта программа  выполняет установку/считывание часов
;Вход:
;  (AH)=0 - прочитать текущее значение часов
;           Возвращает: CX - старшая часть счетчика
;                       DX - младшая часть счетчика
;                       AL=0 - если таймер не прошел 24 часа с момента
;                              последнего считывания
;                       AL<>0 - если на следующий день
;  (AH)=1 - установить текущее состояние часов
;           CX - старшая часть счетчика
;           DX - младшая часть счетчика
; Замечание: счет выполняется 1193180/65536 раз в секунду
;       (или около 18.2 в сек)
;----------------------------------------------------------------------------
        ASSUME  CS:CODE,DS:DATA
TIME_OF_DAY     PROC   FAR
        STI                          ;Разрешить прерывания
        PUSH    DS                   ;Сохранить сегмент
        PUSH    AX                   ;Сохранить параметр
        MOV     AX,DATA
        MOV     DS,AX                ;Установить адресацию значений
        POP     AX                   ;Восстановить входной параметр
        OR      AH,AH                ;AH=0
        JZ      T2                   ;Чтение времени
        DEC     AH                   ;AH=1
        JZ      T3                   ;Установка времени
T1:                                  ;Возврат из программы
        STI                          ;Разрешить прерывания
        POP     DS                   ;Восстановить сегмент
        IRET                         ;Возврат
T2:                                  ;Чтение времени
        CLI                          ;Запретить прерывания во время считывания
                                     ; таймера
        MOV     AL,TIMER_OFL
        MOV     TIMER_OFL,0          ;Переплнение, сбросить флаг
        MOV     CX,TIMER_HIGH
        MOV     DX,TIMER_LOW
        JMP     T1                   ;Возврат
T3:                                  ;Установка времени
        CLI                          ;Запретить прерывания во время записи
                                     ; таймера
        MOV     TIMER_LOW,DX
        MOV     TIMER_HIGH,CX        ;Установить время
        MOV     TIMER_OFL,0          ;Сброс переполнения
        JMP     T1                   ;Возврат
TIME_OF_DAY     ENDP

;----------------------------------------------------------------------------
;  Эта подпрограмма обрабатывает неиспользуемые аппаратные прерывания (A - D).
;  Переменная INTR_FLAG будет содержать уровень аппаратного прерывания или
; FF если прерывание не аппаратное.
;----------------------------------------------------------------------------
HARD_RETURN    PROC    NEAR
        PUSH    DS
        PUSH    DX
        PUSH    AX
        MOV     AX,DATA
        MOV     DS,AX                ; сегмент данных
        MOV     AL,0BH               ; команда - чтение IN-SERVICE REG
        OUT     20H,AL               ; определение уровня прерывания
        NOP
        IN      AL,20H               ; ввод уровня прерывания
        MOV     AH,AL
        OR      AL,AH                ; проверка на ноль
                                     ; 0 - нет аппаратного прерывания
        JNZ     HW_INT               ; если аппаратное прерывание было
        MOV     AH,0FFH              ; признак нет прерывания
        JMP     SHORT SET_INTR_FLAG  ;
HW_INT: IN      AL,21H               ; ввод значения маски
        OR      AL,AH                ; сброс бита маски
        OUT     21H,AL
        MOV     AL,20H               ; команда - конец прерывания
        OUT     20H,AL
SET_INTR_FLAG:
        MOV     INTR_FLAG,AH         ; запись признака - номера прерывания
        POP     AX
        POP     DX
        POP     DS
DUMMY_RETURN:
        IRET
HARD_RETURN  ENDP


        ORG     0FEF3H

INCLUDE VEK.ASM
;---------------------------------------------------------------------------
; Эти векторы пересылаются в область прерываний 8086
;  по включении питания
;----------------------------------------------------------------------------
VECTOR_TABLE    LABEL  WORD          ;Таблица векторов прерываний

        DW      DUMMY_RETURN           ;Прерывание 5H

        DW      DUMMY_RETURN           ;Прерывание 6H

        DW      DUMMY_RETURN           ;Прерывание 7H

        DW      OFFSET TIMER_INT     ;Прерывание 8
        DW      OFFSET KB_INT        ;Прерывание 9

        DW      OFFSET HARD_RETURN   ;Прерывание A
        DW      OFFSET HARD_RETURN   ;Прерывание B
        DW      OFFSET HARD_RETURN   ;Прерывание C
        DW      OFFSET HARD_RETURN   ;Прерывание D

        DW      OFFSET SCANINT       ;Прерывание E

        DW      OFFSET HARD_RETURN   ;Прерывание F

        DW      OFFSET VIDEO_IO      ;Прерывание 10H

        DW      OFFSET EQUIPMENT     ;Прерывание 11H

        DW      OFFSET MEMORY_SIZE_DETERMINE   ;Прерывание 12H

        DW      DUMMY_RETURN           ;Прерывание 13H

        DW      DUMMY_RETURN           ;Прерывание 14H

        DW      OFFSET CASSETTE_IO     ;Прерывание 15H

        DW      KEYBOARD_IO            ;Прерывание 16H

        DW      DUMMY_RETURN           ;Прерывание 17H

        DW      OFFSET MONITOR         ;Прерывание 18H (Монитор)

        DW      OFFSET BOOT_STRAP      ;Прерывание 19H

        DW      TIME_OF_DAY            ;Прерывание 1AH (Время суток)

        DW      DUMMY_RETURN           ;Прерывание 1BH (Прерывание клавиатуры)

        DW      DUMMY_RETURN           ;Прерывание 1CH (Прерывание таймера)

        DW      VIDEO_PARMS            ;Прерывание 1DH (Параметры ВИДЕО)

        DW      DUMMY_RETURN           ;Прерывание 1EH (Параметры диска)

        DW      OFFSET ALTC            ;Прерывание 1FH (Указатель VIDEO_EXT)

INCLUDE INT15_NP.ASM

;---------------------------------------------------------------------------
READ_HALF_BIT   PROC    NEAR
; ЦЕЛЬ:
;  ВЫЧИСЛЯЕТ ДЛИТЕЛЬНОСТЬ ПОЛУПЕРИОДА БИТА,
;  Т.Е. ДЛИТЕЛЬНОСТЬ ИНТЕРВАЛА ОТ ОДНОЙ СМЕНЫ УРОВНЯ
;  СИГНАЛА ДО ДРУГОЙ
;
; НА ВХОДЕ:
;  EDGE_CNT СОДЕРЖИТ ЗНАЧЕНИЕ СЧЕТЧИКА ТАЙМЕРА В МОМЕНТ СМЕНЫ УРОВНЯ СИГНАЛА
;
; ON EXIT:
;  AX СОДЕРЖИТ ЗНАЧЕНИЕ СЧЕТЧИКА В МОМЕНТ НОВОЙ СМЕНЫ УРОВНЯ
;  BX СОДЕРЖИТ ДЛИТЕЛЬНОСТЬ ПОЛУПЕРИОДА
;----------------------------------------------------------------------------
        MOV     CX,100                  ;УСТАНОВИТЬ ВРЕМЯ ОЖИДАНИЯ ФРОНТА
        MOV     AH,LAST_VAL             ;AH <-- ТЕКУЩИЙ УРОВЕНЬ СИГНАЛА
W22:                                    ;ЧИТАТЬ ПОЛУБИТ
        IN      AL,PORT_C               ;ВВЕСТИ СИГНАЛ С МАГНИТОФОНА
        AND     AL,010H          ;ВЫДЕЛИТЬ ТРЕБУЕМЫЙ БИТ
        CMP     AL,AH                   ;УРОВЕНЬ ПОМЕНЯЛСЯ?
        LOOPE   W22                     ;ЕСЛИ НЕТ, ПОВТОРИТЬ
        MOV     LAST_VAL,AL             ;СОХРАНИТЬ НОВЫЙ УРОВЕНЬ
        MOV     AL,0                    ;ЧИТАЕМ ТАЙМЕР НА ЛЕТУ
        OUT     TIM_CTL,AL
        IN      AL,TIMER0               ;МЛАДШИЙ БАЙТ
        MOV     AH,AL                   ;СОХРАНЯЕМ В AH
        IN      AL,TIMER0               ;СТАРШИЙ БАЙТ
        XCHG    AL,AH                   ;XCHG AL,AH
        MOV     BX,EDGE_CNT             ;BX <-- ПРЕДЫДУЩЕЕ ЗНАЧЕНИЕ СЧЕТЧИКА
        SUB     BX,AX                   ;BX <-- ДЛИТЕЛЬНОСТЬ ПОЛУПЕРИОДА
        MOV     EDGE_CNT,AX             ;СОХРАНЯЕМ ЗНАЧЕНИЕ СЧЕТЧИКА
        RET
READ_HALF_BIT   ENDP

BREAK_TEST      PROC    NEAR
;----------------------------------------------------------------------------
;  ЦЕЛЬ:
;       ОПРОС КЛАВИАТУРЫ НА ПРЕДМЕТ НАЖАТИЯ КЛАВИШ
;       ESC,TAB ИЛИ CTRL ДЛЯ ПРЕРЫВАНИЯ ЧТЕНИЯ КАССЕТЫ
;
;       ЕСЛИ ЕСТЬ НАЖАТИЕ ОДНОЙ ИЗ ЭТИХ КЛАВИШ - ФЛАГ Z=1
;----------------------------------------------------------------------------
        PUSH    AX                      ;СОХРАНИТЬ AX
        MOV     AL,0FFH
        OUT     60H,AL
        IN      AX,69H                  ;ОПРОСИТЬ ПОРТ КЛАВИАТУРЫ
        AND     AX,080H                  ;ЕСЛИ НАЖАТА КЛАВИША Z<--1
        POP     AX                      ;ВОССТАНОВИТЬ AX
        RET
BREAK_TEST      ENDP


INCLUDE STP1.ASM      ;П/П звукового сигнала и печати сообщений
;-------------------------------------------------------------------------
;  коррекции:
;    12.02.89  - BEEP оформлена стандартной подпрограммой
;-------------------------------------------------------------------------


;----------------- П/П звукового сигнала
;       (BL) - длительность в квантах (квант - ? мс )
;       (BH) - управление тоном

BEEP    PROC    NEAR
        PUSH    AX
        PUSH    CX
        MOV     AL,10110110B         ;Выбрать TIM 2,LSB,MSB,BINARY
        OUT     TIMER+3,AL           ;Записать регистр режимов таймера
        MOV     AL,33H             ;Управление тоном звука
        OUT     TIMER+2,AL           ;Записать счетчик таймера 2
        MOV     AL,BH             ;управление тоном звука
        OUT     TIMER+2,AL           ;Записать счетчик таймера 2
        IN      AL,PORT_B            ;Получить текущее состояние порта
        PUSH    AX                   ;Сохранение значения порта
        OR      AL,03                ;Включить звук
        OUT     PORT_B,AL
        MOV     CX,100H              ;Установить счетчик ожидания 500/64 мс
G7:     LOOP    G7                   ;Задержка перед включением
        DEC     BL                   ;Задержка счетчика закончена?
        JNZ     G7                   ;НЕТ - продолжение подачи сигнала
        POP     AX                   ;Восстановить значение порта
        OUT     PORT_B,AL
        POP     CX
        POP     AX
        RET                          ;Возврат к программе
BEEP    ENDP

;------------------------------------------------------------------------
; Эта подпрограмма выводит звуковой сигнал ошибки начального тестирования
;      (DX) - количество писков
;------------------------------------------------------------------------
BEEP_ERROR    PROC   NEAR
        PUSH     CX
        PUSH     BX
B_ERR_0:
        MOV      BX,0203H
        CALL     BEEP
        MOV      CX,0FFFFH
B_ERR_1:
        NOP
        LOOP     B_ERR_1
        DEC      DX
        JNZ      B_ERR_0
        POP      BX
        POP      CX
        RET
BEEP_ERROR    ENDP


;------------------------------------------------------------------------
;       Эта подпрограмма печатает сообщения на экране.
; Входные условия:
;       SI=смещение (адрес) буфера сообщения
;       CX=счетчик байтов сообщения
;       Максимальный размер передаваемого сообщения - 36 символов
;--------------------------------------------------------------------------
P_MSG   PROC    NEAR
        MOV     AL,CS:[SI]           ;Заслать символ в AL
        INC     SI                   ;Указатель следующего символа
        MOV     BH,0                 ;Установить страницу =0
        MOV     AH,14                ;Записать символ
        INT     10H                  ;Вызов VIDEO_IO
        LOOP    P_MSG                ;Продолжать до конца сообщения
        RET
P_MSG   ENDP

;---------------------------------------------------------------------
; Эта процедура производит подсчет контрольной суммы области памяти
;     DS:BX - начало области памяти
;     CX    - размер
; Если контрольная сумма совпала, то устанавливается флаг Z
;---------------------------------------------------------------------
ROS_CHECKSUM   PROC  NEAR
        XOR     AL,AL
ROS0:   ADD     AL,DS:[BX]
        INC     BX
        LOOP    ROS0
        OR      AL,AL
        RET
ROS_CHECKSUM   ENDP

;-------------------------------------------------------------------
; Эта процедура производит начальную инициализацию программы в ПЗУ
;      DS
;-------------------------------------------------------------------
ROM_INIT       PROC  NEAR
        SUB      AH,AH
        MOV      AL,[BX+2]    ; В рег. (AX) - длина ПЗУ в 512б блоках
        MOV      CL,9
        SHL      AX,CL        ; Умножить (AX) на 512
        PUSH     AX           ; Сохранить (AX)
        MOV      CL,4
        SHR      AX,CL        ; Разделить (AX) на 16
        ADD      DX,AX
        POP      CX           ; (CX) - размер ПЗУ
        CALL     ROS_CHECKSUM
        JZ       ROM_I_0
        PUSH     DX
        MOV      DX,2
        CALL     BEEP_ERROR
        POP      DX
        JMP      ROM_I_RET
ROM_I_0:
        PUSH     DX
        PUSH     CS
        LEA      AX,CS:ROM_I_1
        PUSH     AX
        PUSH     DS
        MOV      AX,3
        PUSH     AX
        DB       0CBH        ;(RETF)
ROM_I_1:
        POP      DX
        SUB      DX,20H
ROM_I_RET:
        RET
ROM_INIT      ENDP



;        ORG     0FF54H

INCLUDE RESTART.ASM

;--------------------------------------------------------------------------
;       Вектор сброса по включении питания
;---------------------------------------------------------------------------
        ORG     0FFF0H
;-------Сброс по включении питания

        JMP     FAR PTR RESETV

        DB      '10/07/88'           ;Маркер даты создания версии BIOS

        DB      0FFH
        DB      0FFH                 ;Маркер IBM/PC
;        DB      0FFH




        CODE   ENDS
nt near (or at) 64K limit
