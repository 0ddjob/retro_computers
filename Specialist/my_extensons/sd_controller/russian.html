<html lang="ru">
<head>
<style>
th {
    text-align: inherit;
}
.tbl2 {
    border-collapse: collapse;
}
.tbl2 > tbody > tr > td, .tbl2 > tbody > tr > th {
    border: 1px solid black;
}
</style>
<meta charset="utf-8">
</head>
<body>
<script language="JavaScript">document.deep=1; document._title = "Контроллер SD карты";</script>
<script language="JavaScript" src="../common.js"></script>

<div class="border" style="clear:right;float:right;width:346px;margin-right:0">
<div style="width:346px;height:370px;background:url(ps2_fuses.png) no-repeat center center">
</div>Фьюзы ATMega8 в Code Vision AVR</div>

<p>Этот контроллер позволяет подключить SD или SDHC карту к компьютеру Специалист. Контроллер позволяет
быстро запускать программы с SD карты. Программы специально разработанные или доработанные для этого контроллера 
могут сохранять файлы на SD карту. В контроллере используется микроконтроллер ATMega8.</p>

<p>Лицензионное соглашение. AS IS. Вы имеете право использовать эти разработки в любых целях, если принимаете
ниже написанное условие. В случае какого-либо ущерба, возникшего по причине использования моих 
разработок, я не несу никакой ответственности. Вы можете даже удалить копирайт и выдавать их за 
свои. Но мне было бы приятнее, если копирайт остался на месте.</p>

<p>Все материалы находятся в репозитории
<a href="https://github.com/alemorf/retro/tree/master/specialist-sd_controller">
https://github.com/alemorf/retro/tree/master/specialist-sd_controller</a>:</p>

<p class="item">Прошивка specsd.hex для ATMega8 в формате Intel HEX, который
должен поддерживать любой программатор.</p>
<p class="item">Схема и печатная плата для микроконтроллера в TQFP корпусе для ЛУТ в формате программы Proteus в формате PNG и формате DOCX (Microsoft Word).</p>
<p class="item">Схема и печатная плата для микроконтроллера в DIP корпусе для ЛУТ в формате программы Proteus.</p>
<p class="item">Печатная плата от Mifody для микроконтроллера в DIP корпусе для ЛУТ в формате Sprint Layout.</p>
<p class="item">Исходники прошивки. Что бы их скомпилировать без лишних усилий, вам потребуется 
среда разработки Code Vision AVR.</p>
<p class="item">Файлы для записи на SD карту: boot.rks, sdbios.rks, shell.rks.</p>
<p class="item">Исходные коды файлов boot.rks, sdbios.rks, shell.rks и компилятор c8080 для них.</p>
<p class="item">Оригинальная прошивка ПЗУ Специалиста.</p>
<p class="item">Прошивка ПЗУ Специалиста со встроенным драйвером SD карты. Нужно, если вы не хотите загружаться через порт магнитофона.</p>

<p>При прошивке микроконтроллера во фьюзах выбираете: внутренний тактовый 
генератор 8 МГц. Пример для Code Vision AVR справа.</p>

<div class="h2">Принцип работы</div>

<p>Контроллер содержит драйвер файловой системы FAT16 / FAT32. Контроллер соединен
со Специалистом через параллельный порт и вход магнитофона. Контроллер подключается
к компьютеру без изменения ПЗУ и схемы компьютера.</p>

<p>Контроллер всегда перезагружается вместе с компьютером. После перезагрузки Специалист
готов загружать программу с магнитной ленты. После перезагрузки контроллера, контроллер читает 
с SD карты файл boot/boot.rks и загружает этот файл в Специалист через вход магнитофона.
Контроллер выполняет модуляцию данных так как нужно Специалисту: фазовая модуляция,
1400 бит в секунду, 32 байта 0x00, стартовый байт 0xE6. У контроллера есть ограничение,
файл boot.rks должен быть меньше 513 байт. Моя версия этого файла занимает 98 байт и
загружается за (32+1+98)*8/1400 = 0,75 секунды.</p>

<p>Программа из файла boot.rks через параллельный порт отправляет контроллеру команду на
загрузку файла boot/sdbios.rks. И через параллельный порт с очень большой скоростью
загружает этот файл в память и запускает. Размер этого файла может быть хоть
во весь размер оперативной памяти, главное, чтобы он не затирал стек и файл boot.rks.</p>

<p>ПЗУ со встроенным драйвером SD карты (находится в репозитории) не требует соединения 
контроллера и компьютера через вход магнитофона. Загрузка начинается сразу с файла
boot/sdbios.rks через параллельный порт.</p>

<p>Файл sdbios содержит набор команд для взаимодействия с SD контроллером. Код
из этого файла загружается в область памяти 8AE7h - 8EFFh. При желании этот код 
можно разместить в любом месте памяти и даже в ПЗУ.</p>

<p>Программа из файла sdbios.rks через параллельный порт отправляет контроллеру команду на
загрузку файла boot/shell.rks.</p>

<p>shell.rks это программа похожая на Norton Commander. Она позволяет запускать программы,
копировать, удалять, переименовывать, перемещать файлы и каталоги. Эта программа обращается
к sdbios для взаимодействия с SD контроллером.</p>

<p>Можно любую программу и игру в формате RKS переименовать в boot/sdbios.rks или boot/shell.rks и она будет запускаться.</p>

<div class="h2">Описание SD BIOS</div>

<p>SD BIOS может быть загружен в любое место памяти, поэтому нельзя общаться к нему по фиксированному адресу.</p>

<p>После запуска вашей программы регистровая пара BC будет содержать точку входа в SD BIOS.
Регистр A будет содержать версию набора команд (сейчас 1).
Регистровая пара HL будет содержать адрес строки - командную строку.
Регистровая пара DE будут содержать адрес строки - имя загруженного файла, т.е. собственное имя программы.
Для вызова функции SD BIOS в регистр A надо поместить код функции (см ниже) и вызвать подпрограмму по адресу, который был в BC при выполнении первой команды вашей программы.</p>

<p>Функции SD BIOS:</p>

<table class="tbl2">
<tr><th>Имя         </th><th>Описание (регистры перед вызовом / регистры после вызова)</th></tr>
<tr><td>Reboot      </td><td>Теплая перезагрузка (A=0, HL="", DE="" / A=код ошибки)<br>"" значит адрес по которому записано число 0.</td></tr>
<tr><td>Exec        </td><td>Запустить программу (A=0, HL=имя файла, DE=командная строка  / A=код ошибки)<br>HL, DE содержат адрес по которому записаны символы и в конце число 0.</td></tr>
<tr><td>FindFirst   </td><td>Начать получение списка файлов (A=1, HL=путь, DE=максимум файлов для загрузки, 
BC=адрес / HL=сколько загрузили, A=код ошибки)</td></tr>
<tr><td>FindNext    </td><td>Продолжить получение списка файлов (A=1, HL=":", DE=максимум файлов для загрузки, 
BC=адрес / HL=сколько загрузили, A=код ошибки)</td></tr>
<tr><td>Open        </td><td>Открыть файл       (A=2, D=0,   HL=имя файла / A=код ошибки)</td></tr>
<tr><td>Create      </td><td>Создать файл       (A=2, D=1,   HL=имя файла / A=код ошибки)</td></tr>
<tr><td>MkDir       </td><td>Создать папку      (A=2, D=2,   HL=имя файла / A=код ошибки)</td></tr>
<tr><td>Delete      </td><td>Удалить файл/папку (A=2, D=100, HL=имя файла / A=код ошибки)</td></tr>
<tr><td>Seek        </td><td>Установить позицию чтения записи файла (A=3, B=режим, DE:HL=позиция / A=код ошибки, DE:HL=позиция)
(С начала B=0, с текущего положения B=1, с конца B=2)</td></tr>
<tr><td>GetFileSize </td><td>Получить размер файла (A=3, B=100 / A=код ошибки, DE:HL= размер файла)</td></tr>
<tr><td>GetDiskSize </td><td>Получить размер диска в Мб (A=3, B=101 / A=код ошибки, DE:HL= размер диска)</td></tr>
<tr><td>GetDiskFree </td><td>Получить свободное место на диске в Мб (A=3, B=102 / A=код ошибки, DE:HL= размер файла)</td></tr>
<tr><td>SwapFiles   </td><td>Работа с двумя открытыми файлами (A=3, B=200 / A=код ошибки)</td></tr>
<tr><td>Read        </td><td>Прочитать из файла (A=4, HL=размер, DE=адрес / A=код ошибки, HL=сколько загрузили)</td></tr>
<tr><td>Write       </td><td>Записать в файл (A=5, HL=размер, DE=адрес / A=код ошибки)</td></tr>
<tr><td>WriteEOF    </td><td>Конец файла (A=5, HL=0 / A=код ошибки)</td></tr>
<tr><td>Move        </td><td>Переместить файл/папку (A=6, HL=из, DE=в / A=код ошибки)</td></tr>
</table>

<p>После запуска SD BIOS карта памяти выглядит так:</p>

<table class="tbl2">
<tr><th>Адрес</td><th>Имя            </th><th>Описание</th></tr>
<tr><td>8AE7h</td><td>SELF_NAME      </td><td>Собственное имя файла 256 байт (этот адрес содержится в DE после запуска)</td></tr>
<tr><td>8BE7h</td><td>CMD_LINE       </td><td>Командная строка 256 байт (этот адрес содержится в HL после запуска)</td></tr>
<tr><td>8CE7h</td><td>SD_BIOS_CODE   </td><td>Код SD BIOS 537 байт (возможно будет расти в начало сдвигая SELF_NAME и CMD_LINE)</td></tr>
<tr><td>8F00h</td><td>-              </td><td>Не используется ~233 байта (возможно тут есть переменные монитора)</td></tr>
<tr><td>8FDFh</td><td>MONITOR_VARS   </td><td>Переменные монитора</td></tr>
<tr><td>9000h</td><td>VIDEO_MEM      </td><td>Видеопамять</td></tr> 
</table>

<p>С самого начала памяти свободно 35 559 байт памяти (до 8AE7h). Дальше находятся переменные 
SELF_NAME, CMD_LINE. Если они не нужны программисту, то объем непрерывной свободной памяти 
составляет ~36 071 байт (до 8CE7h). </p>

<p>Свободное место по адресу 8F00h оставлено на всякий случай. Что бы не конфликтовать
с Монитором. Возможно, что будущие версии SD BIOS будут использовать эту память.</p>

<div class="h2">Схема</div>

<img src="sd_cir.png" width="100%">

<div class="h2">Готовое устройство</div>

<img src="sd_ready.jpg" width="100%"><br><br>

<img src="sd_ready2.jpg" width="100%"><br><br>

<img src="sd_ready3.jpg" width="100%">

</body>
</html>
